"use strict"
var __create = Object.create
var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropNames = Object.getOwnPropertyNames
var __getProtoOf = Object.getPrototypeOf
var __hasOwnProp = Object.prototype.hasOwnProperty
var _globalThis = {}
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res
}
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports
}
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable })
  }
  return to
}
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
))
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod)
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value)
  return value
}

// node_modules/@esbuild-plugins/node-globals-polyfill/process.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined")
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0)
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout
    return setTimeout(fun, 0)
  }
  try {
    return cachedSetTimeout(fun, 0)
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0)
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0)
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker)
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout
    return clearTimeout(marker)
  }
  try {
    return cachedClearTimeout(marker)
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker)
    } catch (e2) {
      return cachedClearTimeout.call(this, marker)
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return
  }
  draining = false
  if (currentQueue.length) {
    queue = currentQueue.concat(queue)
  } else {
    queueIndex = -1
  }
  if (queue.length) {
    drainQueue()
  }
}
function drainQueue() {
  if (draining) {
    return
  }
  var timeout = runTimeout(cleanUpNextTick)
  draining = true
  var len = queue.length
  while (len) {
    currentQueue = queue
    queue = []
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run()
      }
    }
    queueIndex = -1
    len = queue.length
  }
  currentQueue = null
  draining = false
  runClearTimeout(timeout)
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1)
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i]
    }
  }
  queue.push(new Item(fun, args))
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue)
  }
}
function Item(fun, array) {
  this.fun = fun
  this.array = array
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported")
}
function cwd() {
  return "/"
}
function chdir(dir) {
  throw new Error("process.chdir is not supported")
}
function umask() {
  return 0
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3
  var seconds = Math.floor(clocktime)
  var nanoseconds = Math.floor(clocktime % 1 * 1e9)
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0]
    nanoseconds = nanoseconds - previousTimestamp[1]
    if (nanoseconds < 0) {
      seconds--
      nanoseconds += 1e9
    }
  }
  return [seconds, nanoseconds]
}
function uptime() {
  var currentTime = /* @__PURE__ */ new Date()
  var dif = currentTime - startTime
  return dif / 1e3
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, process, defines
var init_process = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
    cachedSetTimeout = defaultSetTimout
    cachedClearTimeout = defaultClearTimeout
    if (typeof _globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout
    }
    if (typeof _globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout
    }
    queue = []
    draining = false
    queueIndex = -1
    Item.prototype.run = function () {
      this.fun.apply(null, this.array)
    }
    title = "browser"
    platform = "browser"
    browser = true
    env = {}
    argv = []
    version = ""
    versions = {}
    release = {}
    config = {}
    on = noop
    addListener = noop
    once = noop
    off = noop
    removeListener = noop
    removeAllListeners = noop
    emit = noop
    performance = _globalThis.performance || {}
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
      return (/* @__PURE__ */ new Date()).getTime()
    }
    startTime = /* @__PURE__ */ new Date()
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    }
    defines = {}
    Object.keys(defines).forEach((key) => {
      const segs = key.split(".")
      let target = process
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i]
        if (i === segs.length - 1) {
          target[seg] = defines[key]
        } else {
          target = target[seg] || (target[seg] = {})
        }
      }
    })
  }
})

// node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }
  revLookup["-".charCodeAt(0)] = 62
  revLookup["_".charCodeAt(0)] = 63
}
function base64toByteArray(b64) {
  if (!inited) {
    init()
  }
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4")
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0
  arr = new Arr(len * 3 / 4 - placeHolders)
  l = placeHolders > 0 ? len - 4 : len
  var L = 0
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = tmp >> 16 & 255
    arr[L++] = tmp >> 8 & 255
    arr[L++] = tmp & 255
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4
    arr[L++] = tmp & 255
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2
    arr[L++] = tmp >> 8 & 255
    arr[L++] = tmp & 255
  }
  return arr
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63]
}
function encodeChunk(uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]
    output.push(tripletToBase64(tmp))
  }
  return output.join("")
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init()
  }
  var tmp
  var len = uint8.length
  var extraBytes = len % 3
  var output = ""
  var parts = []
  var maxChunkLength = 16383
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i,
        i + maxChunkLength > len2 ? len2 : i + maxChunkLength
      )
    )
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[tmp << 4 & 63]
    output += "=="
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    output += lookup[tmp >> 10]
    output += lookup[tmp >> 4 & 63]
    output += lookup[tmp << 2 & 63]
    output += "="
  }
  parts.push(output)
  return parts.join("")
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length")
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length)
    that.__proto__ = Buffer2.prototype
  } else {
    if (that === null) {
      that = new Buffer2(length)
    }
    that.length = length
  }
  return that
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length)
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number')
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset)
  }
  return fromObject(that, value)
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3)
  }
  return createBuffer(that, size)
}
function allocUnsafe(that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8"
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }
  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)
  var actual = that.write(string, encoding)
  if (actual !== length) {
    that = that.slice(0, actual)
  }
  return that
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds")
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds")
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array)
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array
    that.__proto__ = Buffer2.prototype
  } else {
    that = fromArrayLike(that, array)
  }
  return that
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)
    if (that.length === 0) {
      return that
    }
    obj.copy(that, 0, 0, len)
    return that
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  )
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    )
  }
  return length | 0
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer)
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== "string") {
    string = "" + string
  }
  var len = string.length
  if (len === 0)
    return 0
  var loweredCase = false
  for (; ;) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2
      case "hex":
        return len >>> 1
      case "base64":
        return base64ToBytes(string).length
      default:
        if (loweredCase)
          return utf8ToBytes(string).length
        encoding = ("" + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false
  if (start === void 0 || start < 0) {
    start = 0
  }
  if (start > this.length) {
    return ""
  }
  if (end === void 0 || end > this.length) {
    end = this.length
  }
  if (end <= 0) {
    return ""
  }
  end >>>= 0
  start >>>= 0
  if (end <= start) {
    return ""
  }
  if (!encoding)
    encoding = "utf8"
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end)
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end)
      case "ascii":
        return asciiSlice(this, start, end)
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end)
      case "base64":
        return base64Slice(this, start, end)
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end)
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding)
        encoding = (encoding + "").toLowerCase()
        loweredCase = true
    }
  }
}
function swap(b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1
  if (typeof byteOffset === "string") {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648
  }
  byteOffset = +byteOffset
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1
    else
      byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0
    else
      return -1
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding)
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === "number") {
    val = val & 255
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer,
          val,
          byteOffset
        )
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer,
          val,
          byteOffset
        )
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }
  throw new TypeError("val must be string, number or Buffer")
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase()
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2]
    } else {
      return buf.readUInt16BE(i2 * indexSize)
    }
  }
  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false
          break
        }
      }
      if (found)
        return i
    }
  }
  return -1
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  var strLen = string.length
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string")
  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed))
      return i
    buf[offset + i] = parsed
  }
  return i
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(
    utf8ToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  )
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(
    utf16leToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  )
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf)
  } else {
    return base64fromByteArray(buf.slice(start, end))
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []
  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533
      bytesPerSequence = 1
    } else if (codePoint > 65535) {
      codePoint -= 65536
      res.push(codePoint >>> 10 & 1023 | 55296)
      codePoint = 56320 | codePoint & 1023
    }
    res.push(codePoint)
    i += bytesPerSequence
  }
  return decodeCodePointsArray(res)
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints)
  }
  var res = ""
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}
function asciiSlice(buf, start, end) {
  var ret = ""
  end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127)
  }
  return ret
}
function latin1Slice(buf, start, end) {
  var ret = ""
  end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}
function hexSlice(buf, start, end) {
  var len = buf.length
  if (!start || start < 0)
    start = 0
  if (!end || end < 0 || end > len)
    end = len
  var out = ""
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ""
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint")
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length")
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range")
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range")
  if (offset < 0)
    throw new RangeError("Index out of range")
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    )
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    )
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "")
  if (str.length < 2)
    return ""
  while (str.length % 4 !== 0) {
    str = str + "="
  }
  return str
}
function stringtrim(str) {
  if (str.trim)
    return str.trim()
  return str.replace(/^\s+|\s+$/g, "")
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16)
  return n.toString(16)
}
function utf8ToBytes(string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189)
          continue
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189)
          continue
        }
        leadSurrogate = codePoint
        continue
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189)
        leadSurrogate = codePoint
        continue
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189)
    }
    leadSurrogate = null
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break
      bytes.push(codePoint)
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128)
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      )
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      )
    } else {
      throw new Error("Invalid code point")
    }
  }
  return bytes
}
function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255)
  }
  return byteArray
}
function utf16leToBytes(str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }
  return byteArray
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str))
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break
    dst[i + offset] = src[i]
  }
  return i
}
function isnan(val) {
  return val !== val
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj)
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0))
}
function ieee754read(buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? nBytes - 1 : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]
  i += d
  e = s & (1 << -nBits) - 1
  s >>= -nBits
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1
  e >>= -nBits
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}
function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
  var i = isLE ? 0 : nBytes - 1
  var d = isLE ? 1 : -1
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
  value = Math.abs(value)
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }
    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE
var init_Buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    init_process()
    init_buffer()
    lookup = []
    revLookup = []
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array
    inited = false
    Buffer2.TYPED_ARRAY_SUPPORT = _globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? _globalThis.TYPED_ARRAY_SUPPORT : true
    Buffer2.poolSize = 8192
    Buffer2._augment = function (arr) {
      arr.__proto__ = Buffer2.prototype
      return arr
    }
    Buffer2.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    }
    Buffer2.kMaxLength = kMaxLength()
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype
      Buffer2.__proto__ = Uint8Array
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function (size, fill3, encoding) {
      return alloc(null, size, fill3, encoding)
    }
    Buffer2.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    }
    Buffer2.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    }
    Buffer2.isBuffer = isBuffer
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers")
      }
      if (a === b)
        return 0
      var x = a.length
      var y = b.length
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
      if (x < y)
        return -1
      if (y < x)
        return 1
      return 0
    }
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true
        default:
          return false
      }
    }
    Buffer2.concat = function concat(list2, length) {
      if (!Array.isArray(list2)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      if (list2.length === 0) {
        return Buffer2.alloc(0)
      }
      var i
      if (length === void 0) {
        length = 0
        for (i = 0; i < list2.length; ++i) {
          length += list2[i].length
        }
      }
      var buffer = Buffer2.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list2.length; ++i) {
        var buf = list2[i]
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }
    Buffer2.byteLength = byteLength
    Buffer2.prototype._isBuffer = true
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits")
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits")
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits")
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0
      if (length === 0)
        return ""
      if (arguments.length === 0)
        return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer")
      if (this === b)
        return true
      return Buffer2.compare(this, b) === 0
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer")
      }
      if (start === void 0) {
        start = 0
      }
      if (end === void 0) {
        end = target ? target.length : 0
      }
      if (thisStart === void 0) {
        thisStart = 0
      }
      if (thisEnd === void 0) {
        thisEnd = this.length
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index")
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
      if (this === target)
        return 0
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
      if (x < y)
        return -1
      if (y < x)
        return 1
      return 0
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8"
        length = this.length
        offset = 0
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset
        length = this.length
        offset = 0
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === void 0)
            encoding = "utf8"
        } else {
          encoding = length
          length = void 0
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        )
      }
      var remaining = this.length - offset
      if (length === void 0 || length > remaining)
        length = remaining
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds")
      }
      if (!encoding)
        encoding = "utf8"
      var loweredCase = false
      for (; ;) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length)
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length)
          case "ascii":
            return asciiWrite(this, string, offset, length)
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length)
          case "base64":
            return base64Write(this, string, offset, length)
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length)
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding)
            encoding = ("" + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    MAX_ARGUMENTS_LENGTH = 4096
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length
      start = ~~start
      end = end === void 0 ? len : ~~end
      if (start < 0) {
        start += len
        if (start < 0)
          start = 0
      } else if (start > len) {
        start = len
      }
      if (end < 0) {
        end += len
        if (end < 0)
          end = 0
      } else if (end > len) {
        end = len
      }
      if (end < start)
        end = start
      var newBuf
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer2.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer2(sliceLen, void 0)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }
      return newBuf
    }
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length)
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul
      }
      return val
    }
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length)
      }
      var val = this[offset + --byteLength3]
      var mul = 1
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul
      }
      return val
    }
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length)
      return this[offset]
    }
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length)
      return this[offset] | this[offset + 1] << 8
    }
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length)
      return this[offset] << 8 | this[offset + 1]
    }
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
    }
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
    }
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length)
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul
      }
      mul *= 128
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3)
      return val
    }
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length)
      var i = byteLength3
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul
      }
      mul *= 128
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3)
      return val
    }
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length)
      if (!(this[offset] & 128))
        return this[offset]
      return (255 - this[offset] + 1) * -1
    }
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length)
      var val = this[offset] | this[offset + 1] << 8
      return val & 32768 ? val | 4294901760 : val
    }
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | this[offset] << 8
      return val & 32768 ? val | 4294901760 : val
    }
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
    }
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
    }
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return ieee754read(this, offset, true, 23, 4)
    }
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length)
      return ieee754read(this, offset, false, 23, 4)
    }
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length)
      return ieee754read(this, offset, true, 52, 8)
    }
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length)
      return ieee754read(this, offset, false, 52, 8)
    }
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1
        checkInt(this, value, offset, byteLength3, maxBytes, 0)
      }
      var mul = 1
      var i = 0
      this[offset] = value & 255
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255
      }
      return offset + byteLength3
    }
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1
        checkInt(this, value, offset, byteLength3, maxBytes, 0)
      }
      var i = byteLength3 - 1
      var mul = 1
      this[offset + i] = value & 255
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255
      }
      return offset + byteLength3
    }
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0)
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value)
      this[offset] = value & 255
      return offset + 1
    }
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8
        this[offset + 1] = value & 255
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24
        this[offset + 2] = value >>> 16
        this[offset + 1] = value >>> 8
        this[offset] = value & 255
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24
        this[offset + 1] = value >>> 16
        this[offset + 2] = value >>> 8
        this[offset + 3] = value & 255
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1)
        checkInt(this, value, offset, byteLength3, limit - 1, -limit)
      }
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 255
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = (value / mul >> 0) - sub & 255
      }
      return offset + byteLength3
    }
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1)
        checkInt(this, value, offset, byteLength3, limit - 1, -limit)
      }
      var i = byteLength3 - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 255
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = (value / mul >> 0) - sub & 255
      }
      return offset + byteLength3
    }
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128)
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value)
      if (value < 0)
        value = 255 + value + 1
      this[offset] = value & 255
      return offset + 1
    }
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8
        this[offset + 1] = value & 255
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648)
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
        this[offset + 2] = value >>> 16
        this[offset + 3] = value >>> 24
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648)
      if (value < 0)
        value = 4294967295 + value + 1
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24
        this[offset + 1] = value >>> 16
        this[offset + 2] = value >>> 8
        this[offset + 3] = value & 255
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0
      if (!end && end !== 0)
        end = this.length
      if (targetStart >= target.length)
        targetStart = target.length
      if (!targetStart)
        targetStart = 0
      if (end > 0 && end < start)
        end = start
      if (end === start)
        return 0
      if (target.length === 0 || this.length === 0)
        return 0
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds")
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds")
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds")
      if (end > this.length)
        end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
      var len = end - start
      var i
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }
      return len
    }
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === "string") {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string")
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding)
        }
      } else if (typeof val === "number") {
        val = val & 255
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index")
      }
      if (end <= start) {
        return this
      }
      start = start >>> 0
      end = end === void 0 ? this.length : end >>> 0
      if (!val)
        val = 0
      var i
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
      return this
    }
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
  }
})

// node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    init_Buffer()
  }
})

// node_modules/zotero-plugin-toolkit/dist/utils/debugBridge.js
var require_debugBridge = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/utils/debugBridge.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __importDefault = exports && exports.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : { "default": mod }
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.DebugBridge = void 0
    var basic_1 = require_basic()
    var toolkitGlobal_1 = __importDefault(require_toolkitGlobal())
    var DebugBridge = class {
      get version() {
        return DebugBridge.version
      }
      get disableDebugBridgePassword() {
        return this._disableDebugBridgePassword
      }
      set disableDebugBridgePassword(value) {
        this._disableDebugBridgePassword = value
      }
      get password() {
        return basic_1.BasicTool.getZotero().Prefs.get(DebugBridge.passwordPref, true)
      }
      set password(v) {
        basic_1.BasicTool.getZotero().Prefs.set(DebugBridge.passwordPref, v, true)
      }
      constructor() {
        this._disableDebugBridgePassword = false
        this.initializeDebugBridge()
      }
      static setModule(instance) {
        var _a
        if (!((_a = instance.debugBridge) === null || _a === void 0 ? void 0 : _a.version) || instance.debugBridge.version < DebugBridge.version) {
          instance.debugBridge = new DebugBridge()
        }
      }
      initializeDebugBridge() {
        const debugBridgeExtension = {
          noContent: true,
          doAction: async (uri) => {
            var _a
            const Zotero2 = basic_1.BasicTool.getZotero()
            const uriString = uri.spec.split("//").pop()
            if (!uriString) {
              return
            }
            const params = {};
            (_a = uriString.split("?").pop()) === null || _a === void 0 ? void 0 : _a.split("&").forEach((p) => {
              params[p.split("=")[0]] = p.split("=")[1]
            })
            if (toolkitGlobal_1.default.getInstance().debugBridge.disableDebugBridgePassword || params.password === this.password) {
              if (params.run) {
                try {
                  const AsyncFunction = Object.getPrototypeOf(async function () {
                  }).constructor
                  const f = new AsyncFunction("Zotero,window", decodeURIComponent(params.run))
                  await f(Zotero2, Zotero2.getMainWindow())
                } catch (e) {
                  Zotero2.debug(e)
                  Zotero2.getMainWindow().console.log(e)
                }
              }
              if (params.file) {
                try {
                  Services.scriptloader.loadSubScript(decodeURIComponent(params.file), { Zotero: Zotero2, window: Zotero2.getMainWindow() })
                } catch (e) {
                  Zotero2.debug(e)
                  Zotero2.getMainWindow().console.log(e)
                }
              }
            }
          },
          newChannel: function (uri) {
            this.doAction(uri)
          }
        }
        Services.io.getProtocolHandler("zotero").wrappedJSObject._extensions["zotero://ztoolkit-debug"] = debugBridgeExtension
      }
    }
    exports.DebugBridge = DebugBridge
    DebugBridge.version = 1
    DebugBridge.passwordPref = "extensions.zotero.debug-bridge.password"
  }
})

// node_modules/zotero-plugin-toolkit/dist/managers/toolkitGlobal.js
var require_toolkitGlobal = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/managers/toolkitGlobal.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.ToolkitGlobal = void 0
    var basic_1 = require_basic()
    var debugBridge_1 = require_debugBridge()
    var ToolkitGlobal = class {
      constructor() {
        initializeModules(this)
      }
      /**
       * Get the global unique instance of `class ToolkitGlobal`.
       * @returns An instance of `ToolkitGlobal`.
       */
      static getInstance() {
        const Zotero2 = basic_1.BasicTool.getZotero()
        if (!("_toolkitGlobal" in Zotero2)) {
          Zotero2._toolkitGlobal = new ToolkitGlobal()
        } else {
          initializeModules(Zotero2._toolkitGlobal)
        }
        return Zotero2._toolkitGlobal
      }
    }
    exports.ToolkitGlobal = ToolkitGlobal
    function initializeModules(instance) {
      setModule(instance, "fieldHooks", {
        _ready: false,
        getFieldHooks: {},
        setFieldHooks: {},
        isFieldOfBaseHooks: {}
      })
      setModule(instance, "itemTree", {
        _ready: false,
        columns: [],
        renderCellHooks: {}
      })
      setModule(instance, "itemBox", {
        _ready: false,
        fieldOptions: {}
      })
      setModule(instance, "shortcut", {
        _ready: false,
        eventKeys: []
      })
      setModule(instance, "prompt", {
        _ready: false,
        instance: void 0
      })
      setModule(instance, "readerInstance", {
        _ready: false,
        initializedHooks: {}
      })
      debugBridge_1.DebugBridge.setModule(instance)
    }
    function setModule(instance, key, module3) {
      var _a
      var _b
      if (!module3) {
        return
      }
      if (!instance[key]) {
        instance[key] = module3
      }
      for (const moduleKey in module3) {
        (_a = (_b = instance[key])[moduleKey]) !== null && _a !== void 0 ? _a : _b[moduleKey] = module3[moduleKey]
      }
    }
    exports.default = ToolkitGlobal
  }
})

// node_modules/zotero-plugin-toolkit/dist/basic.js
var require_basic = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/basic.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __importDefault = exports && exports.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : { "default": mod }
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.unregister = exports.ManagerTool = exports.BasicTool = void 0
    var toolkitGlobal_1 = __importDefault(require_toolkitGlobal())
    var BasicTool4 = class {
      get basicOptions() {
        return this._basicOptions
      }
      /**
       *
       * @param basicTool Pass an BasicTool instance to copy its options.
       */
      constructor(data) {
        this.patchSign = "zotero-plugin-toolkit@2.0.0"
        this._basicOptions = {
          log: {
            _type: "toolkitlog",
            disableConsole: false,
            disableZLog: false,
            prefix: ""
          },
          debug: toolkitGlobal_1.default.getInstance().debugBridge
        }
        this.updateOptions(data)
        return
      }
      getGlobal(k) {
        const _Zotero = typeof Zotero !== "undefined" ? Zotero : Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject
        const window2 = _Zotero.getMainWindow()
        switch (k) {
          case "Zotero":
          case "zotero":
            return _Zotero
          case "window":
            return window2
          case "document":
            return window2.document
          case "ZoteroPane":
          case "ZoteroPane_Local":
            return _Zotero.getActiveZoteroPane()
          default:
            return window2[k]
        }
      }
      /**
       * Check if it's running on Zotero 7 (Firefox 102)
       */
      isZotero7() {
        return Zotero.platformMajorVersion >= 102
      }
      /**
       * Get DOMParser.
       *
       * For Zotero 6: mainWindow.DOMParser or nsIDOMParser
       *
       * For Zotero 7: Firefox 102 support DOMParser natively
       */
      getDOMParser() {
        if (this.isZotero7()) {
          return new (this.getGlobal("DOMParser"))()
        }
        try {
          return new (this.getGlobal("DOMParser"))()
        } catch (e) {
          return Components.classes["@mozilla.org/xmlextras/domparser;1"].createInstance(Components.interfaces.nsIDOMParser)
        }
      }
      /**
       * If it's an XUL element
       * @param elem
       */
      isXULElement(elem) {
        return elem.namespaceURI === "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
      }
      /**
       * Create an XUL element
       *
       * For Zotero 6, use `createElementNS`;
       *
       * For Zotero 7+, use `createXULElement`.
       * @param doc
       * @param type
       * @example
       * Create a `<menuitem>`:
       * ```ts
       * const compat = new ZoteroCompat();
       * const doc = compat.getWindow().document;
       * const elem = compat.createXULElement(doc, "menuitem");
       * ```
       */
      createXULElement(doc, type2) {
        if (this.isZotero7()) {
          return doc.createXULElement(type2)
        } else {
          return doc.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", type2)
        }
      }
      /**
       * Output to both Zotero.debug and console.log
       * @param data e.g. string, number, object, ...
       */
      log(...data) {
        var _a
        if (data.length === 0) {
          return
        }
        const Zotero2 = this.getGlobal("Zotero")
        const console2 = this.getGlobal("console")
        let options2
        if (((_a = data[data.length - 1]) === null || _a === void 0 ? void 0 : _a._type) === "toolkitlog") {
          options2 = data.pop()
        } else {
          options2 = this._basicOptions.log
        }
        try {
          if (options2.prefix) {
            data.splice(0, 0, options2.prefix)
          }
          if (!options2.disableConsole) {
            console2.groupCollapsed(...data)
            console2.trace()
            console2.groupEnd()
          }
          if (!options2.disableZLog) {
            Zotero2.debug(data.map((d) => {
              try {
                return typeof d === "object" ? JSON.stringify(d) : String(d)
              } catch (e) {
                Zotero2.debug(d)
                return ""
              }
            }).join("\n"))
          }
        } catch (e) {
          console2.error(e)
          Zotero2.logError(e)
        }
      }
      /**
       * Patch a function
       * @param object The owner of the function
       * @param funcSign The signature of the function(function name)
       * @param ownerSign The signature of patch owner to avoid patching again
       * @param patcher The new wrapper of the patched funcion
       */
      patch(object, funcSign, ownerSign, patcher) {
        if (object[funcSign][ownerSign]) {
          throw new Error(`${String(funcSign)} re-patched`)
        }
        this.log("patching", funcSign, `by ${ownerSign}`)
        object[funcSign] = patcher(object[funcSign])
        object[funcSign][ownerSign] = true
      }
      updateOptions(source) {
        if (!source) {
          return
        }
        if (source instanceof BasicTool4) {
          this._basicOptions = source._basicOptions
        } else {
          this._basicOptions = source
        }
      }
      static getZotero() {
        return typeof Zotero !== "undefined" ? Zotero : Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject
      }
    }
    exports.BasicTool = BasicTool4
    var ManagerTool2 = class extends BasicTool4 {
    }
    exports.ManagerTool = ManagerTool2
    function unregister2(tools) {
      Object.values(tools).forEach((tool) => {
        if (tool instanceof ManagerTool2 || typeof tool.unregisterAll === "function") {
          tool.unregisterAll()
        }
      })
    }
    exports.unregister = unregister2
  }
})

// node_modules/zotero-plugin-toolkit/dist/tools/ui.js
var require_ui = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/tools/ui.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.UITool = void 0
    var basic_1 = require_basic()
    var UITool3 = class extends basic_1.BasicTool {
      get basicOptions() {
        return this._basicOptions
      }
      constructor(base2) {
        super(base2)
        this.elementCache = []
        if (!this._basicOptions.ui) {
          this._basicOptions.ui = {
            enableElementRecord: true,
            enableElementJSONLog: false,
            enableElementDOMLog: true
          }
        }
      }
      /**
       * Remove all elements created by `createElement`.
       *
       * @remarks
       * > What is this for?
       *
       * In bootstrap plugins, elements must be manually maintained and removed on exiting.
       *
       * This API does this for you.
       */
      unregisterAll() {
        this.elementCache.forEach((e) => {
          try {
            e === null || e === void 0 ? void 0 : e.remove()
          } catch (e2) {
            this.log(e2)
          }
        })
      }
      createElement(...args) {
        var _a, _b, _c
        const doc = args[0]
        const tagName = args[1].toLowerCase()
        let props = args[2] || {}
        if (!tagName) {
          return
        }
        if (typeof args[2] === "string") {
          props = {
            namespace: args[2],
            enableElementRecord: args[3]
          }
        }
        if (typeof props.enableElementJSONLog !== "undefined" && props.enableElementJSONLog || this.basicOptions.ui.enableElementJSONLog) {
          this.log(props)
        }
        props.properties = props.properties || props.directAttributes
        props.children = props.children || props.subElementOptions
        let elem
        if (tagName === "fragment") {
          const fragElem = doc.createDocumentFragment()
          elem = fragElem
        } else {
          let realElem = props.id && (props.checkExistenceParent ? props.checkExistenceParent : doc).querySelector(`#${props.id}`)
          if (realElem && props.ignoreIfExists) {
            return realElem
          }
          if (realElem && props.removeIfExists) {
            realElem.remove()
            realElem = void 0
          }
          if (props.customCheck && !props.customCheck(doc, props)) {
            return void 0
          }
          if (!realElem || !props.skipIfExists) {
            let namespace = props.namespace
            if (!namespace) {
              const mightHTML = HTMLElementTagNames.includes(tagName)
              const mightXUL = XULElementTagNames.includes(tagName)
              const mightSVG = SVGElementTagNames.includes(tagName)
              if (Number(mightHTML) + Number(mightXUL) + Number(mightSVG) > 1) {
                this.log(`[Warning] Creating element ${tagName} with no namespace specified. Found multiply namespace matches.`)
              }
              if (mightHTML) {
                namespace = "html"
              } else if (mightXUL) {
                namespace = "xul"
              } else if (mightSVG) {
                namespace = "svg"
              } else {
                namespace = "html"
              }
            }
            if (namespace === "xul") {
              realElem = this.createXULElement(doc, tagName)
            } else {
              realElem = doc.createElementNS({
                html: "http://www.w3.org/1999/xhtml",
                svg: "http://www.w3.org/2000/svg"
              }[namespace], tagName)
            }
            this.elementCache.push(realElem)
          }
          if (props.id) {
            realElem.id = props.id
          }
          if (props.styles && Object.keys(props.styles).length) {
            Object.keys(props.styles).forEach((k) => {
              const v = props.styles[k]
              typeof v !== "undefined" && (realElem.style[k] = v)
            })
          }
          if (props.properties && Object.keys(props.properties).length) {
            Object.keys(props.properties).forEach((k) => {
              const v = props.properties[k]
              typeof v !== "undefined" && (realElem[k] = v)
            })
          }
          if (props.attributes && Object.keys(props.attributes).length) {
            Object.keys(props.attributes).forEach((k) => {
              const v = props.attributes[k]
              typeof v !== "undefined" && realElem.setAttribute(k, String(v))
            })
          }
          if ((_a = props.classList) === null || _a === void 0 ? void 0 : _a.length) {
            realElem.classList.add(...props.classList)
          }
          if ((_b = props.listeners) === null || _b === void 0 ? void 0 : _b.length) {
            props.listeners.forEach(({ type: type2, listener, options: options2 }) => {
              listener && realElem.addEventListener(type2, listener, options2)
            })
          }
          elem = realElem
        }
        if ((_c = props.children) === null || _c === void 0 ? void 0 : _c.length) {
          const subElements = props.children.map((childProps) => {
            childProps.namespace = childProps.namespace || props.namespace
            return this.createElement(doc, childProps.tag, childProps)
          }).filter((e) => e)
          elem.append(...subElements)
        }
        if (typeof props.enableElementDOMLog !== "undefined" && props.enableElementDOMLog || this.basicOptions.ui.enableElementDOMLog) {
          this.log(elem)
        }
        return elem
      }
      /**
       * Append element(s) to a node.
       * @param properties See {@link ElementProps}
       * @param container The parent node to append to.
       * @returns A Node that is the appended child (aChild),
       *          except when aChild is a DocumentFragment,
       *          in which case the empty DocumentFragment is returned.
       */
      appendElement(properties, container) {
        return container.appendChild(this.createElement(container.ownerDocument, properties.tag, properties))
      }
      /**
       * Inserts a node before a reference node as a child of its parent node.
       * @param properties See {@link ElementProps}
       * @param referenceNode The node before which newNode is inserted.
       * @returns
       */
      insertElementBefore(properties, referenceNode) {
        if (referenceNode.parentNode)
          return referenceNode.parentNode.insertBefore(this.createElement(referenceNode.ownerDocument, properties.tag, properties), referenceNode)
        else
          this.log(referenceNode.tagName + " has no parent, cannot insert " + properties.tag)
      }
      /**
       * Replace oldNode with a new one.
       * @param properties See {@link ElementProps}
       * @param oldNode The child to be replaced.
       * @returns The replaced Node. This is the same node as oldChild.
       */
      replaceElement(properties, oldNode) {
        if (oldNode.parentNode)
          return oldNode.parentNode.replaceChild(this.createElement(oldNode.ownerDocument, properties.tag, properties), oldNode)
        else
          this.log(oldNode.tagName + " has no parent, cannot replace it with " + properties.tag)
      }
      /**
       * Parse XHTML to XUL fragment. For Zotero 6.
       *
       * To load preferences from a Zotero 7's `.xhtml`, use this method to parse it.
       * @param str xhtml raw text
       * @param entities dtd file list ("chrome://xxx.dtd")
       * @param defaultXUL true for default XUL namespace
       */
      parseXHTMLToFragment(str, entities = [], defaultXUL = true) {
        let parser2 = this.getDOMParser()
        const xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
        const htmlns = "http://www.w3.org/1999/xhtml"
        const wrappedStr = `${entities.length ? `<!DOCTYPE bindings [ ${entities.reduce((preamble, url, index) => {
          return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}"> %_dtd-${index}; `
        }, "")}]>` : ""}
      <html:div xmlns="${defaultXUL ? xulns : htmlns}"
          xmlns:xul="${xulns}" xmlns:html="${htmlns}">
      ${str}
      </html:div>`
        this.log(wrappedStr, parser2)
        let doc = parser2.parseFromString(wrappedStr, "text/xml")
        this.log(doc)
        if (doc.documentElement.localName === "parsererror") {
          throw new Error("not well-formed XHTML")
        }
        let range = doc.createRange()
        range.selectNodeContents(doc.querySelector("div"))
        return range.extractContents()
      }
    }
    exports.UITool = UITool3
    var HTMLElementTagNames = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "menu",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "slot",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]
    var XULElementTagNames = [
      "action",
      "arrowscrollbox",
      "bbox",
      "binding",
      "bindings",
      "box",
      "broadcaster",
      "broadcasterset",
      "button",
      "browser",
      "checkbox",
      "caption",
      "colorpicker",
      "column",
      "columns",
      "commandset",
      "command",
      "conditions",
      "content",
      "deck",
      "description",
      "dialog",
      "dialogheader",
      "editor",
      "grid",
      "grippy",
      "groupbox",
      "hbox",
      "iframe",
      "image",
      "key",
      "keyset",
      "label",
      "listbox",
      "listcell",
      "listcol",
      "listcols",
      "listhead",
      "listheader",
      "listitem",
      "member",
      "menu",
      "menubar",
      "menuitem",
      "menulist",
      "menupopup",
      "menuseparator",
      "observes",
      "overlay",
      "page",
      "popup",
      "popupset",
      "preference",
      "preferences",
      "prefpane",
      "prefwindow",
      "progressmeter",
      "radio",
      "radiogroup",
      "resizer",
      "richlistbox",
      "richlistitem",
      "row",
      "rows",
      "rule",
      "script",
      "scrollbar",
      "scrollbox",
      "scrollcorner",
      "separator",
      "spacer",
      "splitter",
      "stack",
      "statusbar",
      "statusbarpanel",
      "stringbundle",
      "stringbundleset",
      "tab",
      "tabbrowser",
      "tabbox",
      "tabpanel",
      "tabpanels",
      "tabs",
      "template",
      "textnode",
      "textbox",
      "titlebar",
      "toolbar",
      "toolbarbutton",
      "toolbargrippy",
      "toolbaritem",
      "toolbarpalette",
      "toolbarseparator",
      "toolbarset",
      "toolbarspacer",
      "toolbarspring",
      "toolbox",
      "tooltip",
      "tree",
      "treecell",
      "treechildren",
      "treecol",
      "treecols",
      "treeitem",
      "treerow",
      "treeseparator",
      "triple",
      "vbox",
      "window",
      "wizard",
      "wizardpage"
    ]
    var SVGElementTagNames = [
      "a",
      "animate",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tspan",
      "use",
      "view"
    ]
  }
})

// node_modules/zotero-plugin-toolkit/dist/managers/shortcut.js
var require_shortcut = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/managers/shortcut.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __importDefault = exports && exports.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : { "default": mod }
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.ShortcutManager = void 0
    var basic_1 = require_basic()
    var ui_1 = require_ui()
    var basic_2 = require_basic()
    var toolkitGlobal_1 = __importDefault(require_toolkitGlobal())
    var ShortcutManager3 = class extends basic_2.ManagerTool {
      constructor(base2) {
        super(base2)
        this.ui = new ui_1.UITool(this)
        this.creatorId = `${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`
        this.initializeGlobal()
      }
      register(type2, keyOptions) {
        const _keyOptions = keyOptions
        _keyOptions.type = type2
        switch (_keyOptions.type) {
          case "event":
            this.registerEventKey(_keyOptions)
            return true
          case "element":
            this.registerElementKey(_keyOptions)
            return true
          case "prefs":
            this.getGlobal("Zotero").Prefs.set(_keyOptions.id, _keyOptions.key || "")
            return true
          default:
            try {
              if (_keyOptions.register) {
                return _keyOptions.register(_keyOptions)
              } else {
                return false
              }
            } catch (e) {
              this.log(e)
              return false
            }
        }
      }
      /**
       * Get all shortcuts(element, event, prefs, builtin)
       */
      getAll() {
        return Array.prototype.concat(this.getMainWindowElementKeys(), this.getEventKeys(), this.getPrefsKeys(), this.getBuiltinKeys())
      }
      /**
       * Check key conflicting of `inputKeyOptions`.
       * @param inputKeyOptions
       * @param options
       * @returns conflicting keys array
       */
      checkKeyConflicting(inputKeyOptions, options2 = { includeEmpty: false, customKeys: [] }) {
        var _a
        inputKeyOptions.modifiers = new KeyModifier(inputKeyOptions.modifiers || "").getRaw()
        let allKeys = this.getAll()
        if ((_a = options2.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
          allKeys = allKeys.concat(options2.customKeys)
        }
        if (!options2.includeEmpty) {
          allKeys = allKeys.filter((_keyOptions) => _keyOptions.key)
        }
        return allKeys.filter((_keyOptions) => {
          var _a2, _b
          return _keyOptions.id !== inputKeyOptions.id && ((_a2 = _keyOptions.key) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === ((_b = inputKeyOptions.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) && _keyOptions.modifiers === inputKeyOptions.modifiers
        })
      }
      /**
       * Find all key conflicting.
       * @param options
       * @returns An array of conflicting keys arrays. Same conflicting keys are put together.
       */
      checkAllKeyConflicting(options2 = { includeEmpty: false, customKeys: [] }) {
        var _a
        let allKeys = this.getAll()
        if ((_a = options2.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
          allKeys = allKeys.concat(options2.customKeys)
        }
        if (!options2.includeEmpty) {
          allKeys = allKeys.filter((_keyOptions) => _keyOptions.key)
        }
        const conflicting = []
        while (allKeys.length > 0) {
          const checkKey = allKeys.pop()
          const conflictKeys = allKeys.filter((_keyOptions) => {
            var _a2, _b
            return ((_a2 = _keyOptions.key) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === ((_b = checkKey.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) && _keyOptions.modifiers === checkKey.modifiers
          })
          if (conflictKeys.length) {
            conflictKeys.push(checkKey)
            conflicting.push(conflictKeys)
            const conflictingKeyIds = conflictKeys.map((key) => key.id)
            const toRemoveIds = []
            allKeys.forEach((key, i) => conflictingKeyIds.includes(key.id) && toRemoveIds.push(i))
            toRemoveIds.sort((a, b) => b - a).forEach((id) => allKeys.splice(id, 1))
          }
        }
        return conflicting
      }
      /**
       * Unregister a key.
       * @remarks
       * `builtin` keys cannot be unregistered.
       * @param keyOptions
       * @returns `true` for success and `false` for failure.
       */
      async unregister(keyOptions) {
        var _a
        switch (keyOptions.type) {
          case "element":
            (_a = (keyOptions.xulData.document || this.getGlobal("document")).querySelector(`#${keyOptions.id}`)) === null || _a === void 0 ? void 0 : _a.remove()
            return true
          case "prefs":
            this.getGlobal("Zotero").Prefs.set(keyOptions.id, "")
            return true
          case "builtin":
            return false
          case "event":
            let idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id)
            while (idx >= 0) {
              this.globalCache.eventKeys.splice(idx, 1)
              idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id)
            }
            return true
          default:
            try {
              if (keyOptions.unregister) {
                return await keyOptions.unregister(keyOptions)
              } else {
                return false
              }
            } catch (e) {
              this.log(e)
              return false
            }
        }
      }
      /**
       * Unregister all keys created by this instance.
       */
      unregisterAll() {
        this.ui.unregisterAll()
        this.globalCache.eventKeys.filter((keyOptions) => keyOptions.creatorId === this.creatorId).forEach((keyOptions) => this.unregister(keyOptions))
      }
      initializeGlobal() {
        const Zotero2 = this.getGlobal("Zotero")
        const window2 = this.getGlobal("window")
        this.globalCache = toolkitGlobal_1.default.getInstance().shortcut
        if (!this.globalCache._ready) {
          this.globalCache._ready = true
          window2.addEventListener("keypress", (event) => {
            let eventMods = []
            let eventModsWithAccel = []
            if (event.altKey) {
              eventMods.push("alt")
              eventModsWithAccel.push("alt")
            }
            if (event.shiftKey) {
              eventMods.push("shift")
              eventModsWithAccel.push("shift")
            }
            if (event.metaKey) {
              eventMods.push("meta")
              Zotero2.isMac && eventModsWithAccel.push("accel")
            }
            if (event.ctrlKey) {
              eventMods.push("control")
              !Zotero2.isMac && eventModsWithAccel.push("accel")
            }
            const eventModStr = new KeyModifier(eventMods.join(",")).getRaw()
            const eventModStrWithAccel = new KeyModifier(eventMods.join(",")).getRaw()
            this.globalCache.eventKeys.forEach((keyOptions) => {
              var _a
              if (keyOptions.disabled) {
                return
              }
              const modStr = new KeyModifier(keyOptions.modifiers || "").getRaw()
              if ((modStr === eventModStr || modStr === eventModStrWithAccel) && ((_a = keyOptions.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === event.key.toLowerCase()) {
                keyOptions.callback()
              }
            })
          })
        }
      }
      registerEventKey(keyOptions) {
        keyOptions.creatorId = this.creatorId
        this.globalCache.eventKeys.push(keyOptions)
      }
      /**
       * Register Element \<commandset\>. In general, use `registerElementKey` or `registerKey`.
       * @param commandSetOptions
       */
      registerElementCommandset(commandSetOptions) {
        var _a;
        (_a = commandSetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandSetOptions.document, "commandset", {
          id: commandSetOptions.id,
          skipIfExists: true,
          children: commandSetOptions.commands.map((cmd) => ({
            tag: "command",
            id: cmd.id,
            attributes: {
              oncommand: cmd.oncommand,
              disabled: cmd.disabled,
              label: cmd.label
            }
          }))
        }))
      }
      /**
       * Register Element \<command\>. In general, use `registerElementKey` or `registerKey`.
       * @param commandOptions
       */
      registerElementCommand(commandOptions) {
        var _a
        if (commandOptions._parentId) {
          this.registerElementCommandset({
            id: commandOptions._parentId,
            document: commandOptions.document,
            commands: []
          })
        }
        (_a = commandOptions.document.querySelector(`commandset#${commandOptions._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandOptions.document, "command", {
          id: commandOptions.id,
          skipIfExists: true,
          attributes: {
            oncommand: commandOptions.oncommand,
            disabled: commandOptions.disabled,
            label: commandOptions.label
          }
        }))
      }
      /**
       * Register Element \<keyset\>. In general, use `registerElementKey` or `registerKey`.
       * @param keySetOptions
       */
      registerElementKeyset(keySetOptions) {
        var _a;
        (_a = keySetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(keySetOptions.document, "keyset", {
          id: keySetOptions.id,
          skipIfExists: true,
          children: keySetOptions.keys.map((keyOptions) => ({
            tag: "key",
            id: keyOptions.id,
            attributes: {
              oncommand: keyOptions.xulData.oncommand || "//",
              command: keyOptions.xulData.command,
              modifiers: keyOptions.modifiers,
              key: this.getXULKey(keyOptions.key),
              keycode: this.getXULKeyCode(keyOptions.key),
              disabled: keyOptions.disabled
            }
          }))
        }))
      }
      /**
       * Register a shortcut key element \<key\>.
       * @remarks
       * Provide `_parentId` to register a \<keyset\>;
       *
       * Provide `_commandOptions` to register a \<command\>;
       *
       * Provide `_parentId` in `_commandOptions` to register a \<commandset\>.
       *
       * See examples for more details.
       * @param keyOptions
       * @example
       */
      registerElementKey(keyOptions) {
        var _a
        const doc = keyOptions.xulData.document || this.getGlobal("document")
        if (keyOptions.xulData._parentId) {
          this.registerElementKeyset({
            id: keyOptions.xulData._parentId,
            document: doc,
            keys: []
          })
        }
        (_a = doc.querySelector(`keyset#${keyOptions.xulData._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(doc, "key", {
          id: keyOptions.id,
          skipIfExists: true,
          attributes: {
            oncommand: keyOptions.xulData.oncommand || "//",
            command: keyOptions.xulData.command,
            modifiers: keyOptions.modifiers,
            key: this.getXULKey(keyOptions.key),
            keycode: this.getXULKeyCode(keyOptions.key),
            disabled: keyOptions.disabled
          }
        }))
        if (keyOptions.xulData._commandOptions) {
          this.registerElementCommand(keyOptions.xulData._commandOptions)
        }
      }
      getXULKey(standardKey) {
        if (standardKey.length === 1) {
          return standardKey
        }
        return void 0
      }
      getXULKeyCode(standardKey) {
        const idx = Object.values(XUL_KEYCODE_MAPS).findIndex((value) => value === standardKey)
        if (idx >= 0) {
          return Object.values(XUL_KEYCODE_MAPS)[idx]
        }
        return void 0
      }
      getStandardKey(XULKey, XULKeyCode) {
        if (XULKeyCode && Object.keys(XUL_KEYCODE_MAPS).includes(XULKeyCode)) {
          return XUL_KEYCODE_MAPS[XULKeyCode]
        } else {
          return XULKey
        }
      }
      /**
       * Get all \<commandset\> details.
       * @param doc
       */
      getElementCommandSets(doc) {
        return Array.from((doc || this.getGlobal("document")).querySelectorAll("commandset")).map((cmdSet) => ({
          id: cmdSet.id,
          commands: Array.from(cmdSet.querySelectorAll("command")).map((cmd) => ({
            id: cmd.id,
            oncommand: cmd.getAttribute("oncommand"),
            disabled: cmd.getAttribute("disabled") === "true",
            label: cmd.getAttribute("label"),
            _parentId: cmdSet.id
          }))
        }))
      }
      /**
       * Get all \<command\> details.
       * @param doc
       */
      getElementCommands(doc) {
        return Array.prototype.concat(...this.getElementCommandSets(doc).map((cmdSet) => cmdSet.commands))
      }
      /**
       * Get all \<keyset\> details.
       * @param doc
       * @param options
       */
      getElementKeySets(doc) {
        let allCommends = this.getElementCommands(doc)
        return Array.from((doc || this.getGlobal("document")).querySelectorAll("keyset")).map((keysetElem) => ({
          id: keysetElem.id,
          document: doc,
          keys: Array.from(keysetElem.querySelectorAll("key")).map((keyElem) => {
            const oncommand = keyElem.getAttribute("oncommand") || ""
            const commandId = keyElem.getAttribute("command") || ""
            const commandOptions = allCommends.find((cmd) => cmd.id === commandId)
            const key = {
              type: "element",
              id: keyElem.id,
              key: this.getStandardKey(keyElem.getAttribute("key") || "", keyElem.getAttribute("keycode") || ""),
              modifiers: new KeyModifier(keyElem.getAttribute("modifiers") || "").getRaw(),
              disabled: keyElem.getAttribute("disabled") === "true",
              xulData: {
                document: doc,
                oncommand,
                command: commandId,
                _parentId: keysetElem.id,
                _commandOptions: commandOptions
              },
              callback: () => {
                const win = doc.ownerGlobal
                const _eval = win.eval
                _eval(oncommand)
                _eval((commandOptions === null || commandOptions === void 0 ? void 0 : commandOptions.oncommand) || "")
              }
            }
            return key
          })
        }))
      }
      /**
       * Get all \<key\> details.
       * @param doc
       * @param options
       */
      getElementKeys(doc) {
        return Array.prototype.concat(...this.getElementKeySets(doc).map((keyset) => keyset.keys)).filter((elemKey) => !ELEM_KEY_IGNORE.includes(elemKey.id))
      }
      /**
       * Get \<key\> details in main window.
       * @param options
       */
      getMainWindowElementKeys() {
        return this.getElementKeys(this.getGlobal("document"))
      }
      getEventKeys() {
        return this.globalCache.eventKeys
      }
      /**
       * Get Zotero builtin keys defined in preferences.
       */
      getPrefsKeys() {
        const Zotero2 = this.getGlobal("Zotero")
        return PREF_KEYS.map((pref) => ({
          id: pref.id,
          modifiers: pref.modifiers,
          key: Zotero2.Prefs.get(pref.id),
          callback: pref.callback,
          type: "prefs"
        }))
      }
      /**
       * Get Zotero builtin keys not defined in preferences.
       */
      getBuiltinKeys() {
        return BUILTIN_KEYS.map((builtin) => ({
          id: builtin.id,
          modifiers: builtin.modifiers,
          key: builtin.key,
          callback: builtin.callback,
          type: "builtin"
        }))
      }
    }
    exports.ShortcutManager = ShortcutManager3
    var KeyModifier = class {
      constructor(raw) {
        raw = raw || ""
        this.accel = raw.includes("accel")
        this.shift = raw.includes("shift")
        this.control = raw.includes("control")
        this.meta = raw.includes("meta")
        this.alt = raw.includes("alt")
      }
      equals(newMod) {
        this.accel === newMod.accel
        this.shift === newMod.shift
        this.control === newMod.control
        this.meta === newMod.meta
        this.alt === newMod.alt
      }
      getRaw() {
        const enabled = []
        this.accel && enabled.push("accel")
        this.shift && enabled.push("shift")
        this.control && enabled.push("control")
        this.meta && enabled.push("meta")
        this.alt && enabled.push("alt")
        return enabled.join(",")
      }
    }
    var XUL_KEYCODE_MAPS;
    (function (XUL_KEYCODE_MAPS2) {
      XUL_KEYCODE_MAPS2["VK_CANCEL"] = "Unidentified"
      XUL_KEYCODE_MAPS2["VK_BACK"] = "Backspace"
      XUL_KEYCODE_MAPS2["VK_TAB"] = "Tab"
      XUL_KEYCODE_MAPS2["VK_CLEAR"] = "Clear"
      XUL_KEYCODE_MAPS2["VK_RETURN"] = "Enter"
      XUL_KEYCODE_MAPS2["VK_ENTER"] = "Enter"
      XUL_KEYCODE_MAPS2["VK_SHIFT"] = "Shift"
      XUL_KEYCODE_MAPS2["VK_CONTROL"] = "Control"
      XUL_KEYCODE_MAPS2["VK_ALT"] = "Alt"
      XUL_KEYCODE_MAPS2["VK_PAUSE"] = "Pause"
      XUL_KEYCODE_MAPS2["VK_CAPS_LOCK"] = "CapsLock"
      XUL_KEYCODE_MAPS2["VK_ESCAPE"] = "Escape"
      XUL_KEYCODE_MAPS2["VK_SPACE"] = " "
      XUL_KEYCODE_MAPS2["VK_PAGE_UP"] = "PageUp"
      XUL_KEYCODE_MAPS2["VK_PAGE_DOWN"] = "PageDown"
      XUL_KEYCODE_MAPS2["VK_END"] = "End"
      XUL_KEYCODE_MAPS2["VK_HOME"] = "Home"
      XUL_KEYCODE_MAPS2["VK_LEFT"] = "ArrowLeft"
      XUL_KEYCODE_MAPS2["VK_UP"] = "ArrowUp"
      XUL_KEYCODE_MAPS2["VK_RIGHT"] = "ArrowRight"
      XUL_KEYCODE_MAPS2["VK_DOWN"] = "ArrowDown"
      XUL_KEYCODE_MAPS2["VK_PRINTSCREEN"] = "PrintScreen"
      XUL_KEYCODE_MAPS2["VK_INSERT"] = "Insert"
      XUL_KEYCODE_MAPS2["VK_DELETE"] = "Backspace"
      XUL_KEYCODE_MAPS2["VK_0"] = "0"
      XUL_KEYCODE_MAPS2["VK_1"] = "1"
      XUL_KEYCODE_MAPS2["VK_2"] = "2"
      XUL_KEYCODE_MAPS2["VK_3"] = "3"
      XUL_KEYCODE_MAPS2["VK_4"] = "4"
      XUL_KEYCODE_MAPS2["VK_5"] = "5"
      XUL_KEYCODE_MAPS2["VK_6"] = "6"
      XUL_KEYCODE_MAPS2["VK_7"] = "7"
      XUL_KEYCODE_MAPS2["VK_8"] = "8"
      XUL_KEYCODE_MAPS2["VK_9"] = "9"
      XUL_KEYCODE_MAPS2["VK_A"] = "A"
      XUL_KEYCODE_MAPS2["VK_B"] = "B"
      XUL_KEYCODE_MAPS2["VK_C"] = "C"
      XUL_KEYCODE_MAPS2["VK_D"] = "D"
      XUL_KEYCODE_MAPS2["VK_E"] = "E"
      XUL_KEYCODE_MAPS2["VK_F"] = "F"
      XUL_KEYCODE_MAPS2["VK_G"] = "G"
      XUL_KEYCODE_MAPS2["VK_H"] = "H"
      XUL_KEYCODE_MAPS2["VK_I"] = "I"
      XUL_KEYCODE_MAPS2["VK_J"] = "J"
      XUL_KEYCODE_MAPS2["VK_K"] = "K"
      XUL_KEYCODE_MAPS2["VK_L"] = "L"
      XUL_KEYCODE_MAPS2["VK_M"] = "M"
      XUL_KEYCODE_MAPS2["VK_N"] = "N"
      XUL_KEYCODE_MAPS2["VK_O"] = "O"
      XUL_KEYCODE_MAPS2["VK_P"] = "P"
      XUL_KEYCODE_MAPS2["VK_Q"] = "Q"
      XUL_KEYCODE_MAPS2["VK_R"] = "R"
      XUL_KEYCODE_MAPS2["VK_S"] = "S"
      XUL_KEYCODE_MAPS2["VK_T"] = "T"
      XUL_KEYCODE_MAPS2["VK_U"] = "U"
      XUL_KEYCODE_MAPS2["VK_V"] = "V"
      XUL_KEYCODE_MAPS2["VK_W"] = "W"
      XUL_KEYCODE_MAPS2["VK_X"] = "X"
      XUL_KEYCODE_MAPS2["VK_Y"] = "Y"
      XUL_KEYCODE_MAPS2["VK_Z"] = "Z"
      XUL_KEYCODE_MAPS2["VK_SEMICOLON"] = "Unidentified"
      XUL_KEYCODE_MAPS2["VK_EQUALS"] = "Unidentified"
      XUL_KEYCODE_MAPS2["VK_NUMPAD0"] = "0"
      XUL_KEYCODE_MAPS2["VK_NUMPAD1"] = "1"
      XUL_KEYCODE_MAPS2["VK_NUMPAD2"] = "2"
      XUL_KEYCODE_MAPS2["VK_NUMPAD3"] = "3"
      XUL_KEYCODE_MAPS2["VK_NUMPAD4"] = "4"
      XUL_KEYCODE_MAPS2["VK_NUMPAD5"] = "5"
      XUL_KEYCODE_MAPS2["VK_NUMPAD6"] = "6"
      XUL_KEYCODE_MAPS2["VK_NUMPAD7"] = "7"
      XUL_KEYCODE_MAPS2["VK_NUMPAD8"] = "8"
      XUL_KEYCODE_MAPS2["VK_NUMPAD9"] = "9"
      XUL_KEYCODE_MAPS2["VK_MULTIPLY"] = "Multiply"
      XUL_KEYCODE_MAPS2["VK_ADD"] = "Add"
      XUL_KEYCODE_MAPS2["VK_SEPARATOR"] = "Separator"
      XUL_KEYCODE_MAPS2["VK_SUBTRACT"] = "Subtract"
      XUL_KEYCODE_MAPS2["VK_DECIMAL"] = "Decimal"
      XUL_KEYCODE_MAPS2["VK_DIVIDE"] = "Divide"
      XUL_KEYCODE_MAPS2["VK_F1"] = "F1"
      XUL_KEYCODE_MAPS2["VK_F2"] = "F2"
      XUL_KEYCODE_MAPS2["VK_F3"] = "F3"
      XUL_KEYCODE_MAPS2["VK_F4"] = "F4"
      XUL_KEYCODE_MAPS2["VK_F5"] = "F5"
      XUL_KEYCODE_MAPS2["VK_F6"] = "F6"
      XUL_KEYCODE_MAPS2["VK_F7"] = "F7"
      XUL_KEYCODE_MAPS2["VK_F8"] = "F8"
      XUL_KEYCODE_MAPS2["VK_F9"] = "F9"
      XUL_KEYCODE_MAPS2["VK_F10"] = "F10"
      XUL_KEYCODE_MAPS2["VK_F11"] = "F11"
      XUL_KEYCODE_MAPS2["VK_F12"] = "F12"
      XUL_KEYCODE_MAPS2["VK_F13"] = "F13"
      XUL_KEYCODE_MAPS2["VK_F14"] = "F14"
      XUL_KEYCODE_MAPS2["VK_F15"] = "F15"
      XUL_KEYCODE_MAPS2["VK_F16"] = "F16"
      XUL_KEYCODE_MAPS2["VK_F17"] = "F17"
      XUL_KEYCODE_MAPS2["VK_F18"] = "F18"
      XUL_KEYCODE_MAPS2["VK_F19"] = "F19"
      XUL_KEYCODE_MAPS2["VK_F20"] = "F20"
      XUL_KEYCODE_MAPS2["VK_F21"] = "Soft1"
      XUL_KEYCODE_MAPS2["VK_F22"] = "Soft2"
      XUL_KEYCODE_MAPS2["VK_F23"] = "Soft3"
      XUL_KEYCODE_MAPS2["VK_F24"] = "Soft4"
      XUL_KEYCODE_MAPS2["VK_NUM_LOCK"] = "NumLock"
      XUL_KEYCODE_MAPS2["VK_SCROLL_LOCK"] = "ScrollLock"
      XUL_KEYCODE_MAPS2["VK_COMMA"] = ","
      XUL_KEYCODE_MAPS2["VK_PERIOD"] = "."
      XUL_KEYCODE_MAPS2["VK_SLASH"] = "Divide"
      XUL_KEYCODE_MAPS2["VK_BACK_QUOTE"] = "`"
      XUL_KEYCODE_MAPS2["VK_OPEN_BRACKET"] = "["
      XUL_KEYCODE_MAPS2["VK_CLOSE_BRACKET"] = "]"
      XUL_KEYCODE_MAPS2["VK_QUOTE"] = "\\"
      XUL_KEYCODE_MAPS2["VK_HELP"] = "Help"
    })(XUL_KEYCODE_MAPS || (XUL_KEYCODE_MAPS = {}))
    function getElementKeyCallback(keyId) {
      return function () {
        var _a
        const win = basic_1.BasicTool.getZotero().getMainWindow()
        const keyElem = win.document.querySelector(`#${keyId}`)
        if (!keyElem) {
          return function () {
          }
        }
        const _eval = win.eval
        _eval(keyElem.getAttribute("oncommand") || "//")
        const cmdId = keyElem.getAttribute("command")
        if (!cmdId) {
          return
        }
        _eval(((_a = win.document.querySelector(`#${cmdId}`)) === null || _a === void 0 ? void 0 : _a.getAttribute("oncommand")) || "//")
      }
    }
    function getBuiltinEventKeyCallback(eventId) {
      return function () {
        const Zotero2 = basic_1.BasicTool.getZotero()
        const ZoteroPane2 = Zotero2.getActiveZoteroPane()
        ZoteroPane2.handleKeyPress({
          metaKey: true,
          ctrlKey: true,
          shiftKey: true,
          originalTarget: { id: "" },
          preventDefault: () => {
          },
          key: Zotero2.Prefs.get(`extensions.zotero.keys.${eventId}`, true)
        })
      }
    }
    var ELEM_KEY_IGNORE = ["key_copyCitation", "key_copyBibliography"]
    var PREF_KEYS = [
      {
        id: "extensions.zotero.keys.copySelectedItemCitationsToClipboard",
        modifiers: "accel,shift",
        elemId: "key_copyCitation",
        callback: getElementKeyCallback("key_copyCitation")
      },
      {
        id: "extensions.zotero.keys.copySelectedItemsToClipboard",
        modifiers: "accel,shift",
        elemId: "key_copyBibliography",
        callback: getElementKeyCallback("key_copyBibliography")
      },
      {
        id: "extensions.zotero.keys.library",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("library")
      },
      {
        id: "extensions.zotero.keys.newItem",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("newItem")
      },
      {
        id: "extensions.zotero.keys.newNote",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("newNote")
      },
      {
        id: "extensions.zotero.keys.quicksearch",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("quicksearch")
      },
      {
        id: "extensions.zotero.keys.saveToZotero",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("saveToZotero")
      },
      {
        id: "extensions.zotero.keys.sync",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("sync")
      },
      {
        id: "extensions.zotero.keys.toggleAllRead",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("toggleAllRead")
      },
      {
        id: "extensions.zotero.keys.toggleRead",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("toggleRead")
      }
    ]
    var BUILTIN_KEYS = [
      {
        id: "showItemCollection",
        modifiers: "",
        key: "Ctrl",
        callback: () => {
          const Zotero2 = basic_1.BasicTool.getZotero()
          const ZoteroPane2 = Zotero2.getActiveZoteroPane()
          ZoteroPane2.handleKeyUp({
            originalTarget: { id: ZoteroPane2.itemsView.id },
            keyCode: Zotero2.isWin ? 17 : 18
          })
        }
      },
      {
        id: "closeSelectedTab",
        modifiers: "accel",
        key: "W",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          if (ztabs.selectedIndex > 0) {
            ztabs.close("")
          }
        }
      },
      {
        id: "undoCloseTab",
        modifiers: "accel,shift",
        key: "T",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.undoClose()
        }
      },
      {
        id: "selectNextTab",
        modifiers: "control",
        key: "Tab",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.selectPrev()
        }
      },
      {
        id: "selectPreviousTab",
        modifiers: "control,shift",
        key: "Tab",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.selectNext()
        }
      },
      {
        id: "selectTab1",
        modifiers: "accel",
        key: "1",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(0)
        }
      },
      {
        id: "selectTab2",
        modifiers: "accel",
        key: "2",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(1)
        }
      },
      {
        id: "selectTab3",
        modifiers: "accel",
        key: "3",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(2)
        }
      },
      {
        id: "selectTab4",
        modifiers: "accel",
        key: "4",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(3)
        }
      },
      {
        id: "selectTab5",
        modifiers: "accel",
        key: "5",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(4)
        }
      },
      {
        id: "selectTab6",
        modifiers: "accel",
        key: "6",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(5)
        }
      },
      {
        id: "selectTab7",
        modifiers: "accel",
        key: "7",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(6)
        }
      },
      {
        id: "selectTab8",
        modifiers: "accel",
        key: "8",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.jump(7)
        }
      },
      {
        id: "selectTabLast",
        modifiers: "accel",
        key: "9",
        callback: () => {
          const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs
          ztabs.selectLast()
        }
      }
    ]
  }
})

// node_modules/langchain/dist/schema/index.js
var RUN_KEY, BaseChatMessage, HumanChatMessage, AIChatMessage, SystemChatMessage, ChatMessage, BasePromptValue, BaseChatMessageHistory
var init_schema = __esm({
  "node_modules/langchain/dist/schema/index.js"() {
    init_process()
    init_buffer()
    RUN_KEY = "__run"
    BaseChatMessage = class {
      constructor(text) {
        Object.defineProperty(this, "text", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.text = text
      }
    }
    HumanChatMessage = class extends BaseChatMessage {
      _getType() {
        return "human"
      }
    }
    AIChatMessage = class extends BaseChatMessage {
      _getType() {
        return "ai"
      }
    }
    SystemChatMessage = class extends BaseChatMessage {
      _getType() {
        return "system"
      }
    }
    ChatMessage = class extends BaseChatMessage {
      constructor(text, role) {
        super(text)
        Object.defineProperty(this, "role", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.role = role
      }
      _getType() {
        return "generic"
      }
    }
    BasePromptValue = class {
    }
    BaseChatMessageHistory = class {
    }
  }
})

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module2) {
    init_process()
    init_buffer()
    function RetryOperation(timeouts, options2) {
      if (typeof options2 === "boolean") {
        options2 = { forever: options2 }
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts))
      this._timeouts = timeouts
      this._options = options2 || {}
      this._maxRetryTime = options2 && options2.maxRetryTime || Infinity
      this._fn = null
      this._errors = []
      this._attempts = 1
      this._operationTimeout = null
      this._operationTimeoutCb = null
      this._timeout = null
      this._operationStart = null
      this._timer = null
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0)
      }
    }
    module2.exports = RetryOperation
    RetryOperation.prototype.reset = function () {
      this._attempts = 1
      this._timeouts = this._originalTimeouts.slice(0)
    }
    RetryOperation.prototype.stop = function () {
      if (this._timeout) {
        clearTimeout(this._timeout)
      }
      if (this._timer) {
        clearTimeout(this._timer)
      }
      this._timeouts = []
      this._cachedTimeouts = null
    }
    RetryOperation.prototype.retry = function (err2) {
      if (this._timeout) {
        clearTimeout(this._timeout)
      }
      if (!err2) {
        return false
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime()
      if (err2 && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err2)
        this._errors.unshift(new Error("RetryOperation timeout occurred"))
        return false
      }
      this._errors.push(err2)
      var timeout = this._timeouts.shift()
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1)
          timeout = this._cachedTimeouts.slice(-1)
        } else {
          return false
        }
      }
      var self = this
      this._timer = setTimeout(function () {
        self._attempts++
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function () {
            self._operationTimeoutCb(self._attempts)
          }, self._operationTimeout)
          if (self._options.unref) {
            self._timeout.unref()
          }
        }
        self._fn(self._attempts)
      }, timeout)
      if (this._options.unref) {
        this._timer.unref()
      }
      return true
    }
    RetryOperation.prototype.attempt = function (fn, timeoutOps) {
      this._fn = fn
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb
        }
      }
      var self = this
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function () {
          self._operationTimeoutCb()
        }, self._operationTimeout)
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime()
      this._fn(this._attempts)
    }
    RetryOperation.prototype.try = function (fn) {
      console.log("Using RetryOperation.try() is deprecated")
      this.attempt(fn)
    }
    RetryOperation.prototype.start = function (fn) {
      console.log("Using RetryOperation.start() is deprecated")
      this.attempt(fn)
    }
    RetryOperation.prototype.start = RetryOperation.prototype.try
    RetryOperation.prototype.errors = function () {
      return this._errors
    }
    RetryOperation.prototype.attempts = function () {
      return this._attempts
    }
    RetryOperation.prototype.mainError = function () {
      if (this._errors.length === 0) {
        return null
      }
      var counts = {}
      var mainError = null
      var mainErrorCount = 0
      for (var i = 0; i < this._errors.length; i++) {
        var error2 = this._errors[i]
        var message = error2.message
        var count = (counts[message] || 0) + 1
        counts[message] = count
        if (count >= mainErrorCount) {
          mainError = error2
          mainErrorCount = count
        }
      }
      return mainError
    }
  }
})

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    init_process()
    init_buffer()
    var RetryOperation = require_retry_operation()
    exports.operation = function (options2) {
      var timeouts = exports.timeouts(options2)
      return new RetryOperation(timeouts, {
        forever: options2 && (options2.forever || options2.retries === Infinity),
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      })
    }
    exports.timeouts = function (options2) {
      if (options2 instanceof Array) {
        return [].concat(options2)
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      }
      for (var key in options2) {
        opts[key] = options2[key]
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout")
      }
      var timeouts = []
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts))
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts))
      }
      timeouts.sort(function (a, b) {
        return a - b
      })
      return timeouts
    }
    exports.createTimeout = function (attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt))
      timeout = Math.min(timeout, opts.maxTimeout)
      return timeout
    }
    exports.wrap = function (obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2
        options2 = null
      }
      if (!methods) {
        methods = []
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key)
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i]
        var original = obj[method]
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options2)
          var args = Array.prototype.slice.call(arguments, 1)
          var callback = args.pop()
          args.push(function (err2) {
            if (op.retry(err2)) {
              return
            }
            if (err2) {
              arguments[0] = op.mainError()
            }
            callback.apply(this, arguments)
          })
          op.attempt(function () {
            original2.apply(obj, args)
          })
        }.bind(obj, original)
        obj[method].options = options2
      }
    }
  }
})

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = require_retry()
  }
})

// node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/p-retry/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var retry = require_retry2()
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ]
    var AbortError = class extends Error {
      constructor(message) {
        super()
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message)
        } else {
          this.originalError = new Error(message)
          this.originalError.stack = this.stack
        }
        this.name = "AbortError"
        this.message = message
      }
    }
    var decorateErrorWithCounts = (error2, attemptNumber, options2) => {
      const retriesLeft = options2.retries - (attemptNumber - 1)
      error2.attemptNumber = attemptNumber
      error2.retriesLeft = retriesLeft
      return error2
    }
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage)
    var pRetry2 = (input, options2) => new Promise((resolve2, reject) => {
      options2 = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options2
      }
      const operation = retry.operation(options2)
      operation.attempt(async (attemptNumber) => {
        try {
          resolve2(await input(attemptNumber))
        } catch (error2) {
          if (!(error2 instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error2}". You should only throw errors.`))
            return
          }
          if (error2 instanceof AbortError) {
            operation.stop()
            reject(error2.originalError)
          } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {
            operation.stop()
            reject(error2)
          } else {
            decorateErrorWithCounts(error2, attemptNumber, options2)
            try {
              await options2.onFailedAttempt(error2)
            } catch (error3) {
              reject(error3)
              return
            }
            if (!operation.retry(error2)) {
              reject(operation.mainError())
            }
          }
        }
      })
    })
    module2.exports = pRetry2
    module2.exports.default = pRetry2
    module2.exports.AbortError = AbortError
  }
})

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var has = Object.prototype.hasOwnProperty
    var prefix = "~"
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null)
      if (!new Events().__proto__)
        prefix = false
    }
    function EE(fn, context, once4) {
      this.fn = fn
      this.context = context
      this.once = once4 || false
    }
    function addListener4(emitter, event, fn, context, once4) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function")
      }
      var listener = new EE(fn, context || emitter, once4), evt = prefix ? prefix + event : event
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener)
      else
        emitter._events[evt] = [emitter._events[evt], listener]
      return emitter
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events()
      else
        delete emitter._events[evt]
    }
    function EventEmitter2() {
      this._events = new Events()
      this._eventsCount = 0
    }
    EventEmitter2.prototype.eventNames = function eventNames2() {
      var names = [], events, name
      if (this._eventsCount === 0)
        return names
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name)
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events))
      }
      return names
    }
    EventEmitter2.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt]
      if (!handlers)
        return []
      if (handlers.fn)
        return [handlers.fn]
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn
      }
      return ee
    }
    EventEmitter2.prototype.listenerCount = function listenerCount3(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt]
      if (!listeners2)
        return 0
      if (listeners2.fn)
        return 1
      return listeners2.length
    }
    EventEmitter2.prototype.emit = function emit4(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event
      if (!this._events[evt])
        return false
      var listeners2 = this._events[evt], len = arguments.length, args, i
      if (listeners2.fn) {
        if (listeners2.once)
          this.removeListener(event, listeners2.fn, void 0, true)
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a2), true
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a2, a3), true
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i]
        }
        listeners2.fn.apply(listeners2.context, args)
      } else {
        var length = listeners2.length, j
        for (i = 0; i < length; i++) {
          if (listeners2[i].once)
            this.removeListener(event, listeners2[i].fn, void 0, true)
          switch (len) {
            case 1:
              listeners2[i].fn.call(listeners2[i].context)
              break
            case 2:
              listeners2[i].fn.call(listeners2[i].context, a1)
              break
            case 3:
              listeners2[i].fn.call(listeners2[i].context, a1, a2)
              break
            case 4:
              listeners2[i].fn.call(listeners2[i].context, a1, a2, a3)
              break
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j]
                }
              listeners2[i].fn.apply(listeners2[i].context, args)
          }
        }
      }
      return true
    }
    EventEmitter2.prototype.on = function on3(event, fn, context) {
      return addListener4(this, event, fn, context, false)
    }
    EventEmitter2.prototype.once = function once4(event, fn, context) {
      return addListener4(this, event, fn, context, true)
    }
    EventEmitter2.prototype.removeListener = function removeListener4(event, fn, context, once4) {
      var evt = prefix ? prefix + event : event
      if (!this._events[evt])
        return this
      if (!fn) {
        clearEvent(this, evt)
        return this
      }
      var listeners2 = this._events[evt]
      if (listeners2.fn) {
        if (listeners2.fn === fn && (!once4 || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt)
        }
      } else {
        for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
          if (listeners2[i].fn !== fn || once4 && !listeners2[i].once || context && listeners2[i].context !== context) {
            events.push(listeners2[i])
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events
        else
          clearEvent(this, evt)
      }
      return this
    }
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(event) {
      var evt
      if (event) {
        evt = prefix ? prefix + event : event
        if (this._events[evt])
          clearEvent(this, evt)
      } else {
        this._events = new Events()
        this._eventsCount = 0
      }
      return this
    }
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on
    EventEmitter2.prefixed = prefix
    EventEmitter2.EventEmitter = EventEmitter2
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2
    }
  }
})

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      })
      return promise.then(
        (val) => new Promise((resolve2) => {
          resolve2(onFinally())
        }).then(() => val),
        (err2) => new Promise((resolve2) => {
          resolve2(onFinally())
        }).then(() => {
          throw err2
        })
      )
    }
  }
})

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var pFinally = require_p_finally()
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message)
        this.name = "TimeoutError"
      }
    }
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve2, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number")
      }
      if (milliseconds === Infinity) {
        resolve2(promise)
        return
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve2(fallback())
          } catch (error2) {
            reject(error2)
          }
          return
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message)
        if (typeof promise.cancel === "function") {
          promise.cancel()
        }
        reject(timeoutError)
      }, milliseconds)
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve2, reject),
        () => {
          clearTimeout(timer)
        }
      )
    })
    module2.exports = pTimeout
    module2.exports.default = pTimeout
    module2.exports.TimeoutError = TimeoutError
  }
})

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    function lowerBound(array, value, comparator) {
      let first = 0
      let count = array.length
      while (count > 0) {
        const step = count / 2 | 0
        let it = first + step
        if (comparator(array[it], value) <= 0) {
          first = ++it
          count -= step + 1
        } else {
          count = step
        }
      }
      return first
    }
    exports.default = lowerBound
  }
})

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    var lower_bound_1 = require_lower_bound()
    var PriorityQueue = class {
      constructor() {
        this._queue = []
      }
      enqueue(run, options2) {
        options2 = Object.assign({ priority: 0 }, options2)
        const element = {
          priority: options2.priority,
          run
        }
        if (this.size && this._queue[this.size - 1].priority >= options2.priority) {
          this._queue.push(element)
          return
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority)
        this._queue.splice(index, 0, element)
      }
      dequeue() {
        const item = this._queue.shift()
        return item === null || item === void 0 ? void 0 : item.run
      }
      filter(options2) {
        return this._queue.filter((element) => element.priority === options2.priority).map((element) => element.run)
      }
      get size() {
        return this._queue.length
      }
    }
    exports.default = PriorityQueue
  }
})

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    var EventEmitter2 = require_eventemitter3()
    var p_timeout_1 = require_p_timeout()
    var priority_queue_1 = require_priority_queue()
    var empty = () => {
    }
    var timeoutError = new p_timeout_1.TimeoutError()
    var PQueue = class extends EventEmitter2 {
      constructor(options2) {
        var _a, _b, _c, _d
        super()
        this._intervalCount = 0
        this._intervalEnd = 0
        this._pendingCount = 0
        this._resolveEmpty = empty
        this._resolveIdle = empty
        options2 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options2)
        if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options2.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options2.intervalCap})`)
        }
        if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options2.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options2.interval})`)
        }
        this._carryoverConcurrencyCount = options2.carryoverConcurrencyCount
        this._isIntervalIgnored = options2.intervalCap === Infinity || options2.interval === 0
        this._intervalCap = options2.intervalCap
        this._interval = options2.interval
        this._queue = new options2.queueClass()
        this._queueClass = options2.queueClass
        this.concurrency = options2.concurrency
        this._timeout = options2.timeout
        this._throwOnTimeout = options2.throwOnTimeout === true
        this._isPaused = options2.autoStart === false
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency
      }
      _next() {
        this._pendingCount--
        this._tryToStartAnother()
        this.emit("next")
      }
      _resolvePromises() {
        this._resolveEmpty()
        this._resolveEmpty = empty
        if (this._pendingCount === 0) {
          this._resolveIdle()
          this._resolveIdle = empty
          this.emit("idle")
        }
      }
      _onResumeInterval() {
        this._onInterval()
        this._initializeIntervalIfNeeded()
        this._timeoutId = void 0
      }
      _isIntervalPaused() {
        const now = Date.now()
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval()
              }, delay)
            }
            return true
          }
        }
        return false
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId)
          }
          this._intervalId = void 0
          this._resolvePromises()
          return false
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused()
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue()
            if (!job) {
              return false
            }
            this.emit("active")
            job()
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded()
            }
            return true
          }
        }
        return false
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return
        }
        this._intervalId = setInterval(() => {
          this._onInterval()
        }, this._interval)
        this._intervalEnd = Date.now() + this._interval
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId)
          this._intervalId = void 0
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0
        this._processQueue()
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`)
        }
        this._concurrency = newConcurrency
        this._processQueue()
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options2 = {}) {
        return new Promise((resolve2, reject) => {
          const run = async () => {
            this._pendingCount++
            this._intervalCount++
            try {
              const operation = this._timeout === void 0 && options2.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options2.timeout === void 0 ? this._timeout : options2.timeout, () => {
                if (options2.throwOnTimeout === void 0 ? this._throwOnTimeout : options2.throwOnTimeout) {
                  reject(timeoutError)
                }
                return void 0
              })
              resolve2(await operation)
            } catch (error2) {
              reject(error2)
            }
            this._next()
          }
          this._queue.enqueue(run, options2)
          this._tryToStartAnother()
          this.emit("add")
        })
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options2) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options2)))
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this
        }
        this._isPaused = false
        this._processQueue()
        return this
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass()
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return
        }
        return new Promise((resolve2) => {
          const existingResolve = this._resolveEmpty
          this._resolveEmpty = () => {
            existingResolve()
            resolve2()
          }
        })
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return
        }
        return new Promise((resolve2) => {
          const existingResolve = this._resolveIdle
          this._resolveIdle = () => {
            existingResolve()
            resolve2()
          }
        })
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options2) {
        return this._queue.filter(options2).length
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused
      }
      get timeout() {
        return this._timeout
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds
      }
    }
    exports.default = PQueue
  }
})

// node_modules/langchain/dist/util/async_caller.js
var import_p_retry, import_p_queue, STATUS_NO_RETRY, AsyncCaller
var init_async_caller = __esm({
  "node_modules/langchain/dist/util/async_caller.js"() {
    init_process()
    init_buffer()
    import_p_retry = __toESM(require_p_retry(), 1)
    import_p_queue = __toESM(require_dist(), 1)
    STATUS_NO_RETRY = [
      400,
      401,
      403,
      404,
      405,
      406,
      407,
      408,
      409
      // Conflict
    ]
    AsyncCaller = class {
      constructor(params) {
        var _a, _b
        Object.defineProperty(this, "maxConcurrency", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "maxRetries", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "queue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.maxConcurrency = (_a = params.maxConcurrency) != null ? _a : Infinity
        this.maxRetries = (_b = params.maxRetries) != null ? _b : 6
        const PQueue = "default" in import_p_queue.default ? import_p_queue.default.default : import_p_queue.default
        this.queue = new PQueue({ concurrency: this.maxConcurrency })
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      call(callable, ...args) {
        return this.queue.add(() => (0, import_p_retry.default)(() => callable(...args).catch((error2) => {
          if (error2 instanceof Error) {
            throw error2
          } else {
            throw new Error(error2)
          }
        }), {
          onFailedAttempt(error2) {
            var _a
            if (error2.message.startsWith("Cancel") || error2.message.startsWith("TimeoutError") || error2.message.startsWith("AbortError")) {
              throw error2
            }
            if ((error2 == null ? void 0 : error2.code) === "ECONNABORTED") {
              throw error2
            }
            const status2 = (_a = error2 == null ? void 0 : error2.response) == null ? void 0 : _a.status
            if (status2 && STATUS_NO_RETRY.includes(+status2)) {
              throw error2
            }
          },
          retries: this.maxRetries,
          randomize: true
          // If needed we can change some of the defaults here,
          // but they're quite sensible.
        }), { throwOnTimeout: true })
      }
      fetch(...args) {
        return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)))
      }
    }
  }
})

// node_modules/@dqbd/tiktoken/tiktoken_bg.cjs
var require_tiktoken_bg = __commonJS({
  "node_modules/@dqbd/tiktoken/tiktoken_bg.cjs"(exports, module2) {
    init_process()
    init_buffer()
    var wasm
    module2.exports.__wbg_set_wasm = function (val) {
      wasm = val
    }
    var heap = new Array(128).fill(void 0)
    heap.push(void 0, null, true, false)
    function getObject(idx) {
      return heap[idx]
    }
    var heap_next = heap.length
    function dropObject(idx) {
      if (idx < 132)
        return
      heap[idx] = heap_next
      heap_next = idx
    }
    function takeObject(idx) {
      const ret = getObject(idx)
      dropObject(idx)
      return ret
    }
    var WASM_VECTOR_LEN = 0
    var cachedUint8Memory0 = null
    function getUint8Memory0() {
      if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer)
      }
      return cachedUint8Memory0
    }
    var lTextEncoder = typeof TextEncoder === "undefined" ? (0, module2.require)("util").TextEncoder : TextEncoder
    var cachedTextEncoder = new lTextEncoder("utf-8")
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function (arg, view) {
      return cachedTextEncoder.encodeInto(arg, view)
    } : function (arg, view) {
      const buf = cachedTextEncoder.encode(arg)
      view.set(buf)
      return {
        read: arg.length,
        written: buf.length
      }
    }
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg)
        const ptr2 = malloc(buf.length)
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf)
        WASM_VECTOR_LEN = buf.length
        return ptr2
      }
      let len = arg.length
      let ptr = malloc(len)
      const mem = getUint8Memory0()
      let offset = 0
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset)
        if (code > 127)
          break
        mem[ptr + offset] = code
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset)
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3)
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len)
        const ret = encodeString(arg, view)
        offset += ret.written
      }
      WASM_VECTOR_LEN = offset
      return ptr
    }
    function isLikeNone(x) {
      return x === void 0 || x === null
    }
    var cachedInt32Memory0 = null
    function getInt32Memory0() {
      if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer)
      }
      return cachedInt32Memory0
    }
    var lTextDecoder = typeof TextDecoder === "undefined" ? (0, module2.require)("util").TextDecoder : TextDecoder
    var cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true })
    cachedTextDecoder.decode()
    function getStringFromWasm0(ptr, len) {
      return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len))
    }
    function addHeapObject(obj) {
      if (heap_next === heap.length)
        heap.push(heap.length + 1)
      const idx = heap_next
      heap_next = heap[idx]
      heap[idx] = obj
      return idx
    }
    var cachedUint32Memory0 = null
    function getUint32Memory0() {
      if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer)
      }
      return cachedUint32Memory0
    }
    function getArrayU32FromWasm0(ptr, len) {
      return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len)
    }
    function passArray8ToWasm0(arg, malloc) {
      const ptr = malloc(arg.length * 1)
      getUint8Memory0().set(arg, ptr / 1)
      WASM_VECTOR_LEN = arg.length
      return ptr
    }
    function passArray32ToWasm0(arg, malloc) {
      const ptr = malloc(arg.length * 4)
      getUint32Memory0().set(arg, ptr / 4)
      WASM_VECTOR_LEN = arg.length
      return ptr
    }
    function getArrayU8FromWasm0(ptr, len) {
      return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len)
    }
    module2.exports.get_encoding = function (encoding, extend_special_tokens) {
      if (wasm == null)
        throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
        const ptr0 = passStringToWasm0(encoding, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
        const len0 = WASM_VECTOR_LEN
        wasm.get_encoding(retptr, ptr0, len0, addHeapObject(extend_special_tokens))
        var r0 = getInt32Memory0()[retptr / 4 + 0]
        var r1 = getInt32Memory0()[retptr / 4 + 1]
        var r2 = getInt32Memory0()[retptr / 4 + 2]
        if (r2) {
          throw takeObject(r1)
        }
        return Tiktoken.__wrap(r0)
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16)
      }
    }
    module2.exports.encoding_for_model = function (model, extend_special_tokens) {
      if (wasm == null)
        throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
        const ptr0 = passStringToWasm0(model, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
        const len0 = WASM_VECTOR_LEN
        wasm.encoding_for_model(retptr, ptr0, len0, addHeapObject(extend_special_tokens))
        var r0 = getInt32Memory0()[retptr / 4 + 0]
        var r1 = getInt32Memory0()[retptr / 4 + 1]
        var r2 = getInt32Memory0()[retptr / 4 + 2]
        if (r2) {
          throw takeObject(r1)
        }
        return Tiktoken.__wrap(r0)
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16)
      }
    }
    function handleError(f, args) {
      try {
        return f.apply(this, args)
      } catch (e) {
        wasm.__wbindgen_export_3(addHeapObject(e))
      }
    }
    var Tiktoken = class {
      /**
       * @param {string} tiktoken_bfe
       * @param {any} special_tokens
       * @param {string} pat_str
       */
      constructor(tiktoken_bfe, special_tokens, pat_str) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        const ptr0 = passStringToWasm0(tiktoken_bfe, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
        const len0 = WASM_VECTOR_LEN
        const ptr1 = passStringToWasm0(pat_str, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
        const len1 = WASM_VECTOR_LEN
        const ret = wasm.tiktoken_new(ptr0, len0, addHeapObject(special_tokens), ptr1, len1)
        return Tiktoken.__wrap(ret)
      }
      /** @returns {string | undefined} */
      get name() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          wasm.tiktoken_name(retptr, this.ptr)
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          let v0
          if (r0 !== 0) {
            v0 = getStringFromWasm0(r0, r1).slice()
            wasm.__wbindgen_export_2(r0, r1 * 1)
          }
          return v0
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      static __wrap(ptr) {
        const obj = Object.create(Tiktoken.prototype)
        obj.ptr = ptr
        return obj
      }
      __destroy_into_raw() {
        const ptr = this.ptr
        this.ptr = 0
        return ptr
      }
      free() {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        const ptr = this.__destroy_into_raw()
        wasm.__wbg_tiktoken_free(ptr)
      }
      /**
       * @param {string} text
       * @param {any} allowed_special
       * @param {any} disallowed_special
       * @returns {Uint32Array}
       */
      encode(text, allowed_special, disallowed_special) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
          const len0 = WASM_VECTOR_LEN
          wasm.tiktoken_encode(retptr, this.ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special))
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          var r2 = getInt32Memory0()[retptr / 4 + 2]
          var r3 = getInt32Memory0()[retptr / 4 + 3]
          if (r3) {
            throw takeObject(r2)
          }
          var v1 = getArrayU32FromWasm0(r0, r1).slice()
          wasm.__wbindgen_export_2(r0, r1 * 4)
          return v1
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      /**
       * @param {string} text
       * @returns {Uint32Array}
       */
      encode_ordinary(text) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
          const len0 = WASM_VECTOR_LEN
          wasm.tiktoken_encode_ordinary(retptr, this.ptr, ptr0, len0)
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          var v1 = getArrayU32FromWasm0(r0, r1).slice()
          wasm.__wbindgen_export_2(r0, r1 * 4)
          return v1
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      /**
       * @param {string} text
       * @param {any} allowed_special
       * @param {any} disallowed_special
       * @returns {any}
       */
      encode_with_unstable(text, allowed_special, disallowed_special) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
          const len0 = WASM_VECTOR_LEN
          wasm.tiktoken_encode_with_unstable(retptr, this.ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special))
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          var r2 = getInt32Memory0()[retptr / 4 + 2]
          if (r2) {
            throw takeObject(r1)
          }
          return takeObject(r0)
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {number}
       */
      encode_single_token(bytes) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_0)
        const len0 = WASM_VECTOR_LEN
        const ret = wasm.tiktoken_encode_single_token(this.ptr, ptr0, len0)
        return ret >>> 0
      }
      /**
       * @param {Uint32Array} tokens
       * @returns {Uint8Array}
       */
      decode(tokens) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          const ptr0 = passArray32ToWasm0(tokens, wasm.__wbindgen_export_0)
          const len0 = WASM_VECTOR_LEN
          wasm.tiktoken_decode(retptr, this.ptr, ptr0, len0)
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          var v1 = getArrayU8FromWasm0(r0, r1).slice()
          wasm.__wbindgen_export_2(r0, r1 * 1)
          return v1
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      /**
       * @param {number} token
       * @returns {Uint8Array}
       */
      decode_single_token_bytes(token) {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16)
          wasm.tiktoken_decode_single_token_bytes(retptr, this.ptr, token)
          var r0 = getInt32Memory0()[retptr / 4 + 0]
          var r1 = getInt32Memory0()[retptr / 4 + 1]
          var v0 = getArrayU8FromWasm0(r0, r1).slice()
          wasm.__wbindgen_export_2(r0, r1 * 1)
          return v0
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16)
        }
      }
      /** @returns {any} */
      token_byte_values() {
        if (wasm == null)
          throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
        const ret = wasm.tiktoken_token_byte_values(this.ptr)
        return takeObject(ret)
      }
    }
    module2.exports.Tiktoken = Tiktoken
    module2.exports.__wbindgen_object_drop_ref = function (arg0) {
      takeObject(arg0)
    }
    module2.exports.__wbindgen_is_undefined = function (arg0) {
      const ret = getObject(arg0) === void 0
      return ret
    }
    module2.exports.__wbg_stringify_029a979dfb73aa17 = function () {
      return handleError(function (arg0) {
        const ret = JSON.stringify(getObject(arg0))
        return addHeapObject(ret)
      }, arguments)
    }
    module2.exports.__wbindgen_string_get = function (arg0, arg1) {
      if (wasm == null)
        throw new Error("@dqbd/tiktoken: WASM binary has not been propery initialized.")
      const obj = getObject(arg1)
      const ret = typeof obj === "string" ? obj : void 0
      var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1)
      var len0 = WASM_VECTOR_LEN
      getInt32Memory0()[arg0 / 4 + 1] = len0
      getInt32Memory0()[arg0 / 4 + 0] = ptr0
    }
    module2.exports.__wbindgen_error_new = function (arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1))
      return addHeapObject(ret)
    }
    module2.exports.__wbg_parse_3ac95b51fc312db8 = function () {
      return handleError(function (arg0, arg1) {
        const ret = JSON.parse(getStringFromWasm0(arg0, arg1))
        return addHeapObject(ret)
      }, arguments)
    }
    module2.exports.__wbindgen_throw = function (arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1))
    }
  }
})

// node-modules-polyfills:path
var path_exports = {}
__export(path_exports, {
  basename: () => basename,
  default: () => path_default,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep
})
function normalizeArray(parts, allowAboveRoot) {
  var up = 0
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i]
    if (last === ".") {
      parts.splice(i, 1)
    } else if (last === "..") {
      parts.splice(i, 1)
      up++
    } else if (up) {
      parts.splice(i, 1)
      up--
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..")
    }
  }
  return parts
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/"
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings")
    } else if (!path) {
      continue
    }
    resolvedPath = path + "/" + resolvedPath
    resolvedAbsolute = path.charAt(0) === "/"
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function (p) {
    return !!p
  }), !resolvedAbsolute).join("/")
  return (resolvedAbsolute ? "/" : "") + resolvedPath || "."
}
function normalize(path) {
  var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/"
  path = normalizeArray(filter(path.split("/"), function (p) {
    return !!p
  }), !isPathAbsolute).join("/")
  if (!path && !isPathAbsolute) {
    path = "."
  }
  if (path && trailingSlash) {
    path += "/"
  }
  return (isPathAbsolute ? "/" : "") + path
}
function isAbsolute(path) {
  return path.charAt(0) === "/"
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0)
  return normalize(filter(paths, function (p, index) {
    if (typeof p !== "string") {
      throw new TypeError("Arguments to path.join must be strings")
    }
    return p
  }).join("/"))
}
function relative(from3, to) {
  from3 = resolve(from3).substr(1)
  to = resolve(to).substr(1)
  function trim(arr) {
    var start = 0
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break
    }
    var end = arr.length - 1
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break
    }
    if (start > end)
      return []
    return arr.slice(start, end - start + 1)
  }
  var fromParts = trim(from3.split("/"))
  var toParts = trim(to.split("/"))
  var length = Math.min(fromParts.length, toParts.length)
  var samePartsLength = length
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i
      break
    }
  }
  var outputParts = []
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..")
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength))
  return outputParts.join("/")
}
function dirname(path) {
  var result = splitPath(path), root = result[0], dir = result[1]
  if (!root && !dir) {
    return "."
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1)
  }
  return root + dir
}
function basename(path, ext) {
  var f = splitPath(path)[2]
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length)
  }
  return f
}
function extname(path) {
  return splitPath(path)[3]
}
function filter(xs, f) {
  if (xs.filter)
    return xs.filter(f)
  var res = []
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs))
      res.push(xs[i])
  }
  return res
}
var splitPathRe, splitPath, sep, delimiter, path_default, substr
var init_path = __esm({
  "node-modules-polyfills:path"() {
    init_process()
    init_buffer()
    splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
    splitPath = function (filename) {
      return splitPathRe.exec(filename).slice(1)
    }
    sep = "/"
    delimiter = ":"
    path_default = {
      extname,
      basename,
      dirname,
      sep,
      delimiter,
      relative,
      join,
      isAbsolute,
      normalize,
      resolve
    }
    substr = "ab".substr(-1) === "b" ? function (str, start, len) {
      return str.substr(start, len)
    } : function (str, start, len) {
      if (start < 0)
        start = str.length + start
      return str.substr(start, len)
    }
  }
})

// node-modules-polyfills-commonjs:path
var require_path = __commonJS({
  "node-modules-polyfills-commonjs:path"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_path(), __toCommonJS(path_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills:fs
var fs_exports = {}
__export(fs_exports, {
  default: () => fs_default
})
var fs_default
var init_fs = __esm({
  "node-modules-polyfills:fs"() {
    init_process()
    init_buffer()
    fs_default = {}
  }
})

// node-modules-polyfills-commonjs:fs
var require_fs = __commonJS({
  "node-modules-polyfills-commonjs:fs"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_fs(), __toCommonJS(fs_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node_modules/@dqbd/tiktoken/tiktoken.cjs
var require_tiktoken = __commonJS({
  "node_modules/@dqbd/tiktoken/tiktoken.cjs"(exports) {
    init_process()
    init_buffer()
    var wasm = require_tiktoken_bg()
    var imports = {}
    imports["./tiktoken_bg.js"] = wasm
    var path = require_path()
    var fs = require_fs()
    var candidates = __dirname.split(path.sep).reduce((memo, _, index, array) => {
      const prefix = array.slice(0, index + 1).join(path.sep) + path.sep
      if (!prefix.includes("node_modules" + path.sep)) {
        memo.unshift(
          path.join(
            prefix,
            "node_modules",
            "@dqbd",
            "tiktoken",
            "",
            "./tiktoken_bg.wasm"
          )
        )
      }
      return memo
    }, [])
    candidates.unshift(path.join(__dirname, "./tiktoken_bg.wasm"))
    var bytes = null
    for (const candidate of candidates) {
      try {
        bytes = fs.readFileSync(candidate)
        break
      } catch (e) {
      }
    }
    if (bytes == null)
      throw new Error("Missing tiktoken_bg.wasm")
    var wasmModule = new WebAssembly.Module(bytes)
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports)
    wasm.__wbg_set_wasm(wasmInstance.exports)
    exports["get_encoding"] = wasm["get_encoding"]
    exports["encoding_for_model"] = wasm["encoding_for_model"]
    exports["Tiktoken"] = wasm["Tiktoken"]
  }
})

// node_modules/langchain/dist/base_language/count_tokens.js
var getModelNameForTiktoken, importTiktoken
var init_count_tokens = __esm({
  "node_modules/langchain/dist/base_language/count_tokens.js"() {
    init_process()
    init_buffer()
    getModelNameForTiktoken = (modelName) => {
      if (modelName.startsWith("gpt-3.5-turbo-")) {
        return "gpt-3.5-turbo"
      }
      if (modelName.startsWith("gpt-4-32k-")) {
        return "gpt-4-32k"
      }
      if (modelName.startsWith("gpt-4-")) {
        return "gpt-4"
      }
      return modelName
    }
    importTiktoken = async () => {
      try {
        const { encoding_for_model } = await Promise.resolve().then(() => __toESM(require_tiktoken(), 1))
        return { encoding_for_model }
      } catch (error2) {
        console.log(error2)
        return { encoding_for_model: null }
      }
    }
  }
})

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function bind(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        return fn.apply(thisArg, args)
      }
    }
  }
})

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var bind = require_bind()
    var toString5 = Object.prototype.toString
    function isArray5(val) {
      return Array.isArray(val)
    }
    function isUndefined3(val) {
      return typeof val === "undefined"
    }
    function isBuffer4(val) {
      return val !== null && !isUndefined3(val) && val.constructor !== null && !isUndefined3(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val)
    }
    function isArrayBuffer(val) {
      return toString5.call(val) === "[object ArrayBuffer]"
    }
    function isFormData2(val) {
      return toString5.call(val) === "[object FormData]"
    }
    function isArrayBufferView(val) {
      var result
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val)
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer)
      }
      return result
    }
    function isString2(val) {
      return typeof val === "string"
    }
    function isNumber2(val) {
      return typeof val === "number"
    }
    function isObject3(val) {
      return val !== null && typeof val === "object"
    }
    function isPlainObject(val) {
      if (toString5.call(val) !== "[object Object]") {
        return false
      }
      var prototype = Object.getPrototypeOf(val)
      return prototype === null || prototype === Object.prototype
    }
    function isDate3(val) {
      return toString5.call(val) === "[object Date]"
    }
    function isFile(val) {
      return toString5.call(val) === "[object File]"
    }
    function isBlob(val) {
      return toString5.call(val) === "[object Blob]"
    }
    function isFunction3(val) {
      return toString5.call(val) === "[object Function]"
    }
    function isStream(val) {
      return isObject3(val) && isFunction3(val.pipe)
    }
    function isURLSearchParams2(val) {
      return toString5.call(val) === "[object URLSearchParams]"
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
    }
    function isStandardBrowserEnv2() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false
      }
      return typeof window !== "undefined" && typeof document !== "undefined"
    }
    function forEach3(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return
      }
      if (typeof obj !== "object") {
        obj = [obj]
      }
      if (isArray5(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj)
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj)
          }
        }
      }
    }
    function merge() {
      var result = {}
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val)
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val)
        } else if (isArray5(val)) {
          result[key] = val.slice()
        } else {
          result[key] = val
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach3(arguments[i], assignValue)
      }
      return result
    }
    function extend(a, b, thisArg) {
      forEach3(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg)
        } else {
          a[key] = val
        }
      })
      return a
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1)
      }
      return content
    }
    module2.exports = {
      isArray: isArray5,
      isArrayBuffer,
      isBuffer: isBuffer4,
      isFormData: isFormData2,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject: isObject3,
      isPlainObject,
      isUndefined: isUndefined3,
      isDate: isDate3,
      isFile,
      isBlob,
      isFunction: isFunction3,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv: isStandardBrowserEnv2,
      forEach: forEach3,
      merge,
      extend,
      trim,
      stripBOM
    }
  }
})

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    function encode3(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    module2.exports = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url
      }
      var serializedParams
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params)
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString()
      } else {
        var parts = []
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return
          }
          if (utils.isArray(val)) {
            key = key + "[]"
          } else {
            val = [val]
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString()
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v)
            }
            parts.push(encode3(key) + "=" + encode3(v))
          })
        })
        serializedParams = parts.join("&")
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#")
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex)
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams
      }
      return url
    }
  }
})

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    function InterceptorManager() {
      this.handlers = []
    }
    InterceptorManager.prototype.use = function use2(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      })
      return this.handlers.length - 1
    }
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null
      }
    }
    InterceptorManager.prototype.forEach = function forEach3(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h)
        }
      })
    }
    module2.exports = InterceptorManager
  }
})

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value
          delete headers[name]
        }
      })
    }
  }
})

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function enhanceError2(error2, config4, code, request3, response) {
      error2.config = config4
      if (code) {
        error2.code = code
      }
      error2.request = request3
      error2.response = response
      error2.isAxiosError = true
      error2.toJSON = function toJSON4() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        }
      }
      return error2
    }
  }
})

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    }
  }
})

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var enhanceError2 = require_enhanceError()
    module2.exports = function createError2(message, config4, code, request3, response) {
      var error2 = new Error(message)
      return enhanceError2(error2, config4, code, request3, response)
    }
  }
})

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var createError2 = require_createError()
    module2.exports = function settle2(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response)
      } else {
        reject(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ))
      }
    }
  }
})

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write4(name, value, expires, path, domain3, secure) {
            var cookie = []
            cookie.push(name + "=" + encodeURIComponent(value))
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString())
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path)
            }
            if (utils.isString(domain3)) {
              cookie.push("domain=" + domain3)
            }
            if (secure === true) {
              cookie.push("secure")
            }
            document.cookie = cookie.join("; ")
          },
          read: function read2(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"))
            return match ? decodeURIComponent(match[3]) : null
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5)
          }
        }
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write4() {
          },
          read: function read2() {
            return null
          },
          remove: function remove() {
          }
        }
      }()
    )
  }
})

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)
    }
  }
})

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL
    }
  }
})

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var isAbsoluteURL2 = require_isAbsoluteURL()
    var combineURLs2 = require_combineURLs()
    module2.exports = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL2(requestedURL)) {
        return combineURLs2(baseURL, requestedURL)
      }
      return requestedURL
    }
  }
})

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]
    module2.exports = function parseHeaders(headers) {
      var parsed = {}
      var key
      var val
      var i
      if (!headers) {
        return parsed
      }
      utils.forEach(headers.split("\n"), function parser2(line) {
        i = line.indexOf(":")
        key = utils.trim(line.substr(0, i)).toLowerCase()
        val = utils.trim(line.substr(i + 1))
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val])
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val
          }
        }
      })
      return parsed
    }
  }
})

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent)
        var urlParsingNode = document.createElement("a")
        var originURL
        function resolveURL(url) {
          var href = url
          if (msie) {
            urlParsingNode.setAttribute("href", href)
            href = urlParsingNode.href
          }
          urlParsingNode.setAttribute("href", href)
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          }
        }
        originURL = resolveURL(window.location.href)
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host
        }
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true
        }
      }()
    )
  }
})

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    function Cancel(message) {
      this.message = message
    }
    Cancel.prototype.toString = function toString5() {
      return "Cancel" + (this.message ? ": " + this.message : "")
    }
    Cancel.prototype.__CANCEL__ = true
    module2.exports = Cancel
  }
})

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var settle2 = require_settle()
    var cookies = require_cookies()
    var buildURL2 = require_buildURL()
    var buildFullPath2 = require_buildFullPath()
    var parseHeaders = require_parseHeaders()
    var isURLSameOrigin = require_isURLSameOrigin()
    var createError2 = require_createError()
    var transitionalDefaults = require_transitional()
    var Cancel = require_Cancel()
    module2.exports = function xhrAdapter(config4) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config4.data
        var requestHeaders = config4.headers
        var responseType = config4.responseType
        var onCanceled
        function done2() {
          if (config4.cancelToken) {
            config4.cancelToken.unsubscribe(onCanceled)
          }
          if (config4.signal) {
            config4.signal.removeEventListener("abort", onCanceled)
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"]
        }
        var request3 = new XMLHttpRequest()
        if (config4.auth) {
          var username = config4.auth.username || ""
          var password = config4.auth.password ? unescape(encodeURIComponent(config4.auth.password)) : ""
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password)
        }
        var fullPath = buildFullPath2(config4.baseURL, config4.url)
        request3.open(config4.method.toUpperCase(), buildURL2(fullPath, config4.params, config4.paramsSerializer), true)
        request3.timeout = config4.timeout
        function onloadend() {
          if (!request3) {
            return
          }
          var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders(request3.getAllResponseHeaders()) : null
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response
          var response = {
            data: responseData,
            status: request3.status,
            statusText: request3.statusText,
            headers: responseHeaders,
            config: config4,
            request: request3
          }
          settle2(function _resolve(value) {
            resolve2(value)
            done2()
          }, function _reject(err2) {
            reject(err2)
            done2()
          }, response)
          request3 = null
        }
        if ("onloadend" in request3) {
          request3.onloadend = onloadend
        } else {
          request3.onreadystatechange = function handleLoad() {
            if (!request3 || request3.readyState !== 4) {
              return
            }
            if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
              return
            }
            setTimeout(onloadend)
          }
        }
        request3.onabort = function handleAbort() {
          if (!request3) {
            return
          }
          reject(createError2("Request aborted", config4, "ECONNABORTED", request3))
          request3 = null
        }
        request3.onerror = function handleError() {
          reject(createError2("Network Error", config4, null, request3))
          request3 = null
        }
        request3.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config4.timeout ? "timeout of " + config4.timeout + "ms exceeded" : "timeout exceeded"
          var transitional = config4.transitional || transitionalDefaults
          if (config4.timeoutErrorMessage) {
            timeoutErrorMessage = config4.timeoutErrorMessage
          }
          reject(createError2(
            timeoutErrorMessage,
            config4,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request3
          ))
          request3 = null
        }
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config4.withCredentials || isURLSameOrigin(fullPath)) && config4.xsrfCookieName ? cookies.read(config4.xsrfCookieName) : void 0
          if (xsrfValue) {
            requestHeaders[config4.xsrfHeaderName] = xsrfValue
          }
        }
        if ("setRequestHeader" in request3) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key]
            } else {
              request3.setRequestHeader(key, val)
            }
          })
        }
        if (!utils.isUndefined(config4.withCredentials)) {
          request3.withCredentials = !!config4.withCredentials
        }
        if (responseType && responseType !== "json") {
          request3.responseType = config4.responseType
        }
        if (typeof config4.onDownloadProgress === "function") {
          request3.addEventListener("progress", config4.onDownloadProgress)
        }
        if (typeof config4.onUploadProgress === "function" && request3.upload) {
          request3.upload.addEventListener("progress", config4.onUploadProgress)
        }
        if (config4.cancelToken || config4.signal) {
          onCanceled = function (cancel) {
            if (!request3) {
              return
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel)
            request3.abort()
            request3 = null
          }
          config4.cancelToken && config4.cancelToken.subscribe(onCanceled)
          if (config4.signal) {
            config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled)
          }
        }
        if (!requestData) {
          requestData = null
        }
        request3.send(requestData)
      })
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js
function blobConstructor() {
  if (typeof _blobConstructor !== "undefined") {
    return _blobConstructor
  }
  try {
    new _globalThis.Blob([new ArrayBuffer(1)])
    _blobConstructor = true
  } catch (e) {
    _blobConstructor = false
  }
  return _blobConstructor
}
function checkTypeSupport(type2) {
  if (!xhr) {
    xhr = new _globalThis.XMLHttpRequest()
    xhr.open("GET", _globalThis.location.host ? "/" : "https://example.com")
  }
  try {
    xhr.responseType = type2
    return xhr.responseType === type2
  } catch (e) {
    return false
  }
}
function isFunction(value) {
  return typeof value === "function"
}
var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray
var init_capability = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js"() {
    init_process()
    init_buffer()
    hasFetch = isFunction(_globalThis.fetch) && isFunction(_globalThis.ReadableStream)
    haveArrayBuffer = typeof _globalThis.ArrayBuffer !== "undefined"
    haveSlice = haveArrayBuffer && isFunction(_globalThis.ArrayBuffer.prototype.slice)
    arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer")
    msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream")
    mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer")
    overrideMimeType = isFunction(xhr && xhr.overrideMimeType)
    vbArray = isFunction(_globalThis.VBArray)
    xhr = null
  }
})

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined")
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0)
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout
    return setTimeout(fun, 0)
  }
  try {
    return cachedSetTimeout2(fun, 0)
  } catch (e) {
    try {
      return cachedSetTimeout2.call(null, fun, 0)
    } catch (e2) {
      return cachedSetTimeout2.call(this, fun, 0)
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker)
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout
    return clearTimeout(marker)
  }
  try {
    return cachedClearTimeout2(marker)
  } catch (e) {
    try {
      return cachedClearTimeout2.call(null, marker)
    } catch (e2) {
      return cachedClearTimeout2.call(this, marker)
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return
  }
  draining2 = false
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2)
  } else {
    queueIndex2 = -1
  }
  if (queue2.length) {
    drainQueue2()
  }
}
function drainQueue2() {
  if (draining2) {
    return
  }
  var timeout = runTimeout2(cleanUpNextTick2)
  draining2 = true
  var len = queue2.length
  while (len) {
    currentQueue2 = queue2
    queue2 = []
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run()
      }
    }
    queueIndex2 = -1
    len = queue2.length
  }
  currentQueue2 = null
  draining2 = false
  runClearTimeout2(timeout)
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1)
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i]
    }
  }
  queue2.push(new Item2(fun, args))
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2)
  }
}
function Item2(fun, array) {
  this.fun = fun
  this.array = array
}
function noop2() {
}
function binding2(name) {
  throw new Error("process.binding is not supported")
}
function cwd2() {
  return "/"
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported")
}
function umask2() {
  return 0
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3
  var seconds = Math.floor(clocktime)
  var nanoseconds = Math.floor(clocktime % 1 * 1e9)
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0]
    nanoseconds = nanoseconds - previousTimestamp[1]
    if (nanoseconds < 0) {
      seconds--
      nanoseconds += 1e9
    }
  }
  return [seconds, nanoseconds]
}
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date()
  var dif = currentTime - startTime2
  return dif / 1e3
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env2, argv2, version3, versions2, release2, config3, on2, addListener2, once2, off2, removeListener2, removeAllListeners2, emit2, performance2, performanceNow2, startTime2, browser$1, process_default
var init_process2 = __esm({
  "node-modules-polyfills:process"() {
    init_process()
    init_buffer()
    cachedSetTimeout2 = defaultSetTimout2
    cachedClearTimeout2 = defaultClearTimeout2
    if (typeof _globalThis.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout
    }
    if (typeof _globalThis.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout
    }
    queue2 = []
    draining2 = false
    queueIndex2 = -1
    Item2.prototype.run = function () {
      this.fun.apply(null, this.array)
    }
    title2 = "browser"
    platform2 = "browser"
    browser2 = true
    env2 = {}
    argv2 = []
    version3 = ""
    versions2 = {}
    release2 = {}
    config3 = {}
    on2 = noop2
    addListener2 = noop2
    once2 = noop2
    off2 = noop2
    removeListener2 = noop2
    removeAllListeners2 = noop2
    emit2 = noop2
    performance2 = _globalThis.performance || {}
    performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function () {
      return (/* @__PURE__ */ new Date()).getTime()
    }
    startTime2 = /* @__PURE__ */ new Date()
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env2,
      argv: argv2,
      version: version3,
      versions: versions2,
      on: on2,
      addListener: addListener2,
      once: once2,
      off: off2,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform2,
      release: release2,
      config: config3,
      uptime: uptime2
    }
    process_default = browser$1
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_process()
    init_buffer()
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        })
      }
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {
        }
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }
    inherits_default = inherits
  }
})

// node-modules-polyfills:util
var util_exports = {}
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => inherits_default,
  inspect: () => inspect,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log
})
function format(f) {
  if (!isString(f)) {
    var objects = []
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]))
    }
    return objects.join(" ")
  }
  var i = 1
  var args = arguments
  var len = args.length
  var str = String(f).replace(formatRegExp, function (x2) {
    if (x2 === "%%")
      return "%"
    if (i >= len)
      return x2
    switch (x2) {
      case "%s":
        return String(args[i++])
      case "%d":
        return Number(args[i++])
      case "%j":
        try {
          return JSON.stringify(args[i++])
        } catch (_) {
          return "[Circular]"
        }
      default:
        return x2
    }
  })
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x
    } else {
      str += " " + inspect(x)
    }
  }
  return str
}
function deprecate(fn, msg) {
  if (isUndefined(_globalThis.process)) {
    return function () {
      return deprecate(fn, msg).apply(this, arguments)
    }
  }
  if (process_default.noDeprecation === true) {
    return fn
  }
  var warned = false
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg)
      } else if (process_default.traceDeprecation) {
        console.trace(msg)
      } else {
        console.error(msg)
      }
      warned = true
    }
    return fn.apply(this, arguments)
  }
  return deprecated
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || ""
  set = set.toUpperCase()
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0
      debugs[set] = function () {
        var msg = format.apply(null, arguments)
        console.error("%s %d: %s", set, pid, msg)
      }
    } else {
      debugs[set] = function () {
      }
    }
  }
  return debugs[set]
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }
  if (arguments.length >= 3)
    ctx.depth = arguments[2]
  if (arguments.length >= 4)
    ctx.colors = arguments[3]
  if (isBoolean(opts)) {
    ctx.showHidden = opts
  } else if (opts) {
    _extend(ctx, opts)
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false
  if (isUndefined(ctx.depth))
    ctx.depth = 2
  if (isUndefined(ctx.colors))
    ctx.colors = false
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true
  if (ctx.colors)
    ctx.stylize = stylizeWithColor
  return formatValue(ctx, obj, ctx.depth)
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType]
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m"
  } else {
    return str
  }
}
function stylizeNoColor(str, styleType) {
  return str
}
function arrayToHash(array) {
  var hash2 = {}
  array.forEach(function (val, idx) {
    hash2[val] = true
  })
  return hash2
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx)
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes)
    }
    return ret
  }
  var primitive = formatPrimitive(ctx, value)
  if (primitive) {
    return primitive
  }
  var keys2 = Object.keys(value)
  var visibleKeys = arrayToHash(keys2)
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value)
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value)
  }
  if (keys2.length === 0) {
    if (isFunction2(value)) {
      var name = value.name ? ": " + value.name : ""
      return ctx.stylize("[Function" + name + "]", "special")
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date")
    }
    if (isError(value)) {
      return formatError(value)
    }
  }
  var base2 = "", array = false, braces = ["{", "}"]
  if (isArray(value)) {
    array = true
    braces = ["[", "]"]
  }
  if (isFunction2(value)) {
    var n = value.name ? ": " + value.name : ""
    base2 = " [Function" + n + "]"
  }
  if (isRegExp(value)) {
    base2 = " " + RegExp.prototype.toString.call(value)
  }
  if (isDate(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value)
  }
  if (isError(value)) {
    base2 = " " + formatError(value)
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1]
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
    } else {
      return ctx.stylize("[Object]", "special")
    }
  }
  ctx.seen.push(value)
  var output
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2)
  } else {
    output = keys2.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
    })
  }
  ctx.seen.pop()
  return reduceToSingleString(output, base2, braces)
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined")
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"
    return ctx.stylize(simple, "string")
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number")
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean")
  if (isNull(value))
    return ctx.stylize("null", "null")
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]"
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = []
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ))
    } else {
      output.push("")
    }
  }
  keys2.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ))
    }
  })
  return output
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special")
    } else {
      str = ctx.stylize("[Getter]", "special")
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special")
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]"
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null)
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1)
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function (line) {
            return "  " + line
          }).join("\n").substr(2)
        } else {
          str = "\n" + str.split("\n").map(function (line) {
            return "   " + line
          }).join("\n")
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special")
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str
    }
    name = JSON.stringify("" + key)
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2)
      name = ctx.stylize(name, "name")
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'")
      name = ctx.stylize(name, "string")
    }
  }
  return name + ": " + str
}
function reduceToSingleString(output, base2, braces) {
  var numLinesEst = 0
  var length = output.reduce(function (prev, cur) {
    numLinesEst++
    if (cur.indexOf("\n") >= 0)
      numLinesEst++
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1
  }, 0)
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1]
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1]
}
function isArray(ar) {
  return Array.isArray(ar)
}
function isBoolean(arg) {
  return typeof arg === "boolean"
}
function isNull(arg) {
  return arg === null
}
function isNullOrUndefined(arg) {
  return arg == null
}
function isNumber(arg) {
  return typeof arg === "number"
}
function isString(arg) {
  return typeof arg === "string"
}
function isSymbol(arg) {
  return typeof arg === "symbol"
}
function isUndefined(arg) {
  return arg === void 0
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]"
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]"
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error)
}
function isFunction2(arg) {
  return typeof arg === "function"
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined"
}
function isBuffer2(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf)
}
function objectToString(o) {
  return Object.prototype.toString.call(o)
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10)
}
function timestamp() {
  var d = /* @__PURE__ */ new Date()
  var time = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":")
  return [d.getDate(), months[d.getMonth()], time].join(" ")
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments))
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin
  var keys2 = Object.keys(add)
  var i = keys2.length
  while (i--) {
    origin[keys2[i]] = add[keys2[i]]
  }
  return origin
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop)
}
var formatRegExp, debugs, debugEnviron, months, util_default
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_process()
    init_buffer()
    init_process2()
    init_inherits()
    formatRegExp = /%[sdj%]/g
    debugs = {}
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    }
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    }
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ]
    util_default = {
      inherits: inherits_default,
      _extend,
      log,
      isBuffer: isBuffer2,
      isPrimitive,
      isFunction: isFunction2,
      isError,
      isDate,
      isObject,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray,
      inspect,
      deprecate,
      format,
      debuglog
    }
  }
})

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this)
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners
  return that._maxListeners
}
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self)
  else {
    var len = handler.length
    var listeners2 = arrayClone(handler, len)
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self)
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1)
  else {
    var len = handler.length
    var listeners2 = arrayClone(handler, len)
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1)
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2)
  else {
    var len = handler.length
    var listeners2 = arrayClone(handler, len)
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1, arg2)
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3)
  else {
    var len = handler.length
    var listeners2 = arrayClone(handler, len)
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1, arg2, arg3)
  }
}
function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args)
  else {
    var len = handler.length
    var listeners2 = arrayClone(handler, len)
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self, args)
  }
}
function _addListener(target, type2, listener, prepend) {
  var m
  var events
  var existing
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function')
  events = target._events
  if (!events) {
    events = target._events = new EventHandlers()
    target._eventsCount = 0
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      )
      events = target._events
    }
    existing = events[type2]
  }
  if (!existing) {
    existing = events[type2] = listener
    ++target._eventsCount
  } else {
    if (typeof existing === "function") {
      existing = events[type2] = prepend ? [listener, existing] : [existing, listener]
    } else {
      if (prepend) {
        existing.unshift(listener)
      } else {
        existing.push(listener)
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target)
      if (m && m > 0 && existing.length > m) {
        existing.warned = true
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit")
        w.name = "MaxListenersExceededWarning"
        w.emitter = target
        w.type = type2
        w.count = existing.length
        emitWarning(w)
      }
    }
  }
  return target
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e)
}
function _onceWrap(target, type2, listener) {
  var fired = false
  function g() {
    target.removeListener(type2, g)
    if (!fired) {
      fired = true
      listener.apply(target, arguments)
    }
  }
  g.listener = listener
  return g
}
function listenerCount(type2) {
  var events = this._events
  if (events) {
    var evlistener = events[type2]
    if (typeof evlistener === "function") {
      return 1
    } else if (evlistener) {
      return evlistener.length
    }
  }
  return 0
}
function spliceOne(list2, index) {
  for (var i = index, k = i + 1, n = list2.length; k < n; i += 1, k += 1)
    list2[i] = list2[k]
  list2.pop()
}
function arrayClone(arr, i) {
  var copy3 = new Array(i)
  while (i--)
    copy3[i] = arr[i]
  return copy3
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length)
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i]
  }
  return ret
}
var domain2, events_default
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict"
    init_process()
    init_buffer()
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null)
    events_default = EventEmitter
    EventEmitter.EventEmitter = EventEmitter
    EventEmitter.usingDomains = false
    EventEmitter.prototype.domain = void 0
    EventEmitter.prototype._events = void 0
    EventEmitter.prototype._maxListeners = void 0
    EventEmitter.defaultMaxListeners = 10
    EventEmitter.init = function () {
      this.domain = null
      if (EventEmitter.usingDomains) {
        if (domain2.active && !(this instanceof domain2.Domain)) {
          this.domain = domain2.active
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers()
        this._eventsCount = 0
      }
      this._maxListeners = this._maxListeners || void 0
    }
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number')
      this._maxListeners = n
      return this
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this)
    }
    EventEmitter.prototype.emit = function emit3(type2) {
      var er, handler, len, args, i, events, domain3
      var needDomainExit = false
      var doError = type2 === "error"
      events = this._events
      if (events)
        doError = doError && events.error == null
      else if (!doError)
        return false
      domain3 = this.domain
      if (doError) {
        er = arguments[1]
        if (domain3) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event')
          er.domainEmitter = this
          er.domain = domain3
          er.domainThrown = false
          domain3.emit("error", er)
        } else if (er instanceof Error) {
          throw er
        } else {
          var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")")
          err2.context = er
          throw err2
        }
        return false
      }
      handler = events[type2]
      if (!handler)
        return false
      var isFn = typeof handler === "function"
      len = arguments.length
      switch (len) {
        case 1:
          emitNone(handler, isFn, this)
          break
        case 2:
          emitOne(handler, isFn, this, arguments[1])
          break
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2])
          break
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3])
          break
        default:
          args = new Array(len - 1)
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i]
          emitMany(handler, isFn, this, args)
      }
      if (needDomainExit)
        domain3.exit()
      return true
    }
    EventEmitter.prototype.addListener = function addListener3(type2, listener) {
      return _addListener(this, type2, listener, false)
    }
    EventEmitter.prototype.on = EventEmitter.prototype.addListener
    EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true)
    }
    EventEmitter.prototype.once = function once3(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function')
      this.on(type2, _onceWrap(this, type2, listener))
      return this
    }
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function')
      this.prependListener(type2, _onceWrap(this, type2, listener))
      return this
    }
    EventEmitter.prototype.removeListener = function removeListener3(type2, listener) {
      var list2, events, position, i, originalListener
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function')
      events = this._events
      if (!events)
        return this
      list2 = events[type2]
      if (!list2)
        return this
      if (list2 === listener || list2.listener && list2.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers()
        else {
          delete events[type2]
          if (events.removeListener)
            this.emit("removeListener", type2, list2.listener || listener)
        }
      } else if (typeof list2 !== "function") {
        position = -1
        for (i = list2.length; i-- > 0;) {
          if (list2[i] === listener || list2[i].listener && list2[i].listener === listener) {
            originalListener = list2[i].listener
            position = i
            break
          }
        }
        if (position < 0)
          return this
        if (list2.length === 1) {
          list2[0] = void 0
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers()
            return this
          } else {
            delete events[type2]
          }
        } else {
          spliceOne(list2, position)
        }
        if (events.removeListener)
          this.emit("removeListener", type2, originalListener || listener)
      }
      return this
    }
    EventEmitter.prototype.removeAllListeners = function removeAllListeners3(type2) {
      var listeners2, events
      events = this._events
      if (!events)
        return this
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers()
          this._eventsCount = 0
        } else if (events[type2]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers()
          else
            delete events[type2]
        }
        return this
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events)
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i]
          if (key === "removeListener")
            continue
          this.removeAllListeners(key)
        }
        this.removeAllListeners("removeListener")
        this._events = new EventHandlers()
        this._eventsCount = 0
        return this
      }
      listeners2 = events[type2]
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2)
      } else if (listeners2) {
        do {
          this.removeListener(type2, listeners2[listeners2.length - 1])
        } while (listeners2[0])
      }
      return this
    }
    EventEmitter.prototype.listeners = function listeners(type2) {
      var evlistener
      var ret
      var events = this._events
      if (!events)
        ret = []
      else {
        evlistener = events[type2]
        if (!evlistener)
          ret = []
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener]
        else
          ret = unwrapListeners(evlistener)
      }
      return ret
    }
    EventEmitter.listenerCount = function (emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2)
      } else {
        return listenerCount.call(emitter, type2)
      }
    }
    EventEmitter.prototype.listenerCount = listenerCount
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
    }
  }
})

// node-modules-polyfills:buffer
function init2() {
  inited2 = true
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup2[i] = code[i]
    revLookup2[code.charCodeAt(i)] = i
  }
  revLookup2["-".charCodeAt(0)] = 62
  revLookup2["_".charCodeAt(0)] = 63
}
function toByteArray(b64) {
  if (!inited2) {
    init2()
  }
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4")
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0
  arr = new Arr2(len * 3 / 4 - placeHolders)
  l = placeHolders > 0 ? len - 4 : len
  var L = 0
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)]
    arr[L++] = tmp >> 16 & 255
    arr[L++] = tmp >> 8 & 255
    arr[L++] = tmp & 255
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4
    arr[L++] = tmp & 255
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2
    arr[L++] = tmp >> 8 & 255
    arr[L++] = tmp & 255
  }
  return arr
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63]
}
function encodeChunk2(uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]
    output.push(tripletToBase642(tmp))
  }
  return output.join("")
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2()
  }
  var tmp
  var len = uint8.length
  var extraBytes = len % 3
  var output = ""
  var parts = []
  var maxChunkLength = 16383
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength))
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup2[tmp >> 2]
    output += lookup2[tmp << 4 & 63]
    output += "=="
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    output += lookup2[tmp >> 10]
    output += lookup2[tmp >> 4 & 63]
    output += lookup2[tmp << 2 & 63]
    output += "="
  }
  parts.push(output)
  return parts.join("")
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? nBytes - 1 : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]
  i += d
  e = s & (1 << -nBits) - 1
  s >>= -nBits
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1
  e >>= -nBits
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}
function write2(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
  var i = isLE ? 0 : nBytes - 1
  var d = isLE ? 1 : -1
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
  value = Math.abs(value)
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }
    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128
}
function kMaxLength2() {
  return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length")
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length)
    that.__proto__ = Buffer3.prototype
  } else {
    if (that === null) {
      that = new Buffer3(length)
    }
    that.length = length
  }
  return that
}
function Buffer3(arg, encodingOrOffset, length) {
  if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
    return new Buffer3(arg, encodingOrOffset, length)
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      )
    }
    return allocUnsafe2(this, arg)
  }
  return from2(this, arg, encodingOrOffset, length)
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number')
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length)
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset)
  }
  return fromObject2(that, value)
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size)
  if (size <= 0) {
    return createBuffer2(that, size)
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3)
  }
  return createBuffer2(that, size)
}
function allocUnsafe2(that, size) {
  assertSize2(size)
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0)
  if (!Buffer3.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8"
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }
  var length = byteLength2(string, encoding) | 0
  that = createBuffer2(that, length)
  var actual = that.write(string, encoding)
  if (actual !== length) {
    that = that.slice(0, actual)
  }
  return that
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0
  that = createBuffer2(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds")
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds")
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array)
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = array
    that.__proto__ = Buffer3.prototype
  } else {
    that = fromArrayLike2(that, array)
  }
  return that
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0
    that = createBuffer2(that, len)
    if (that.length === 0) {
      return that
    }
    obj.copy(that, 0, 0, len)
    return that
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0)
      }
      return fromArrayLike2(that, obj)
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike2(that, obj.data)
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes")
  }
  return length | 0
}
function internalIsBuffer2(b) {
  return !!(b != null && b._isBuffer)
}
function byteLength2(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== "string") {
    string = "" + string
  }
  var len = string.length
  if (len === 0)
    return 0
  var loweredCase = false
  for (; ;) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2
      case "hex":
        return len >>> 1
      case "base64":
        return base64ToBytes2(string).length
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length
        encoding = ("" + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false
  if (start === void 0 || start < 0) {
    start = 0
  }
  if (start > this.length) {
    return ""
  }
  if (end === void 0 || end > this.length) {
    end = this.length
  }
  if (end <= 0) {
    return ""
  }
  end >>>= 0
  start >>>= 0
  if (end <= start) {
    return ""
  }
  if (!encoding)
    encoding = "utf8"
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end)
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end)
      case "ascii":
        return asciiSlice2(this, start, end)
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end)
      case "base64":
        return base64Slice2(this, start, end)
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end)
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding)
        encoding = (encoding + "").toLowerCase()
        loweredCase = true
    }
  }
}
function swap2(b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1
  if (typeof byteOffset === "string") {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648
  }
  byteOffset = +byteOffset
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1
    else
      byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0
    else
      return -1
  }
  if (typeof val === "string") {
    val = Buffer3.from(val, encoding)
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === "number") {
    val = val & 255
    if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir)
  }
  throw new TypeError("val must be string, number or Buffer")
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase()
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2]
    } else {
      return buf.readUInt16BE(i2 * indexSize)
    }
  }
  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false
          break
        }
      }
      if (found)
        return i
    }
  }
  return -1
}
function hexWrite2(buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  var strLen = string.length
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string")
  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed))
      return i
    buf[offset + i] = parsed
  }
  return i
}
function utf8Write2(buf, string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length)
}
function asciiWrite2(buf, string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), buf, offset, length)
}
function latin1Write2(buf, string, offset, length) {
  return asciiWrite2(buf, string, offset, length)
}
function base64Write2(buf, string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), buf, offset, length)
}
function ucs2Write2(buf, string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length)
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []
  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533
      bytesPerSequence = 1
    } else if (codePoint > 65535) {
      codePoint -= 65536
      res.push(codePoint >>> 10 & 1023 | 55296)
      codePoint = 56320 | codePoint & 1023
    }
    res.push(codePoint)
    i += bytesPerSequence
  }
  return decodeCodePointsArray2(res)
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints)
  }
  var res = ""
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    )
  }
  return res
}
function asciiSlice2(buf, start, end) {
  var ret = ""
  end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127)
  }
  return ret
}
function latin1Slice2(buf, start, end) {
  var ret = ""
  end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}
function hexSlice2(buf, start, end) {
  var len = buf.length
  if (!start || start < 0)
    start = 0
  if (!end || end < 0 || end > len)
    end = len
  var out = ""
  for (var i = start; i < end; ++i) {
    out += toHex2(buf[i])
  }
  return out
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ""
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint")
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length")
}
function checkInt2(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range")
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
  }
}
function checkIEEE7542(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range")
  if (offset < 0)
    throw new RangeError("Index out of range")
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4)
  }
  write2(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8)
  }
  write2(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "")
  if (str.length < 2)
    return ""
  while (str.length % 4 !== 0) {
    str = str + "="
  }
  return str
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim()
  return str.replace(/^\s+|\s+$/g, "")
}
function toHex2(n) {
  if (n < 16)
    return "0" + n.toString(16)
  return n.toString(16)
}
function utf8ToBytes2(string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189)
          continue
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189)
          continue
        }
        leadSurrogate = codePoint
        continue
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189)
        leadSurrogate = codePoint
        continue
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189)
    }
    leadSurrogate = null
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break
      bytes.push(codePoint)
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      )
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      )
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      )
    } else {
      throw new Error("Invalid code point")
    }
  }
  return bytes
}
function asciiToBytes2(str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255)
  }
  return byteArray
}
function utf16leToBytes2(str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }
  return byteArray
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str))
}
function blitBuffer2(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break
    dst[i + offset] = src[i]
  }
  return i
}
function isnan2(val) {
  return val !== val
}
function isBuffer3(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj))
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj)
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0))
}
var lookup2, revLookup2, Arr2, inited2, toString3, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    init_process()
    init_buffer()
    lookup2 = []
    revLookup2 = []
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array
    inited2 = false
    toString3 = {}.toString
    isArray2 = Array.isArray || function (arr) {
      return toString3.call(arr) == "[object Array]"
    }
    INSPECT_MAX_BYTES = 50
    Buffer3.TYPED_ARRAY_SUPPORT = _globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? _globalThis.TYPED_ARRAY_SUPPORT : true
    _kMaxLength = kMaxLength2()
    Buffer3.poolSize = 8192
    Buffer3._augment = function (arr) {
      arr.__proto__ = Buffer3.prototype
      return arr
    }
    Buffer3.from = function (value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length)
    }
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype
      Buffer3.__proto__ = Uint8Array
    }
    Buffer3.alloc = function (size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding)
    }
    Buffer3.allocUnsafe = function (size) {
      return allocUnsafe2(null, size)
    }
    Buffer3.allocUnsafeSlow = function (size) {
      return allocUnsafe2(null, size)
    }
    Buffer3.isBuffer = isBuffer3
    Buffer3.compare = function compare3(a, b) {
      if (!internalIsBuffer2(a) || !internalIsBuffer2(b)) {
        throw new TypeError("Arguments must be Buffers")
      }
      if (a === b)
        return 0
      var x = a.length
      var y = b.length
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
      if (x < y)
        return -1
      if (y < x)
        return 1
      return 0
    }
    Buffer3.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true
        default:
          return false
      }
    }
    Buffer3.concat = function concat2(list2, length) {
      if (!isArray2(list2)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      if (list2.length === 0) {
        return Buffer3.alloc(0)
      }
      var i
      if (length === void 0) {
        length = 0
        for (i = 0; i < list2.length; ++i) {
          length += list2[i].length
        }
      }
      var buffer = Buffer3.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list2.length; ++i) {
        var buf = list2[i]
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }
    Buffer3.byteLength = byteLength2
    Buffer3.prototype._isBuffer = true
    Buffer3.prototype.swap16 = function swap162() {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits")
      }
      for (var i = 0; i < len; i += 2) {
        swap2(this, i, i + 1)
      }
      return this
    }
    Buffer3.prototype.swap32 = function swap322() {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits")
      }
      for (var i = 0; i < len; i += 4) {
        swap2(this, i, i + 3)
        swap2(this, i + 1, i + 2)
      }
      return this
    }
    Buffer3.prototype.swap64 = function swap642() {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits")
      }
      for (var i = 0; i < len; i += 8) {
        swap2(this, i, i + 7)
        swap2(this, i + 1, i + 6)
        swap2(this, i + 2, i + 5)
        swap2(this, i + 3, i + 4)
      }
      return this
    }
    Buffer3.prototype.toString = function toString4() {
      var length = this.length | 0
      if (length === 0)
        return ""
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length)
      return slowToString2.apply(this, arguments)
    }
    Buffer3.prototype.equals = function equals2(b) {
      if (!internalIsBuffer2(b))
        throw new TypeError("Argument must be a Buffer")
      if (this === b)
        return true
      return Buffer3.compare(this, b) === 0
    }
    Buffer3.prototype.inspect = function inspect2() {
      var str = ""
      var max = INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ")
        if (this.length > max)
          str += " ... "
      }
      return "<Buffer " + str + ">"
    }
    Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer")
      }
      if (start === void 0) {
        start = 0
      }
      if (end === void 0) {
        end = target ? target.length : 0
      }
      if (thisStart === void 0) {
        thisStart = 0
      }
      if (thisEnd === void 0) {
        thisEnd = this.length
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index")
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
      if (this === target)
        return 0
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
      if (x < y)
        return -1
      if (y < x)
        return 1
      return 0
    }
    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, true)
    }
    Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, false)
    }
    Buffer3.prototype.write = function write3(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8"
        length = this.length
        offset = 0
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset
        length = this.length
        offset = 0
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === void 0)
            encoding = "utf8"
        } else {
          encoding = length
          length = void 0
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        )
      }
      var remaining = this.length - offset
      if (length === void 0 || length > remaining)
        length = remaining
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds")
      }
      if (!encoding)
        encoding = "utf8"
      var loweredCase = false
      for (; ;) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string, offset, length)
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string, offset, length)
          case "ascii":
            return asciiWrite2(this, string, offset, length)
          case "latin1":
          case "binary":
            return latin1Write2(this, string, offset, length)
          case "base64":
            return base64Write2(this, string, offset, length)
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string, offset, length)
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding)
            encoding = ("" + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer3.prototype.toJSON = function toJSON3() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    MAX_ARGUMENTS_LENGTH2 = 4096
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length
      start = ~~start
      end = end === void 0 ? len : ~~end
      if (start < 0) {
        start += len
        if (start < 0)
          start = 0
      } else if (start > len) {
        start = len
      }
      if (end < 0) {
        end += len
        if (end < 0)
          end = 0
      } else if (end > len) {
        end = len
      }
      if (end < start)
        end = start
      var newBuf
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer3.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer3(sliceLen, void 0)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }
      return newBuf
    }
    Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length)
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul
      }
      return val
    }
    Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length)
      }
      var val = this[offset + --byteLength3]
      var mul = 1
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul
      }
      return val
    }
    Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length)
      return this[offset]
    }
    Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length)
      return this[offset] | this[offset + 1] << 8
    }
    Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length)
      return this[offset] << 8 | this[offset + 1]
    }
    Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
    }
    Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
    }
    Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length)
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul
      }
      mul *= 128
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3)
      return val
    }
    Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length)
      var i = byteLength3
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul
      }
      mul *= 128
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3)
      return val
    }
    Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length)
      if (!(this[offset] & 128))
        return this[offset]
      return (255 - this[offset] + 1) * -1
    }
    Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length)
      var val = this[offset] | this[offset + 1] << 8
      return val & 32768 ? val | 4294901760 : val
    }
    Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length)
      var val = this[offset + 1] | this[offset] << 8
      return val & 32768 ? val | 4294901760 : val
    }
    Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
    }
    Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
    }
    Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return read(this, offset, true, 23, 4)
    }
    Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length)
      return read(this, offset, false, 23, 4)
    }
    Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length)
      return read(this, offset, true, 52, 8)
    }
    Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length)
      return read(this, offset, false, 52, 8)
    }
    Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1
        checkInt2(this, value, offset, byteLength3, maxBytes, 0)
      }
      var mul = 1
      var i = 0
      this[offset] = value & 255
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255
      }
      return offset + byteLength3
    }
    Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      byteLength3 = byteLength3 | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1
        checkInt2(this, value, offset, byteLength3, maxBytes, 0)
      }
      var i = byteLength3 - 1
      var mul = 1
      this[offset + i] = value & 255
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255
      }
      return offset + byteLength3
    }
    Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0)
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value)
      this[offset] = value & 255
      return offset + 1
    }
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
      } else {
        objectWriteUInt162(this, value, offset, true)
      }
      return offset + 2
    }
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8
        this[offset + 1] = value & 255
      } else {
        objectWriteUInt162(this, value, offset, false)
      }
      return offset + 2
    }
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24
        this[offset + 2] = value >>> 16
        this[offset + 1] = value >>> 8
        this[offset] = value & 255
      } else {
        objectWriteUInt322(this, value, offset, true)
      }
      return offset + 4
    }
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24
        this[offset + 1] = value >>> 16
        this[offset + 2] = value >>> 8
        this[offset + 3] = value & 255
      } else {
        objectWriteUInt322(this, value, offset, false)
      }
      return offset + 4
    }
    Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1)
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit)
      }
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 255
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = (value / mul >> 0) - sub & 255
      }
      return offset + byteLength3
    }
    Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1)
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit)
      }
      var i = byteLength3 - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 255
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = (value / mul >> 0) - sub & 255
      }
      return offset + byteLength3
    }
    Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128)
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value)
      if (value < 0)
        value = 255 + value + 1
      this[offset] = value & 255
      return offset + 1
    }
    Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
      } else {
        objectWriteUInt162(this, value, offset, true)
      }
      return offset + 2
    }
    Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8
        this[offset + 1] = value & 255
      } else {
        objectWriteUInt162(this, value, offset, false)
      }
      return offset + 2
    }
    Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648)
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255
        this[offset + 1] = value >>> 8
        this[offset + 2] = value >>> 16
        this[offset + 3] = value >>> 24
      } else {
        objectWriteUInt322(this, value, offset, true)
      }
      return offset + 4
    }
    Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648)
      if (value < 0)
        value = 4294967295 + value + 1
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24
        this[offset + 1] = value >>> 16
        this[offset + 2] = value >>> 8
        this[offset + 3] = value & 255
      } else {
        objectWriteUInt322(this, value, offset, false)
      }
      return offset + 4
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert)
    }
    Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert)
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert)
    }
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert)
    }
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0
      if (!end && end !== 0)
        end = this.length
      if (targetStart >= target.length)
        targetStart = target.length
      if (!targetStart)
        targetStart = 0
      if (end > 0 && end < start)
        end = start
      if (end === start)
        return 0
      if (target.length === 0 || this.length === 0)
        return 0
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds")
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds")
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds")
      if (end > this.length)
        end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
      var len = end - start
      var i
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }
      return len
    }
    Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === "string") {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string")
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding)
        }
      } else if (typeof val === "number") {
        val = val & 255
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index")
      }
      if (end <= start) {
        return this
      }
      start = start >>> 0
      end = end === void 0 ? this.length : end >>> 0
      if (!val)
        val = 0
      var i
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer3(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
      return this
    }
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null
  this.tail = null
  this.length = 0
}
var buffer_list_default
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_process()
    init_buffer()
    init_buffer2()
    buffer_list_default = BufferList
    BufferList.prototype.push = function (v) {
      var entry = { data: v, next: null }
      if (this.length > 0)
        this.tail.next = entry
      else
        this.head = entry
      this.tail = entry
      ++this.length
    }
    BufferList.prototype.unshift = function (v) {
      var entry = { data: v, next: this.head }
      if (this.length === 0)
        this.tail = entry
      this.head = entry
      ++this.length
    }
    BufferList.prototype.shift = function () {
      if (this.length === 0)
        return
      var ret = this.head.data
      if (this.length === 1)
        this.head = this.tail = null
      else
        this.head = this.head.next
      --this.length
      return ret
    }
    BufferList.prototype.clear = function () {
      this.head = this.tail = null
      this.length = 0
    }
    BufferList.prototype.join = function (s) {
      if (this.length === 0)
        return ""
      var p = this.head
      var ret = "" + p.data
      while (p = p.next) {
        ret += s + p.data
      }
      return ret
    }
    BufferList.prototype.concat = function (n) {
      if (this.length === 0)
        return Buffer3.alloc(0)
      if (this.length === 1)
        return this.head.data
      var ret = Buffer3.allocUnsafe(n >>> 0)
      var p = this.head
      var i = 0
      while (p) {
        p.data.copy(ret, i)
        i += p.data.length
        p = p.next
      }
      return ret
    }
  }
})

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding)
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "")
  assertEncoding(encoding)
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3
      break
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2
      this.detectIncompleteChar = utf16DetectIncompleteChar
      break
    case "base64":
      this.surrogateSize = 3
      this.detectIncompleteChar = base64DetectIncompleteChar
      break
    default:
      this.write = passThroughWrite
      return
  }
  this.charBuffer = new Buffer3(6)
  this.charReceived = 0
  this.charLength = 0
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding)
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2
  this.charLength = this.charReceived ? 2 : 0
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3
  this.charLength = this.charReceived ? 3 : 0
}
var isBufferEncoding
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_process()
    init_buffer()
    init_buffer2()
    isBufferEncoding = Buffer3.isEncoding || function (encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true
        default:
          return false
      }
    }
    StringDecoder.prototype.write = function (buffer) {
      var charStr = ""
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length
        buffer.copy(this.charBuffer, this.charReceived, 0, available)
        this.charReceived += available
        if (this.charReceived < this.charLength) {
          return ""
        }
        buffer = buffer.slice(available, buffer.length)
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding)
        var charCode = charStr.charCodeAt(charStr.length - 1)
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize
          charStr = ""
          continue
        }
        this.charReceived = this.charLength = 0
        if (buffer.length === 0) {
          return charStr
        }
        break
      }
      this.detectIncompleteChar(buffer)
      var end = buffer.length
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end)
        end -= this.charReceived
      }
      charStr += buffer.toString(this.encoding, 0, end)
      var end = charStr.length - 1
      var charCode = charStr.charCodeAt(end)
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize
        this.charLength += size
        this.charReceived += size
        this.charBuffer.copy(this.charBuffer, size, 0, size)
        buffer.copy(this.charBuffer, 0, 0, size)
        return charStr.substring(0, end)
      }
      return charStr
    }
    StringDecoder.prototype.detectIncompleteChar = function (buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i]
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2
          break
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3
          break
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4
          break
        }
      }
      this.charReceived = i
    }
    StringDecoder.prototype.end = function (buffer) {
      var res = ""
      if (buffer && buffer.length)
        res = this.write(buffer)
      if (this.charReceived) {
        var cr = this.charReceived
        var buf = this.charBuffer
        var enc = this.encoding
        res += buf.slice(0, cr).toString(enc)
      }
      return res
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn)
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn)
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn)
    else
      emitter._events[event] = [fn, emitter._events[event]]
  }
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length
}
function ReadableState(options2, stream) {
  options2 = options2 || {}
  this.objectMode = !!options2.objectMode
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode
  var hwm = options2.highWaterMark
  var defaultHwm = this.objectMode ? 16 : 16 * 1024
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm
  this.highWaterMark = ~~this.highWaterMark
  this.buffer = new buffer_list_default()
  this.length = 0
  this.pipes = null
  this.pipesCount = 0
  this.flowing = null
  this.ended = false
  this.endEmitted = false
  this.reading = false
  this.sync = true
  this.needReadable = false
  this.emittedReadable = false
  this.readableListening = false
  this.resumeScheduled = false
  this.defaultEncoding = options2.defaultEncoding || "utf8"
  this.ranOut = false
  this.awaitDrain = 0
  this.readingMore = false
  this.decoder = null
  this.encoding = null
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding)
    this.encoding = options2.encoding
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2)
  this._readableState = new ReadableState(options2, this)
  this.readable = true
  if (options2 && typeof options2.read === "function")
    this._read = options2.read
  events_default.call(this)
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk)
  if (er) {
    stream.emit("error", er)
  } else if (chunk === null) {
    state.reading = false
    onEofChunk(stream, state)
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF")
      stream.emit("error", e)
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event")
      stream.emit("error", _e)
    } else {
      var skipAdd
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk)
        skipAdd = !state.objectMode && chunk.length === 0
      }
      if (!addToFront)
        state.reading = false
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk)
          stream.read(0)
        } else {
          state.length += state.objectMode ? 1 : chunk.length
          if (addToFront)
            state.buffer.unshift(chunk)
          else
            state.buffer.push(chunk)
          if (state.needReadable)
            emitReadable(stream)
        }
      }
      maybeReadMore(stream, state)
    }
  } else if (!addToFront) {
    state.reading = false
  }
  return needMoreData(state)
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0)
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM
  } else {
    n--
    n |= n >>> 1
    n |= n >>> 2
    n |= n >>> 4
    n |= n >>> 8
    n |= n >>> 16
    n++
  }
  return n
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0
  if (state.objectMode)
    return 1
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length
    else
      return state.length
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n)
  if (n <= state.length)
    return n
  if (!state.ended) {
    state.needReadable = true
    return 0
  }
  return state.length
}
function chunkInvalid(state, chunk) {
  var er = null
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk")
  }
  return er
}
function onEofChunk(stream, state) {
  if (state.ended)
    return
  if (state.decoder) {
    var chunk = state.decoder.end()
    if (chunk && chunk.length) {
      state.buffer.push(chunk)
      state.length += state.objectMode ? 1 : chunk.length
    }
  }
  state.ended = true
  emitReadable(stream)
}
function emitReadable(stream) {
  var state = stream._readableState
  state.needReadable = false
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing)
    state.emittedReadable = true
    if (state.sync)
      nextTick2(emitReadable_, stream)
    else
      emitReadable_(stream)
  }
}
function emitReadable_(stream) {
  debug("emit readable")
  stream.emit("readable")
  flow(stream)
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true
    nextTick2(maybeReadMore_, stream, state)
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0")
    stream.read(0)
    if (len === state.length)
      break
    else
      len = state.length
  }
  state.readingMore = false
}
function pipeOnDrain(src) {
  return function () {
    var state = src._readableState
    debug("pipeOnDrain", state.awaitDrain)
    if (state.awaitDrain)
      state.awaitDrain--
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true
      flow(src)
    }
  }
}
function nReadingNextTick(self) {
  debug("readable nexttick read 0")
  self.read(0)
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true
    nextTick2(resume_, stream, state)
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0")
    stream.read(0)
  }
  state.resumeScheduled = false
  state.awaitDrain = 0
  stream.emit("resume")
  flow(stream)
  if (state.flowing && !state.reading)
    stream.read(0)
}
function flow(stream) {
  var state = stream._readableState
  debug("flow", state.flowing)
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null
  var ret
  if (state.objectMode)
    ret = state.buffer.shift()
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("")
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data
    else
      ret = state.buffer.concat(state.length)
    state.buffer.clear()
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder)
  }
  return ret
}
function fromListPartial(n, list2, hasStrings) {
  var ret
  if (n < list2.head.data.length) {
    ret = list2.head.data.slice(0, n)
    list2.head.data = list2.head.data.slice(n)
  } else if (n === list2.head.data.length) {
    ret = list2.shift()
  } else {
    ret = hasStrings ? copyFromBufferString(n, list2) : copyFromBuffer(n, list2)
  }
  return ret
}
function copyFromBufferString(n, list2) {
  var p = list2.head
  var c = 1
  var ret = p.data
  n -= ret.length
  while (p = p.next) {
    var str = p.data
    var nb = n > str.length ? str.length : n
    if (nb === str.length)
      ret += str
    else
      ret += str.slice(0, n)
    n -= nb
    if (n === 0) {
      if (nb === str.length) {
        ++c
        if (p.next)
          list2.head = p.next
        else
          list2.head = list2.tail = null
      } else {
        list2.head = p
        p.data = str.slice(nb)
      }
      break
    }
    ++c
  }
  list2.length -= c
  return ret
}
function copyFromBuffer(n, list2) {
  var ret = Buffer2.allocUnsafe(n)
  var p = list2.head
  var c = 1
  p.data.copy(ret)
  n -= p.data.length
  while (p = p.next) {
    var buf = p.data
    var nb = n > buf.length ? buf.length : n
    buf.copy(ret, ret.length - n, 0, nb)
    n -= nb
    if (n === 0) {
      if (nb === buf.length) {
        ++c
        if (p.next)
          list2.head = p.next
        else
          list2.head = list2.tail = null
      } else {
        list2.head = p
        p.data = buf.slice(nb)
      }
      break
    }
    ++c
  }
  list2.length -= c
  return ret
}
function endReadable(stream) {
  var state = stream._readableState
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream')
  if (!state.endEmitted) {
    state.ended = true
    nextTick2(endReadableNT, state, stream)
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true
    stream.readable = false
    stream.emit("end")
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i)
  }
}
function indexOf3(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i
  }
  return -1
}
var debug, MAX_HWM
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict"
    init_process()
    init_buffer()
    init_events()
    init_util()
    init_buffer_list()
    init_string_decoder()
    init_duplex()
    init_process2()
    Readable.ReadableState = ReadableState
    debug = debuglog("stream")
    inherits_default(Readable, events_default)
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding)
          encoding = ""
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false)
    }
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState
      return readableAddChunk(this, state, chunk, "", true)
    }
    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false
    }
    Readable.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder(enc)
      this._readableState.encoding = enc
      return this
    }
    MAX_HWM = 8388608
    Readable.prototype.read = function (n) {
      debug("read", n)
      n = parseInt(n, 10)
      var state = this._readableState
      var nOrig = n
      if (n !== 0)
        state.emittedReadable = false
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended)
        if (state.length === 0 && state.ended)
          endReadable(this)
        else
          emitReadable(this)
        return null
      }
      n = howMuchToRead(n, state)
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this)
        return null
      }
      var doRead = state.needReadable
      debug("need readable", doRead)
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true
        debug("length less than watermark", doRead)
      }
      if (state.ended || state.reading) {
        doRead = false
        debug("reading or ended", doRead)
      } else if (doRead) {
        debug("do read")
        state.reading = true
        state.sync = true
        if (state.length === 0)
          state.needReadable = true
        this._read(state.highWaterMark)
        state.sync = false
        if (!state.reading)
          n = howMuchToRead(nOrig, state)
      }
      var ret
      if (n > 0)
        ret = fromList(n, state)
      else
        ret = null
      if (ret === null) {
        state.needReadable = true
        n = 0
      } else {
        state.length -= n
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true
        if (nOrig !== n && state.ended)
          endReadable(this)
      }
      if (ret !== null)
        this.emit("data", ret)
      return ret
    }
    Readable.prototype._read = function (n) {
      this.emit("error", new Error("not implemented"))
    }
    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this
      var state = this._readableState
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest
          break
        case 1:
          state.pipes = [state.pipes, dest]
          break
        default:
          state.pipes.push(dest)
          break
      }
      state.pipesCount += 1
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts)
      var doEnd = !pipeOpts || pipeOpts.end !== false
      var endFn = doEnd ? onend2 : cleanup
      if (state.endEmitted)
        nextTick2(endFn)
      else
        src.once("end", endFn)
      dest.on("unpipe", onunpipe)
      function onunpipe(readable) {
        debug("onunpipe")
        if (readable === src) {
          cleanup()
        }
      }
      function onend2() {
        debug("onend")
        dest.end()
      }
      var ondrain = pipeOnDrain(src)
      dest.on("drain", ondrain)
      var cleanedUp = false
      function cleanup() {
        debug("cleanup")
        dest.removeListener("close", onclose)
        dest.removeListener("finish", onfinish)
        dest.removeListener("drain", ondrain)
        dest.removeListener("error", onerror)
        dest.removeListener("unpipe", onunpipe)
        src.removeListener("end", onend2)
        src.removeListener("end", cleanup)
        src.removeListener("data", ondata)
        cleanedUp = true
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain()
      }
      var increasedAwaitDrain = false
      src.on("data", ondata)
      function ondata(chunk) {
        debug("ondata")
        increasedAwaitDrain = false
        var ret = dest.write(chunk)
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain)
            src._readableState.awaitDrain++
            increasedAwaitDrain = true
          }
          src.pause()
        }
      }
      function onerror(er) {
        debug("onerror", er)
        unpipe()
        dest.removeListener("error", onerror)
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er)
      }
      prependListener2(dest, "error", onerror)
      function onclose() {
        dest.removeListener("finish", onfinish)
        unpipe()
      }
      dest.once("close", onclose)
      function onfinish() {
        debug("onfinish")
        dest.removeListener("close", onclose)
        unpipe()
      }
      dest.once("finish", onfinish)
      function unpipe() {
        debug("unpipe")
        src.unpipe(dest)
      }
      dest.emit("pipe", src)
      if (!state.flowing) {
        debug("pipe resume")
        src.resume()
      }
      return dest
    }
    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState
      if (state.pipesCount === 0)
        return this
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this
        if (!dest)
          dest = state.pipes
        state.pipes = null
        state.pipesCount = 0
        state.flowing = false
        if (dest)
          dest.emit("unpipe", this)
        return this
      }
      if (!dest) {
        var dests = state.pipes
        var len = state.pipesCount
        state.pipes = null
        state.pipesCount = 0
        state.flowing = false
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this)
        }
        return this
      }
      var i = indexOf3(state.pipes, dest)
      if (i === -1)
        return this
      state.pipes.splice(i, 1)
      state.pipesCount -= 1
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0]
      dest.emit("unpipe", this)
      return this
    }
    Readable.prototype.on = function (ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn)
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume()
      } else if (ev === "readable") {
        var state = this._readableState
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true
          state.emittedReadable = false
          if (!state.reading) {
            nextTick2(nReadingNextTick, this)
          } else if (state.length) {
            emitReadable(this, state)
          }
        }
      }
      return res
    }
    Readable.prototype.addListener = Readable.prototype.on
    Readable.prototype.resume = function () {
      var state = this._readableState
      if (!state.flowing) {
        debug("resume")
        state.flowing = true
        resume(this, state)
      }
      return this
    }
    Readable.prototype.pause = function () {
      debug("call pause flowing=%j", this._readableState.flowing)
      if (false !== this._readableState.flowing) {
        debug("pause")
        this._readableState.flowing = false
        this.emit("pause")
      }
      return this
    }
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState
      var paused = false
      var self = this
      stream.on("end", function () {
        debug("wrapped end")
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end()
          if (chunk && chunk.length)
            self.push(chunk)
        }
        self.push(null)
      })
      stream.on("data", function (chunk) {
        debug("wrapped data")
        if (state.decoder)
          chunk = state.decoder.write(chunk)
        if (state.objectMode && (chunk === null || chunk === void 0))
          return
        else if (!state.objectMode && (!chunk || !chunk.length))
          return
        var ret = self.push(chunk)
        if (!ret) {
          paused = true
          stream.pause()
        }
      })
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments)
            }
          }(i)
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"]
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev))
      })
      self._read = function (n) {
        debug("wrapped _read", n)
        if (paused) {
          paused = false
          stream.resume()
        }
      }
      return self
    }
    Readable._fromList = fromList
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk
  this.encoding = encoding
  this.callback = cb
  this.next = null
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function () {
      return this.getBuffer()
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  })
  options2 = options2 || {}
  this.objectMode = !!options2.objectMode
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode
  var hwm = options2.highWaterMark
  var defaultHwm = this.objectMode ? 16 : 16 * 1024
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm
  this.highWaterMark = ~~this.highWaterMark
  this.needDrain = false
  this.ending = false
  this.ended = false
  this.finished = false
  var noDecode = options2.decodeStrings === false
  this.decodeStrings = !noDecode
  this.defaultEncoding = options2.defaultEncoding || "utf8"
  this.length = 0
  this.writing = false
  this.corked = 0
  this.sync = true
  this.bufferProcessing = false
  this.onwrite = function (er) {
    onwrite(stream, er)
  }
  this.writecb = null
  this.writelen = 0
  this.bufferedRequest = null
  this.lastBufferedRequest = null
  this.pendingcb = 0
  this.prefinished = false
  this.errorEmitted = false
  this.bufferedRequestCount = 0
  this.corkedRequestsFree = new CorkedRequest(this)
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2)
  this._writableState = new WritableState(options2, this)
  this.writable = true
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write
    if (typeof options2.writev === "function")
      this._writev = options2.writev
  }
  EventEmitter.call(this)
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end")
  stream.emit("error", er)
  nextTick2(cb, er)
}
function validChunk(stream, state, chunk, cb) {
  var valid = true
  var er = false
  if (chunk === null) {
    er = new TypeError("May not write null values to stream")
  } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk")
  }
  if (er) {
    stream.emit("error", er)
    nextTick2(cb, er)
    valid = false
  }
  return valid
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding)
  }
  return chunk
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding)
  if (Buffer3.isBuffer(chunk))
    encoding = "buffer"
  var len = state.objectMode ? 1 : chunk.length
  state.length += len
  var ret = state.length < state.highWaterMark
  if (!ret)
    state.needDrain = true
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb)
    if (last) {
      last.next = state.lastBufferedRequest
    } else {
      state.bufferedRequest = state.lastBufferedRequest
    }
    state.bufferedRequestCount += 1
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb)
  }
  return ret
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len
  state.writecb = cb
  state.writing = true
  state.sync = true
  if (writev)
    stream._writev(chunk, state.onwrite)
  else
    stream._write(chunk, encoding, state.onwrite)
  state.sync = false
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb
  if (sync)
    nextTick2(cb, er)
  else
    cb(er)
  stream._writableState.errorEmitted = true
  stream.emit("error", er)
}
function onwriteStateUpdate(state) {
  state.writing = false
  state.writecb = null
  state.length -= state.writelen
  state.writelen = 0
}
function onwrite(stream, er) {
  var state = stream._writableState
  var sync = state.sync
  var cb = state.writecb
  onwriteStateUpdate(state)
  if (er)
    onwriteError(stream, state, sync, er, cb)
  else {
    var finished = needFinish(state)
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state)
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb)
    } else {
      afterWrite(stream, state, finished, cb)
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state)
  state.pendingcb--
  cb()
  finishMaybe(stream, state)
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false
    stream.emit("drain")
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true
  var entry = state.bufferedRequest
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount
    var buffer = new Array(l)
    var holder = state.corkedRequestsFree
    holder.entry = entry
    var count = 0
    while (entry) {
      buffer[count] = entry
      entry = entry.next
      count += 1
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish)
    state.pendingcb++
    state.lastBufferedRequest = null
    if (holder.next) {
      state.corkedRequestsFree = holder.next
      holder.next = null
    } else {
      state.corkedRequestsFree = new CorkedRequest(state)
    }
  } else {
    while (entry) {
      var chunk = entry.chunk
      var encoding = entry.encoding
      var cb = entry.callback
      var len = state.objectMode ? 1 : chunk.length
      doWrite(stream, state, false, len, chunk, encoding, cb)
      entry = entry.next
      if (state.writing) {
        break
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null
  }
  state.bufferedRequestCount = 0
  state.bufferedRequest = entry
  state.bufferProcessing = false
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true
    stream.emit("prefinish")
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state)
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state)
      state.finished = true
      stream.emit("finish")
    } else {
      prefinish(stream, state)
    }
  }
  return need
}
function endWritable(stream, state, cb) {
  state.ending = true
  finishMaybe(stream, state)
  if (cb) {
    if (state.finished)
      nextTick2(cb)
    else
      stream.once("finish", cb)
  }
  state.ended = true
  stream.writable = false
}
function CorkedRequest(state) {
  var _this = this
  this.next = null
  this.entry = null
  this.finish = function (err2) {
    var entry = _this.entry
    _this.entry = null
    while (entry) {
      var cb = entry.callback
      state.pendingcb--
      cb(err2)
      entry = entry.next
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this
    } else {
      state.corkedRequestsFree = _this
    }
  }
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_process()
    init_buffer()
    init_util()
    init_buffer2()
    init_events()
    init_duplex()
    init_process2()
    Writable.WritableState = WritableState
    inherits_default(Writable, EventEmitter)
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest
      var out = []
      while (current) {
        out.push(current)
        current = current.next
      }
      return out
    }
    Writable.prototype.pipe = function () {
      this.emit("error", new Error("Cannot pipe, not readable"))
    }
    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState
      var ret = false
      if (typeof encoding === "function") {
        cb = encoding
        encoding = null
      }
      if (Buffer3.isBuffer(chunk))
        encoding = "buffer"
      else if (!encoding)
        encoding = state.defaultEncoding
      if (typeof cb !== "function")
        cb = nop
      if (state.ended)
        writeAfterEnd(this, cb)
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++
        ret = writeOrBuffer(this, state, chunk, encoding, cb)
      }
      return ret
    }
    Writable.prototype.cork = function () {
      var state = this._writableState
      state.corked++
    }
    Writable.prototype.uncork = function () {
      var state = this._writableState
      if (state.corked) {
        state.corked--
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state)
      }
    }
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase()
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding)
      this._writableState.defaultEncoding = encoding
      return this
    }
    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error("not implemented"))
    }
    Writable.prototype._writev = null
    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState
      if (typeof chunk === "function") {
        cb = chunk
        chunk = null
        encoding = null
      } else if (typeof encoding === "function") {
        cb = encoding
        encoding = null
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding)
      if (state.corked) {
        state.corked = 1
        this.uncork()
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb)
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2)
  Readable.call(this, options2)
  Writable.call(this, options2)
  if (options2 && options2.readable === false)
    this.readable = false
  if (options2 && options2.writable === false)
    this.writable = false
  this.allowHalfOpen = true
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false
  this.once("end", onend)
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return
  nextTick2(onEndNT, this)
}
function onEndNT(self) {
  self.end()
}
var keys, method, v
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_process()
    init_buffer()
    init_util()
    init_process2()
    init_readable()
    init_writable()
    inherits_default(Duplex, Readable)
    keys = Object.keys(Writable.prototype)
    for (v = 0; v < keys.length; v++) {
      method = keys[v]
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method]
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data)
  }
  this.needTransform = false
  this.transforming = false
  this.writecb = null
  this.writechunk = null
  this.writeencoding = null
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState
  ts.transforming = false
  var cb = ts.writecb
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"))
  ts.writechunk = null
  ts.writecb = null
  if (data !== null && data !== void 0)
    stream.push(data)
  cb(er)
  var rs = stream._readableState
  rs.reading = false
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark)
  }
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2)
  Duplex.call(this, options2)
  this._transformState = new TransformState(this)
  var stream = this
  this._readableState.needReadable = true
  this._readableState.sync = false
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform
    if (typeof options2.flush === "function")
      this._flush = options2.flush
  }
  this.once("prefinish", function () {
    if (typeof this._flush === "function")
      this._flush(function (er) {
        done(stream, er)
      })
    else
      done(stream)
  })
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er)
  var ws = stream._writableState
  var ts = stream._transformState
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0")
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming")
  return stream.push(null)
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_process()
    init_buffer()
    init_duplex()
    init_util()
    inherits_default(Transform, Duplex)
    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false
      return Duplex.prototype.push.call(this, chunk, encoding)
    }
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error("Not implemented")
    }
    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState
      ts.writecb = cb
      ts.writechunk = chunk
      ts.writeencoding = encoding
      if (!ts.transforming) {
        var rs = this._readableState
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark)
      }
    }
    Transform.prototype._read = function (n) {
      var ts = this._transformState
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
      } else {
        ts.needTransform = true
      }
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2)
  Transform.call(this, options2)
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_process()
    init_buffer()
    init_transform()
    init_util()
    inherits_default(PassThrough, Transform)
    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk)
    }
  }
})

// node-modules-polyfills:stream
var stream_exports = {}
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
})
function Stream() {
  events_default.call(this)
}
var stream_default
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_process()
    init_buffer()
    init_events()
    init_util()
    init_duplex()
    init_readable()
    init_writable()
    init_transform()
    init_passthrough()
    inherits_default(Stream, events_default)
    Stream.Readable = Readable
    Stream.Writable = Writable
    Stream.Duplex = Duplex
    Stream.Transform = Transform
    Stream.PassThrough = PassThrough
    Stream.Stream = Stream
    stream_default = Stream
    Stream.prototype.pipe = function (dest, options2) {
      var source = this
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause()
          }
        }
      }
      source.on("data", ondata)
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume()
        }
      }
      dest.on("drain", ondrain)
      if (!dest._isStdio && (!options2 || options2.end !== false)) {
        source.on("end", onend2)
        source.on("close", onclose)
      }
      var didOnEnd = false
      function onend2() {
        if (didOnEnd)
          return
        didOnEnd = true
        dest.end()
      }
      function onclose() {
        if (didOnEnd)
          return
        didOnEnd = true
        if (typeof dest.destroy === "function")
          dest.destroy()
      }
      function onerror(er) {
        cleanup()
        if (events_default.listenerCount(this, "error") === 0) {
          throw er
        }
      }
      source.on("error", onerror)
      dest.on("error", onerror)
      function cleanup() {
        source.removeListener("data", ondata)
        dest.removeListener("drain", ondrain)
        source.removeListener("end", onend2)
        source.removeListener("close", onclose)
        source.removeListener("error", onerror)
        dest.removeListener("error", onerror)
        source.removeListener("end", cleanup)
        source.removeListener("close", cleanup)
        dest.removeListener("close", cleanup)
      }
      source.on("end", cleanup)
      source.on("close", cleanup)
      dest.on("close", cleanup)
      dest.emit("pipe", source)
      return dest
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js
function IncomingMessage(xhr2, response, mode) {
  var self = this
  Readable.call(self)
  self._mode = mode
  self.headers = {}
  self.rawHeaders = []
  self.trailers = {}
  self.rawTrailers = []
  self.on("end", function () {
    process.nextTick(function () {
      self.emit("close")
    })
  })
  var read2
  if (mode === "fetch") {
    self._fetchResponse = response
    self.url = response.url
    self.statusCode = response.status
    self.statusMessage = response.statusText
    for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
      self.headers[header[0].toLowerCase()] = header[1]
      self.rawHeaders.push(header[0], header[1])
    }
    var reader = response.body.getReader()
    read2 = function () {
      reader.read().then(function (result) {
        if (self._destroyed)
          return
        if (result.done) {
          self.push(null)
          return
        }
        self.push(new Buffer2(result.value))
        read2()
      })
    }
    read2()
  } else {
    self._xhr = xhr2
    self._pos = 0
    self.url = xhr2.responseURL
    self.statusCode = xhr2.status
    self.statusMessage = xhr2.statusText
    var headers = xhr2.getAllResponseHeaders().split(/\r?\n/)
    headers.forEach(function (header2) {
      var matches = header2.match(/^([^:]+):\s*(.*)/)
      if (matches) {
        var key = matches[1].toLowerCase()
        if (key === "set-cookie") {
          if (self.headers[key] === void 0) {
            self.headers[key] = []
          }
          self.headers[key].push(matches[2])
        } else if (self.headers[key] !== void 0) {
          self.headers[key] += ", " + matches[2]
        } else {
          self.headers[key] = matches[2]
        }
        self.rawHeaders.push(matches[1], matches[2])
      }
    })
    self._charset = "x-user-defined"
    if (!overrideMimeType) {
      var mimeType = self.rawHeaders["mime-type"]
      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
        if (charsetMatch) {
          self._charset = charsetMatch[1].toLowerCase()
        }
      }
      if (!self._charset)
        self._charset = "utf-8"
    }
  }
}
var rStates
var init_response = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js"() {
    init_process()
    init_buffer()
    init_capability()
    init_util()
    init_stream()
    rStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    }
    inherits_default(IncomingMessage, Readable)
    IncomingMessage.prototype._read = function () {
    }
    IncomingMessage.prototype._onXHRProgress = function () {
      var self = this
      var xhr2 = self._xhr
      var response = null
      switch (self._mode) {
        case "text:vbarray":
          if (xhr2.readyState !== rStates.DONE)
            break
          try {
            response = new _globalThis.VBArray(xhr2.responseBody).toArray()
          } catch (e) {
          }
          if (response !== null) {
            self.push(new Buffer2(response))
            break
          }
        case "text":
          try {
            response = xhr2.responseText
          } catch (e) {
            self._mode = "text:vbarray"
            break
          }
          if (response.length > self._pos) {
            var newData = response.substr(self._pos)
            if (self._charset === "x-user-defined") {
              var buffer = new Buffer2(newData.length)
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255
              self.push(buffer)
            } else {
              self.push(newData, self._charset)
            }
            self._pos = response.length
          }
          break
        case "arraybuffer":
          if (xhr2.readyState !== rStates.DONE || !xhr2.response)
            break
          response = xhr2.response
          self.push(new Buffer2(new Uint8Array(response)))
          break
        case "moz-chunked-arraybuffer":
          response = xhr2.response
          if (xhr2.readyState !== rStates.LOADING || !response)
            break
          self.push(new Buffer2(new Uint8Array(response)))
          break
        case "ms-stream":
          response = xhr2.response
          if (xhr2.readyState !== rStates.LOADING)
            break
          var reader = new _globalThis.MSStreamReader()
          reader.onprogress = function () {
            if (reader.result.byteLength > self._pos) {
              self.push(new Buffer2(new Uint8Array(reader.result.slice(self._pos))))
              self._pos = reader.result.byteLength
            }
          }
          reader.onload = function () {
            self.push(null)
          }
          reader.readAsArrayBuffer(response)
          break
      }
      if (self._xhr.readyState === rStates.DONE && self._mode !== "ms-stream") {
        self.push(null)
      }
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js
function to_arraybuffer_default(buf) {
  if (buf instanceof Uint8Array) {
    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer
    } else if (typeof buf.buffer.slice === "function") {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
    }
  }
  if (isBuffer3(buf)) {
    var arrayCopy = new Uint8Array(buf.length)
    var len = buf.length
    for (var i = 0; i < len; i++) {
      arrayCopy[i] = buf[i]
    }
    return arrayCopy.buffer
  } else {
    throw new Error("Argument must be a Buffer")
  }
}
var init_to_arraybuffer = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js"() {
    init_process()
    init_buffer()
    init_buffer2()
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js
function decideMode(preferBinary, useFetch) {
  if (hasFetch && useFetch) {
    return "fetch"
  } else if (mozchunkedarraybuffer) {
    return "moz-chunked-arraybuffer"
  } else if (msstream) {
    return "ms-stream"
  } else if (arraybuffer && preferBinary) {
    return "arraybuffer"
  } else if (vbArray && preferBinary) {
    return "text:vbarray"
  } else {
    return "text"
  }
}
function ClientRequest(opts) {
  var self = this
  Writable.call(self)
  self._opts = opts
  self._body = []
  self._headers = {}
  if (opts.auth)
    self.setHeader("Authorization", "Basic " + new Buffer2(opts.auth).toString("base64"))
  Object.keys(opts.headers).forEach(function (name) {
    self.setHeader(name, opts.headers[name])
  })
  var preferBinary
  var useFetch = true
  if (opts.mode === "disable-fetch") {
    useFetch = false
    preferBinary = true
  } else if (opts.mode === "prefer-streaming") {
    preferBinary = false
  } else if (opts.mode === "allow-wrong-content-type") {
    preferBinary = !overrideMimeType
  } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
    preferBinary = true
  } else {
    throw new Error("Invalid value for opts.mode")
  }
  self._mode = decideMode(preferBinary, useFetch)
  self.on("finish", function () {
    self._onFinish()
  })
}
function statusValid(xhr2) {
  try {
    var status2 = xhr2.status
    return status2 !== null && status2 !== 0
  } catch (e) {
    return false
  }
}
var request_default, unsafeHeaders
var init_request = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js"() {
    init_process()
    init_buffer()
    init_capability()
    init_util()
    init_response()
    init_stream()
    init_to_arraybuffer()
    request_default = ClientRequest
    inherits_default(ClientRequest, Writable)
    unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "user-agent",
      "via"
    ]
    ClientRequest.prototype.setHeader = function (name, value) {
      var self = this
      var lowerName = name.toLowerCase()
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return
      self._headers[lowerName] = {
        name,
        value
      }
    }
    ClientRequest.prototype.getHeader = function (name) {
      var self = this
      return self._headers[name.toLowerCase()].value
    }
    ClientRequest.prototype.removeHeader = function (name) {
      var self = this
      delete self._headers[name.toLowerCase()]
    }
    ClientRequest.prototype._onFinish = function () {
      var self = this
      if (self._destroyed)
        return
      var opts = self._opts
      var headersObj = self._headers
      var body
      if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
        if (blobConstructor()) {
          body = new _globalThis.Blob(self._body.map(function (buffer) {
            return to_arraybuffer_default(buffer)
          }), {
            type: (headersObj["content-type"] || {}).value || ""
          })
        } else {
          body = Buffer2.concat(self._body).toString()
        }
      }
      if (self._mode === "fetch") {
        var headers = Object.keys(headersObj).map(function (name) {
          return [headersObj[name].name, headersObj[name].value]
        })
        _globalThis.fetch(self._opts.url, {
          method: self._opts.method,
          headers,
          body,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin"
        }).then(function (response) {
          self._fetchResponse = response
          self._connect()
        }, function (reason) {
          self.emit("error", reason)
        })
      } else {
        var xhr2 = self._xhr = new _globalThis.XMLHttpRequest()
        try {
          xhr2.open(self._opts.method, self._opts.url, true)
        } catch (err2) {
          process.nextTick(function () {
            self.emit("error", err2)
          })
          return
        }
        if ("responseType" in xhr2)
          xhr2.responseType = self._mode.split(":")[0]
        if ("withCredentials" in xhr2)
          xhr2.withCredentials = !!opts.withCredentials
        if (self._mode === "text" && "overrideMimeType" in xhr2)
          xhr2.overrideMimeType("text/plain; charset=x-user-defined")
        Object.keys(headersObj).forEach(function (name) {
          xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value)
        })
        self._response = null
        xhr2.onreadystatechange = function () {
          switch (xhr2.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self._onXHRProgress()
              break
          }
        }
        if (self._mode === "moz-chunked-arraybuffer") {
          xhr2.onprogress = function () {
            self._onXHRProgress()
          }
        }
        xhr2.onerror = function () {
          if (self._destroyed)
            return
          self.emit("error", new Error("XHR error"))
        }
        try {
          xhr2.send(body)
        } catch (err2) {
          process.nextTick(function () {
            self.emit("error", err2)
          })
          return
        }
      }
    }
    ClientRequest.prototype._onXHRProgress = function () {
      var self = this
      if (!statusValid(self._xhr) || self._destroyed)
        return
      if (!self._response)
        self._connect()
      self._response._onXHRProgress()
    }
    ClientRequest.prototype._connect = function () {
      var self = this
      if (self._destroyed)
        return
      self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
      self.emit("response", self._response)
    }
    ClientRequest.prototype._write = function (chunk, encoding, cb) {
      var self = this
      self._body.push(chunk)
      cb()
    }
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
      var self = this
      self._destroyed = true
      if (self._response)
        self._response._destroyed = true
      if (self._xhr)
        self._xhr.abort()
    }
    ClientRequest.prototype.end = function (data, encoding, cb) {
      var self = this
      if (typeof data === "function") {
        cb = data
        data = void 0
      }
      Writable.prototype.end.call(self, data, encoding, cb)
    }
    ClientRequest.prototype.flushHeaders = function () {
    }
    ClientRequest.prototype.setTimeout = function () {
    }
    ClientRequest.prototype.setNoDelay = function () {
    }
    ClientRequest.prototype.setSocketKeepAlive = function () {
    }
  }
})

// node-modules-polyfills:punycode
var punycode_exports = {}
__export(punycode_exports, {
  decode: () => decode,
  default: () => punycode_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2: () => ucs2,
  version: () => version4
})
function error(type2) {
  throw new RangeError(errors[type2])
}
function map(array, fn) {
  var length = array.length
  var result = []
  while (length--) {
    result[length] = fn(array[length])
  }
  return result
}
function mapDomain(string, fn) {
  var parts = string.split("@")
  var result = ""
  if (parts.length > 1) {
    result = parts[0] + "@"
    string = parts[1]
  }
  string = string.replace(regexSeparators, ".")
  var labels = string.split(".")
  var encoded = map(labels, fn).join(".")
  return result + encoded
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra
  while (counter < length) {
    value = string.charCodeAt(counter++)
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++)
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536)
      } else {
        output.push(value)
        counter--
      }
    } else {
      output.push(value)
    }
  }
  return output
}
function ucs2encode(array) {
  return map(array, function (value) {
    var output = ""
    if (value > 65535) {
      value -= 65536
      output += stringFromCharCode(value >>> 10 & 1023 | 55296)
      value = 56320 | value & 1023
    }
    output += stringFromCharCode(value)
    return output
  }).join("")
}
function basicToDigit(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97
  }
  return base
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
}
function adapt(delta, numPoints, firstTime) {
  var k = 0
  delta = firstTime ? floor(delta / damp) : delta >> 1
  delta += floor(delta / numPoints)
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin)
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew))
}
function decode(input) {
  var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT
  basic = input.lastIndexOf(delimiter2)
  if (basic < 0) {
    basic = 0
  }
  for (j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic")
    }
    output.push(input.charCodeAt(j))
  }
  for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
    for (oldi = i, w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input")
      }
      digit = basicToDigit(input.charCodeAt(index++))
      if (digit >= base || digit > floor((maxInt - i) / w)) {
        error("overflow")
      }
      i += digit * w
      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
      if (digit < t) {
        break
      }
      baseMinusT = base - t
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow")
      }
      w *= baseMinusT
    }
    out = output.length + 1
    bias = adapt(i - oldi, out, oldi == 0)
    if (floor(i / out) > maxInt - n) {
      error("overflow")
    }
    n += floor(i / out)
    i %= out
    output.splice(i++, 0, n)
  }
  return ucs2encode(output)
}
function encode(input) {
  var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT
  input = ucs2decode(input)
  inputLength = input.length
  n = initialN
  delta = 0
  bias = initialBias
  for (j = 0; j < inputLength; ++j) {
    currentValue = input[j]
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue))
    }
  }
  handledCPCount = basicLength = output.length
  if (basicLength) {
    output.push(delimiter2)
  }
  while (handledCPCount < inputLength) {
    for (m = maxInt, j = 0; j < inputLength; ++j) {
      currentValue = input[j]
      if (currentValue >= n && currentValue < m) {
        m = currentValue
      }
    }
    handledCPCountPlusOne = handledCPCount + 1
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow")
    }
    delta += (m - n) * handledCPCountPlusOne
    n = m
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j]
      if (currentValue < n && ++delta > maxInt) {
        error("overflow")
      }
      if (currentValue == n) {
        for (q = delta, k = base; ; k += base) {
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
          if (q < t) {
            break
          }
          qMinusT = q - t
          baseMinusT = base - t
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          )
          q = floor(qMinusT / baseMinusT)
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)))
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength)
        delta = 0
        ++handledCPCount
      }
    }
    ++delta
    ++n
  }
  return output.join("")
}
function toUnicode(input) {
  return mapDomain(input, function (string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string
  })
}
function toASCII(input) {
  return mapDomain(input, function (string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string
  })
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter2, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, version4, ucs2, punycode_default
var init_punycode = __esm({
  "node-modules-polyfills:punycode"() {
    init_process()
    init_buffer()
    maxInt = 2147483647
    base = 36
    tMin = 1
    tMax = 26
    skew = 38
    damp = 700
    initialBias = 72
    initialN = 128
    delimiter2 = "-"
    regexPunycode = /^xn--/
    regexNonASCII = /[^\x20-\x7E]/
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }
    baseMinusTMin = base - tMin
    floor = Math.floor
    stringFromCharCode = String.fromCharCode
    version4 = "1.4.1"
    ucs2 = {
      decode: ucs2decode,
      encode: ucs2encode
    }
    punycode_default = {
      version: version4,
      ucs2,
      toASCII,
      toUnicode,
      encode,
      decode
    }
  }
})

// node-modules-polyfills:querystring
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop)
}
function stringifyPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v
    case "boolean":
      return v ? "true" : "false"
    case "number":
      return isFinite(v) ? v : ""
    default:
      return ""
  }
}
function stringify(obj, sep2, eq, name) {
  sep2 = sep2 || "&"
  eq = eq || "="
  if (obj === null) {
    obj = void 0
  }
  if (typeof obj === "object") {
    return map2(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq
      if (isArray3(obj[k])) {
        return map2(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v))
        }).join(sep2)
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
      }
    }).join(sep2)
  }
  if (!name)
    return ""
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj))
}
function map2(xs, f) {
  if (xs.map)
    return xs.map(f)
  var res = []
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i))
  }
  return res
}
function parse(qs, sep2, eq, options2) {
  sep2 = sep2 || "&"
  eq = eq || "="
  var obj = {}
  if (typeof qs !== "string" || qs.length === 0) {
    return obj
  }
  var regexp = /\+/g
  qs = qs.split(sep2)
  var maxKeys = 1e3
  if (options2 && typeof options2.maxKeys === "number") {
    maxKeys = options2.maxKeys
  }
  var len = qs.length
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys
  }
  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v
    if (idx >= 0) {
      kstr = x.substr(0, idx)
      vstr = x.substr(idx + 1)
    } else {
      kstr = x
      vstr = ""
    }
    k = decodeURIComponent(kstr)
    v = decodeURIComponent(vstr)
    if (!hasOwnProperty2(obj, k)) {
      obj[k] = v
    } else if (isArray3(obj[k])) {
      obj[k].push(v)
    } else {
      obj[k] = [obj[k], v]
    }
  }
  return obj
}
var isArray3, objectKeys
var init_querystring = __esm({
  "node-modules-polyfills:querystring"() {
    init_process()
    init_buffer()
    isArray3 = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === "[object Array]"
    }
    objectKeys = Object.keys || function (obj) {
      var res = []
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key)
      }
      return res
    }
  }
})

// node-modules-polyfills:url
var url_exports = {}
__export(url_exports, {
  Url: () => Url,
  default: () => url_default,
  format: () => urlFormat,
  parse: () => urlParse,
  resolve: () => urlResolve,
  resolveObject: () => urlResolveObject
})
function Url() {
  this.protocol = null
  this.slashes = null
  this.auth = null
  this.host = null
  this.port = null
  this.hostname = null
  this.hash = null
  this.search = null
  this.query = null
  this.pathname = null
  this.path = null
  this.href = null
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url)
    return url
  var u = new Url()
  u.parse(url, parseQueryString, slashesDenoteHost)
  return u
}
function parse2(self, url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url)
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g
  uSplit[0] = uSplit[0].replace(slashRegex, "/")
  url = uSplit.join(splitter)
  var rest = url
  rest = rest.trim()
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest)
    if (simplePath) {
      self.path = rest
      self.href = rest
      self.pathname = simplePath[1]
      if (simplePath[2]) {
        self.search = simplePath[2]
        if (parseQueryString) {
          self.query = parse(self.search.substr(1))
        } else {
          self.query = self.search.substr(1)
        }
      } else if (parseQueryString) {
        self.search = ""
        self.query = {}
      }
      return self
    }
  }
  var proto = protocolPattern.exec(rest)
  if (proto) {
    proto = proto[0]
    var lowerProto = proto.toLowerCase()
    self.protocol = lowerProto
    rest = rest.substr(proto.length)
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//"
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2)
      self.slashes = true
    }
  }
  var i, hec, l, p
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i])
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec
    }
    var auth, atSign
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@")
    } else {
      atSign = rest.lastIndexOf("@", hostEnd)
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign)
      rest = rest.slice(atSign + 1)
      self.auth = decodeURIComponent(auth)
    }
    hostEnd = -1
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i])
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec
    }
    if (hostEnd === -1)
      hostEnd = rest.length
    self.host = rest.slice(0, hostEnd)
    rest = rest.slice(hostEnd)
    parseHost(self)
    self.hostname = self.hostname || ""
    var ipv6Hostname = self.hostname[0] === "[" && self.hostname[self.hostname.length - 1] === "]"
    if (!ipv6Hostname) {
      var hostparts = self.hostname.split(/\./)
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i]
        if (!part)
          continue
        if (!part.match(hostnamePartPattern)) {
          var newpart = ""
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x"
            } else {
              newpart += part[j]
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i)
            var notHost = hostparts.slice(i + 1)
            var bit = part.match(hostnamePartStart)
            if (bit) {
              validParts.push(bit[1])
              notHost.unshift(bit[2])
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest
            }
            self.hostname = validParts.join(".")
            break
          }
        }
      }
    }
    if (self.hostname.length > hostnameMaxLen) {
      self.hostname = ""
    } else {
      self.hostname = self.hostname.toLowerCase()
    }
    if (!ipv6Hostname) {
      self.hostname = toASCII(self.hostname)
    }
    p = self.port ? ":" + self.port : ""
    var h = self.hostname || ""
    self.host = h + p
    self.href += self.host
    if (ipv6Hostname) {
      self.hostname = self.hostname.substr(1, self.hostname.length - 2)
      if (rest[0] !== "/") {
        rest = "/" + rest
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i]
      if (rest.indexOf(ae) === -1)
        continue
      var esc = encodeURIComponent(ae)
      if (esc === ae) {
        esc = escape(ae)
      }
      rest = rest.split(ae).join(esc)
    }
  }
  var hash2 = rest.indexOf("#")
  if (hash2 !== -1) {
    self.hash = rest.substr(hash2)
    rest = rest.slice(0, hash2)
  }
  var qm = rest.indexOf("?")
  if (qm !== -1) {
    self.search = rest.substr(qm)
    self.query = rest.substr(qm + 1)
    if (parseQueryString) {
      self.query = parse(self.query)
    }
    rest = rest.slice(0, qm)
  } else if (parseQueryString) {
    self.search = ""
    self.query = {}
  }
  if (rest)
    self.pathname = rest
  if (slashedProtocol[lowerProto] && self.hostname && !self.pathname) {
    self.pathname = "/"
  }
  if (self.pathname || self.search) {
    p = self.pathname || ""
    var s = self.search || ""
    self.path = p + s
  }
  self.href = format2(self)
  return self
}
function urlFormat(obj) {
  if (isString(obj))
    obj = parse2({}, obj)
  return format2(obj)
}
function format2(self) {
  var auth = self.auth || ""
  if (auth) {
    auth = encodeURIComponent(auth)
    auth = auth.replace(/%3A/i, ":")
    auth += "@"
  }
  var protocol2 = self.protocol || "", pathname = self.pathname || "", hash2 = self.hash || "", host = false, query = ""
  if (self.host) {
    host = auth + self.host
  } else if (self.hostname) {
    host = auth + (self.hostname.indexOf(":") === -1 ? self.hostname : "[" + this.hostname + "]")
    if (self.port) {
      host += ":" + self.port
    }
  }
  if (self.query && isObject(self.query) && Object.keys(self.query).length) {
    query = stringify(self.query)
  }
  var search = self.search || query && "?" + query || ""
  if (protocol2 && protocol2.substr(-1) !== ":")
    protocol2 += ":"
  if (self.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {
    host = "//" + (host || "")
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname
  } else if (!host) {
    host = ""
  }
  if (hash2 && hash2.charAt(0) !== "#")
    hash2 = "#" + hash2
  if (search && search.charAt(0) !== "?")
    search = "?" + search
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match)
  })
  search = search.replace("#", "%23")
  return protocol2 + host + pathname + search + hash2
}
function urlResolve(source, relative2) {
  return urlParse(source, false, true).resolve(relative2)
}
function urlResolveObject(source, relative2) {
  if (!source)
    return relative2
  return urlParse(source, false, true).resolveObject(relative2)
}
function parseHost(self) {
  var host = self.host
  var port = portPattern.exec(host)
  if (port) {
    port = port[0]
    if (port !== ":") {
      self.port = port.substr(1)
    }
    host = host.substr(0, host.length - port.length)
  }
  if (host)
    self.hostname = host
}
var url_default, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol
var init_url = __esm({
  "node-modules-polyfills:url"() {
    init_process()
    init_buffer()
    init_punycode()
    init_util()
    init_querystring()
    url_default = {
      parse: urlParse,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      Url
    }
    protocolPattern = /^([a-z0-9.+-]+:)/i
    portPattern = /:[0-9]*$/
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"]
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims)
    autoEscape = ["'"].concat(unwise)
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape)
    hostEndingChars = ["/", "?", "#"]
    hostnameMaxLen = 255
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    }
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    }
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    }
    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
      return parse2(this, url, parseQueryString, slashesDenoteHost)
    }
    Url.prototype.format = function () {
      return format2(this)
    }
    Url.prototype.resolve = function (relative2) {
      return this.resolveObject(urlParse(relative2, false, true)).format()
    }
    Url.prototype.resolveObject = function (relative2) {
      if (isString(relative2)) {
        var rel = new Url()
        rel.parse(relative2, false, true)
        relative2 = rel
      }
      var result = new Url()
      var tkeys = Object.keys(this)
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk]
        result[tkey] = this[tkey]
      }
      result.hash = relative2.hash
      if (relative2.href === "") {
        result.href = result.format()
        return result
      }
      if (relative2.slashes && !relative2.protocol) {
        var rkeys = Object.keys(relative2)
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk]
          if (rkey !== "protocol")
            result[rkey] = relative2[rkey]
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/"
        }
        result.href = result.format()
        return result
      }
      var relPath
      if (relative2.protocol && relative2.protocol !== result.protocol) {
        if (!slashedProtocol[relative2.protocol]) {
          var keys2 = Object.keys(relative2)
          for (var v = 0; v < keys2.length; v++) {
            var k = keys2[v]
            result[k] = relative2[k]
          }
          result.href = result.format()
          return result
        }
        result.protocol = relative2.protocol
        if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
          relPath = (relative2.pathname || "").split("/")
          while (relPath.length && !(relative2.host = relPath.shift()))
            ;
          if (!relative2.host)
            relative2.host = ""
          if (!relative2.hostname)
            relative2.hostname = ""
          if (relPath[0] !== "")
            relPath.unshift("")
          if (relPath.length < 2)
            relPath.unshift("")
          result.pathname = relPath.join("/")
        } else {
          result.pathname = relative2.pathname
        }
        result.search = relative2.search
        result.query = relative2.query
        result.host = relative2.host || ""
        result.auth = relative2.auth
        result.hostname = relative2.hostname || relative2.host
        result.port = relative2.port
        if (result.pathname || result.search) {
          var p = result.pathname || ""
          var s = result.search || ""
          result.path = p + s
        }
        result.slashes = result.slashes || relative2.slashes
        result.href = result.format()
        return result
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol]
      relPath = relative2.pathname && relative2.pathname.split("/") || []
      if (psychotic) {
        result.hostname = ""
        result.port = null
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host
          else
            srcPath.unshift(result.host)
        }
        result.host = ""
        if (relative2.protocol) {
          relative2.hostname = null
          relative2.port = null
          if (relative2.host) {
            if (relPath[0] === "")
              relPath[0] = relative2.host
            else
              relPath.unshift(relative2.host)
          }
          relative2.host = null
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "")
      }
      var authInHost
      if (isRelAbs) {
        result.host = relative2.host || relative2.host === "" ? relative2.host : result.host
        result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname
        result.search = relative2.search
        result.query = relative2.query
        srcPath = relPath
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = []
        srcPath.pop()
        srcPath = srcPath.concat(relPath)
        result.search = relative2.search
        result.query = relative2.query
      } else if (!isNullOrUndefined(relative2.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift()
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false
          if (authInHost) {
            result.auth = authInHost.shift()
            result.host = result.hostname = authInHost.shift()
          }
        }
        result.search = relative2.search
        result.query = relative2.query
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
        }
        result.href = result.format()
        return result
      }
      if (!srcPath.length) {
        result.pathname = null
        if (result.search) {
          result.path = "/" + result.search
        } else {
          result.path = null
        }
        result.href = result.format()
        return result
      }
      var last = srcPath.slice(-1)[0]
      var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last === "." || last === "..") || last === ""
      var up = 0
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i]
        if (last === ".") {
          srcPath.splice(i, 1)
        } else if (last === "..") {
          srcPath.splice(i, 1)
          up++
        } else if (up) {
          srcPath.splice(i, 1)
          up--
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..")
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("")
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("")
      }
      var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/"
      if (psychotic) {
        result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : ""
        authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false
        if (authInHost) {
          result.auth = authInHost.shift()
          result.host = result.hostname = authInHost.shift()
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length
      if (mustEndAbs && !isAbsolute2) {
        srcPath.unshift("")
      }
      if (!srcPath.length) {
        result.pathname = null
        result.path = null
      } else {
        result.pathname = srcPath.join("/")
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
      }
      result.auth = relative2.auth || result.auth
      result.slashes = result.slashes || relative2.slashes
      result.href = result.format()
      return result
    }
    Url.prototype.parseHost = function () {
      return parseHost(this)
    }
  }
})

// node-modules-polyfills:http
var http_exports = {}
__export(http_exports, {
  Agent: () => Agent,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  default: () => http_default,
  get: () => get,
  request: () => request
})
function request(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts)
  var defaultProtocol = _globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : ""
  var protocol2 = opts.protocol || defaultProtocol
  var host = opts.hostname || opts.host
  var port = opts.port
  var path = opts.path || "/"
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]"
  opts.url = (host ? protocol2 + "//" + host : "") + (port ? ":" + port : "") + path
  opts.method = (opts.method || "GET").toUpperCase()
  opts.headers = opts.headers || {}
  var req = new request_default(opts)
  if (cb)
    req.on("response", cb)
  return req
}
function get(opts, cb) {
  var req = request(opts, cb)
  req.end()
  return req
}
function Agent() {
}
var METHODS, STATUS_CODES, http_default
var init_http = __esm({
  "node-modules-polyfills:http"() {
    init_process()
    init_buffer()
    init_request()
    init_url()
    Agent.defaultMaxSockets = 4
    METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ]
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      // RFC 2518, obsoleted by RFC 4918
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      // RFC 4918
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      // RFC 2324
      422: "Unprocessable Entity",
      // RFC 4918
      423: "Locked",
      // RFC 4918
      424: "Failed Dependency",
      // RFC 4918
      425: "Unordered Collection",
      // RFC 4918
      426: "Upgrade Required",
      // RFC 2817
      428: "Precondition Required",
      // RFC 6585
      429: "Too Many Requests",
      // RFC 6585
      431: "Request Header Fields Too Large",
      // RFC 6585
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      // RFC 2295
      507: "Insufficient Storage",
      // RFC 4918
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      // RFC 2774
      511: "Network Authentication Required"
      // RFC 6585
    }
    http_default = {
      request,
      get,
      Agent,
      METHODS,
      STATUS_CODES
    }
  }
})

// node-modules-polyfills-commonjs:http
var require_http = __commonJS({
  "node-modules-polyfills-commonjs:http"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_http(), __toCommonJS(http_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills:https
var https_exports = {}
__export(https_exports, {
  Agent: () => Agent2,
  METHODS: () => METHODS2,
  STATUS_CODES: () => STATUS_CODES2,
  default: () => https_default,
  get: () => get2,
  request: () => request2
})
function request2(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts)
  var defaultProtocol = _globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : ""
  var protocol2 = opts.protocol || defaultProtocol
  var host = opts.hostname || opts.host
  var port = opts.port
  var path = opts.path || "/"
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]"
  opts.url = (host ? protocol2 + "//" + host : "") + (port ? ":" + port : "") + path
  opts.method = (opts.method || "GET").toUpperCase()
  opts.headers = opts.headers || {}
  var req = new request_default(opts)
  if (cb)
    req.on("response", cb)
  return req
}
function get2(opts, cb) {
  var req = request2(opts, cb)
  req.end()
  return req
}
function Agent2() {
}
var METHODS2, STATUS_CODES2, https_default
var init_https = __esm({
  "node-modules-polyfills:https"() {
    init_process()
    init_buffer()
    init_request()
    init_url()
    Agent2.defaultMaxSockets = 4
    METHODS2 = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ]
    STATUS_CODES2 = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      // RFC 2518, obsoleted by RFC 4918
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      // RFC 4918
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      // RFC 2324
      422: "Unprocessable Entity",
      // RFC 4918
      423: "Locked",
      // RFC 4918
      424: "Failed Dependency",
      // RFC 4918
      425: "Unordered Collection",
      // RFC 4918
      426: "Upgrade Required",
      // RFC 2817
      428: "Precondition Required",
      // RFC 6585
      429: "Too Many Requests",
      // RFC 6585
      431: "Request Header Fields Too Large",
      // RFC 6585
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      // RFC 2295
      507: "Insufficient Storage",
      // RFC 4918
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      // RFC 2774
      511: "Network Authentication Required"
      // RFC 6585
    }
    https_default = {
      request: request2,
      get: get2,
      Agent: Agent2,
      METHODS: METHODS2,
      STATUS_CODES: STATUS_CODES2
    }
  }
})

// node-modules-polyfills-commonjs:https
var require_https = __commonJS({
  "node-modules-polyfills-commonjs:https"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_https(), __toCommonJS(https_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills-commonjs:url
var require_url = __commonJS({
  "node-modules-polyfills-commonjs:url"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_url(), __toCommonJS(url_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_stream(), __toCommonJS(stream_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills:assert
var assert_exports = {}
__export(assert_exports, {
  AssertionError: () => AssertionError,
  assert: () => ok,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => assert_default,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  strictEqual: () => strictEqual,
  throws: () => throws
})
function compare5(a, b) {
  if (a === b) {
    return 0
  }
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames
  }
  return _functionsHaveNames = function () {
    return function foo() {
    }.name === "foo"
  }()
}
function pToString(obj) {
  return Object.prototype.toString.call(obj)
}
function isView(arrbuf) {
  if (isBuffer3(arrbuf)) {
    return false
  }
  if (typeof _globalThis.ArrayBuffer !== "function") {
    return false
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf)
  }
  if (!arrbuf) {
    return false
  }
  if (arrbuf instanceof DataView) {
    return true
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true
  }
  return false
}
function assert(value, message) {
  if (!value)
    fail(value, true, message, "==", ok)
}
function getName(func) {
  if (!isFunction2(func)) {
    return
  }
  if (functionsHaveNames()) {
    return func.name
  }
  var str = func.toString()
  var match = str.match(regex)
  return match && match[1]
}
function AssertionError(options2) {
  this.name = "AssertionError"
  this.actual = options2.actual
  this.expected = options2.expected
  this.operator = options2.operator
  if (options2.message) {
    this.message = options2.message
    this.generatedMessage = false
  } else {
    this.message = getMessage(this)
    this.generatedMessage = true
  }
  var stackStartFunction = options2.stackStartFunction || fail
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction)
  } else {
    var err2 = new Error()
    if (err2.stack) {
      var out = err2.stack
      var fn_name = getName(stackStartFunction)
      var idx = out.indexOf("\n" + fn_name)
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1)
        out = out.substring(next_line + 1)
      }
      this.stack = out
    }
  }
}
function truncate(s, n) {
  if (typeof s === "string") {
    return s.length < n ? s : s.slice(0, n)
  } else {
    return s
  }
}
function inspect3(something) {
  if (functionsHaveNames() || !isFunction2(something)) {
    return inspect(something)
  }
  var rawname = getName(something)
  var name = rawname ? ": " + rawname : ""
  return "[Function" + name + "]"
}
function getMessage(self) {
  return truncate(inspect3(self.actual), 128) + " " + self.operator + " " + truncate(inspect3(self.expected), 128)
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  })
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok)
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal)
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual)
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual)
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual)
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true
  } else if (isBuffer3(actual) && isBuffer3(expected)) {
    return compare5(actual, expected) === 0
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime()
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare5(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0
  } else if (isBuffer3(actual) !== isBuffer3(expected)) {
    return false
  } else {
    memos = memos || { actual: [], expected: [] }
    var actualIndex = memos.actual.indexOf(actual)
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true
      }
    }
    memos.actual.push(actual)
    memos.expected.push(expected)
    return objEquiv(actual, expected, strict, memos)
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]"
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false
  if (isPrimitive(a) || isPrimitive(b))
    return a === b
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false
  var aIsArgs = isArguments(a)
  var bIsArgs = isArguments(b)
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false
  if (aIsArgs) {
    a = pSlice.call(a)
    b = pSlice.call(b)
    return _deepEqual(a, b, strict)
  }
  var ka = objectKeys2(a)
  var kb = objectKeys2(b)
  var key, i
  if (ka.length !== kb.length)
    return false
  ka.sort()
  kb.sort()
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i]
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false
  }
  return true
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual)
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual)
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual)
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual)
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual)
  }
  try {
    if (actual instanceof expected) {
      return true
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false
  }
  return expected.call({}, actual) === true
}
function _tryBlock(block2) {
  var error2
  try {
    block2()
  } catch (e) {
    error2 = e
  }
  return error2
}
function _throws(shouldThrow, block2, expected, message) {
  var actual
  if (typeof block2 !== "function") {
    throw new TypeError('"block" argument must be a function')
  }
  if (typeof expected === "string") {
    message = expected
    expected = null
  }
  actual = _tryBlock(block2)
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".")
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message)
  }
  var userProvidedMessage = typeof message === "string"
  var isUnwantedException = !shouldThrow && isError(actual)
  var isUnexpectedException = !shouldThrow && actual && !expected
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message)
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual
  }
}
function throws(block2, error2, message) {
  _throws(true, block2, error2, message)
}
function doesNotThrow(block2, error2, message) {
  _throws(false, block2, error2, message)
}
function ifError(err2) {
  if (err2)
    throw err2
}
var hasOwn, objectKeys2, pSlice, _functionsHaveNames, assert_default, regex
var init_assert = __esm({
  "node-modules-polyfills:assert"() {
    init_process()
    init_buffer()
    init_buffer2()
    init_util()
    hasOwn = Object.prototype.hasOwnProperty
    objectKeys2 = Object.keys || function (obj) {
      var keys2 = []
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys2.push(key)
      }
      return keys2
    }
    pSlice = Array.prototype.slice
    assert_default = assert
    regex = /\s*function\s+([^\(\s]*)\s*/
    assert.AssertionError = AssertionError
    inherits_default(AssertionError, Error)
    assert.fail = fail
    assert.ok = ok
    assert.equal = equal
    assert.notEqual = notEqual
    assert.deepEqual = deepEqual
    assert.deepStrictEqual = deepStrictEqual
    assert.notDeepEqual = notDeepEqual
    assert.notDeepStrictEqual = notDeepStrictEqual
    assert.strictEqual = strictEqual
    assert.notStrictEqual = notStrictEqual
    assert.throws = throws
    assert.doesNotThrow = doesNotThrow
    assert.ifError = ifError
  }
})

// node-modules-polyfills-commonjs:assert
var require_assert = __commonJS({
  "node-modules-polyfills-commonjs:assert"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_assert(), __toCommonJS(assert_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    init_process()
    init_buffer()
    var s = 1e3
    var m = s * 60
    var h = m * 60
    var d = h * 24
    var w = d * 7
    var y = d * 365.25
    module2.exports = function (val, options2) {
      options2 = options2 || {}
      var type2 = typeof val
      if (type2 === "string" && val.length > 0) {
        return parse4(val)
      } else if (type2 === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val)
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      )
    }
    function parse4(str) {
      str = String(str)
      if (str.length > 100) {
        return
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      )
      if (!match) {
        return
      }
      var n = parseFloat(match[1])
      var type2 = (match[2] || "ms").toLowerCase()
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y
        case "weeks":
        case "week":
        case "w":
          return n * w
        case "days":
        case "day":
        case "d":
          return n * d
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n
        default:
          return void 0
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms)
      if (msAbs >= d) {
        return Math.round(ms / d) + "d"
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h"
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m"
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s"
      }
      return ms + "ms"
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms)
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day")
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour")
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute")
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second")
      }
      return ms + " ms"
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "")
    }
  }
})

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    init_process()
    init_buffer()
    function setup(env3) {
      createDebug.debug = createDebug
      createDebug.default = createDebug
      createDebug.coerce = coerce2
      createDebug.disable = disable
      createDebug.enable = enable
      createDebug.enabled = enabled
      createDebug.humanize = require_ms()
      createDebug.destroy = destroy
      Object.keys(env3).forEach((key) => {
        createDebug[key] = env3[key]
      })
      createDebug.names = []
      createDebug.skips = []
      createDebug.formatters = {}
      function selectColor(namespace) {
        let hash2 = 0
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i)
          hash2 |= 0
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length]
      }
      createDebug.selectColor = selectColor
      function createDebug(namespace) {
        let prevTime
        let enableOverride = null
        let namespacesCache
        let enabledCache
        function debug2(...args) {
          if (!debug2.enabled) {
            return
          }
          const self = debug2
          const curr = Number(/* @__PURE__ */ new Date())
          const ms = curr - (prevTime || curr)
          self.diff = ms
          self.prev = prevTime
          self.curr = curr
          prevTime = curr
          args[0] = createDebug.coerce(args[0])
          if (typeof args[0] !== "string") {
            args.unshift("%O")
          }
          let index = 0
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
            if (match === "%%") {
              return "%"
            }
            index++
            const formatter = createDebug.formatters[format3]
            if (typeof formatter === "function") {
              const val = args[index]
              match = formatter.call(self, val)
              args.splice(index, 1)
              index--
            }
            return match
          })
          createDebug.formatArgs.call(self, args)
          const logFn = self.log || createDebug.log
          logFn.apply(self, args)
        }
        debug2.namespace = namespace
        debug2.useColors = createDebug.useColors()
        debug2.color = createDebug.selectColor(namespace)
        debug2.extend = extend
        debug2.destroy = createDebug.destroy
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces
              enabledCache = createDebug.enabled(namespace)
            }
            return enabledCache
          },
          set: (v) => {
            enableOverride = v
          }
        })
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2)
        }
        return debug2
      }
      function extend(namespace, delimiter3) {
        const newDebug = createDebug(this.namespace + (typeof delimiter3 === "undefined" ? ":" : delimiter3) + namespace)
        newDebug.log = this.log
        return newDebug
      }
      function enable(namespaces) {
        createDebug.save(namespaces)
        createDebug.namespaces = namespaces
        createDebug.names = []
        createDebug.skips = []
        let i
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/)
        const len = split.length
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue
          }
          namespaces = split[i].replace(/\*/g, ".*?")
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"))
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"))
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",")
        createDebug.enable("")
        return namespaces
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true
        }
        let i
        let len
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true
          }
        }
        return false
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*")
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message
        }
        return val
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
      }
      createDebug.enable(createDebug.load())
      return createDebug
    }
    module2.exports = setup
  }
})

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    init_process()
    init_buffer()
    exports.formatArgs = formatArgs
    exports.save = save
    exports.load = load
    exports.useColors = useColors
    exports.storage = localstorage()
    exports.destroy = (() => {
      let warned = false
      return () => {
        if (!warned) {
          warned = true
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
      }
    })()
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ]
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff)
      if (!this.useColors) {
        return
      }
      const c = "color: " + this.color
      args.splice(1, 0, c, "color: inherit")
      let index = 0
      let lastC = 0
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return
        }
        index++
        if (match === "%c") {
          lastC = index
        }
      })
      args.splice(lastC, 0, c)
    }
    exports.log = console.debug || console.log || (() => {
    })
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces)
        } else {
          exports.storage.removeItem("debug")
        }
      } catch (error2) {
      }
    }
    function load() {
      let r
      try {
        r = exports.storage.getItem("debug")
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG
      }
      return r
    }
    function localstorage() {
      try {
        return localStorage
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports)
    var { formatters } = module2.exports
    formatters.j = function (v) {
      try {
        return JSON.stringify(v)
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message
      }
    }
  }
})

// node-modules-polyfills:tty
var tty_exports = {}
__export(tty_exports, {
  ReadStream: () => ReadStream,
  WriteStream: () => WriteStream,
  default: () => tty_default,
  isatty: () => isatty
})
function isatty() {
  return false
}
function ReadStream() {
  throw new Error("tty.ReadStream is not implemented")
}
function WriteStream() {
  throw new Error("tty.ReadStream is not implemented")
}
var tty_default
var init_tty = __esm({
  "node-modules-polyfills:tty"() {
    init_process()
    init_buffer()
    tty_default = {
      isatty,
      ReadStream,
      WriteStream
    }
  }
})

// node-modules-polyfills-commonjs:tty
var require_tty = __commonJS({
  "node-modules-polyfills-commonjs:tty"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_tty(), __toCommonJS(tty_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills-commonjs:util
var require_util = __commonJS({
  "node-modules-polyfills-commonjs:util"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_util(), __toCommonJS(util_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node-modules-polyfills:os
var os_exports = {}
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch,
  cpus: () => cpus,
  default: () => os_default,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform3,
  release: () => release3,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime3
})
function endianness() {
  if (typeof _endianness === "undefined") {
    var a = new ArrayBuffer(2)
    var b = new Uint8Array(a)
    var c = new Uint16Array(a)
    b[0] = 1
    b[1] = 2
    if (c[0] === 258) {
      _endianness = "BE"
    } else if (c[0] === 513) {
      _endianness = "LE"
    } else {
      throw new Error("unable to figure out endianess")
    }
  }
  return _endianness
}
function hostname() {
  if (typeof _globalThis.location !== "undefined") {
    return _globalThis.location.hostname
  } else
    return ""
}
function loadavg() {
  return []
}
function uptime3() {
  return 0
}
function freemem() {
  return Number.MAX_VALUE
}
function totalmem() {
  return Number.MAX_VALUE
}
function cpus() {
  return []
}
function type() {
  return "Browser"
}
function release3() {
  if (typeof _globalThis.navigator !== "undefined") {
    return _globalThis.navigator.appVersion
  }
  return ""
}
function networkInterfaces() {
}
function getNetworkInterfaces() {
}
function arch() {
  return "javascript"
}
function platform3() {
  return "browser"
}
function tmpDir() {
  return "/tmp"
}
var _endianness, tmpdir, EOL, os_default
var init_os = __esm({
  "node-modules-polyfills:os"() {
    init_process()
    init_buffer()
    tmpdir = tmpDir
    EOL = "\n"
    os_default = {
      EOL,
      tmpdir,
      tmpDir,
      networkInterfaces,
      getNetworkInterfaces,
      release: release3,
      type,
      cpus,
      totalmem,
      freemem,
      uptime: uptime3,
      loadavg,
      hostname,
      endianness
    }
  }
})

// node-modules-polyfills-commonjs:os
var require_os = __commonJS({
  "node-modules-polyfills-commonjs:os"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_os(), __toCommonJS(os_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = (flag, argv3 = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--"
      const position = argv3.indexOf(prefix + flag)
      const terminatorPosition = argv3.indexOf("--")
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition)
    }
  }
})

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var os = require_os()
    var tty = require_tty()
    var hasFlag = require_has_flag()
    var { env: env3 } = process
    var flagForceColor
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env3) {
        if (env3.FORCE_COLOR === "true") {
          return 1
        }
        if (env3.FORCE_COLOR === "false") {
          return 0
        }
        return env3.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env3.FORCE_COLOR, 10), 3)
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      }
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor()
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor
      if (forceColor === 0) {
        return 0
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3
        }
        if (hasFlag("color=256")) {
          return 2
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0
      }
      const min = forceColor || 0
      if (env3.TERM === "dumb") {
        return min
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".")
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2
        }
        return 1
      }
      if ("CI" in env3) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env3) || env3.CI_NAME === "codeship") {
          return 1
        }
        return min
      }
      if ("TEAMCITY_VERSION" in env3) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0
      }
      if (env3.COLORTERM === "truecolor") {
        return 3
      }
      if ("TERM_PROGRAM" in env3) {
        const version5 = Number.parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10)
        switch (env3.TERM_PROGRAM) {
          case "iTerm.app":
            return version5 >= 3 ? 3 : 2
          case "Apple_Terminal":
            return 2
        }
      }
      if (/-256(color)?$/i.test(env3.TERM)) {
        return 2
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
        return 1
      }
      if ("COLORTERM" in env3) {
        return 1
      }
      return min
    }
    function getSupportLevel(stream, options2 = {}) {
      const level = supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options2
      })
      return translateLevel(level)
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    }
  }
})

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    init_process()
    init_buffer()
    var tty = require_tty()
    var util2 = require_util()
    exports.init = init3
    exports.log = log2
    exports.formatArgs = formatArgs
    exports.save = save
    exports.load = load
    exports.useColors = useColors
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    )
    exports.colors = [6, 2, 3, 4, 5, 1]
    try {
      const supportsColor = require_supports_color()
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ]
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key)
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase()
      })
      let val = process.env[key]
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false
      } else if (val === "null") {
        val = null
      } else {
        val = Number(val)
      }
      obj[prop] = val
      return obj
    }, {})
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd)
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this
      if (useColors2) {
        const c = this.color
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c)
        const prefix = `  ${colorCode};1m${name} \x1B[0m`
        args[0] = prefix + args[0].split("\n").join("\n" + prefix)
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m")
      } else {
        args[0] = getDate() + name + " " + args[0]
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return ""
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " "
    }
    function log2(...args) {
      return process.stderr.write(util2.format(...args) + "\n")
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces
      } else {
        delete process.env.DEBUG
      }
    }
    function load() {
      return process.env.DEBUG
    }
    function init3(debug2) {
      debug2.inspectOpts = {}
      const keys2 = Object.keys(exports.inspectOpts)
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]]
      }
    }
    module2.exports = require_common()(exports)
    var { formatters } = module2.exports
    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ")
    }
    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors
      return util2.inspect(v, this.inspectOpts)
    }
  }
})

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    init_process()
    init_buffer()
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser()
    } else {
      module2.exports = require_node()
    }
  }
})

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    init_process()
    init_buffer()
    var debug2
    module2.exports = function () {
      if (!debug2) {
        try {
          debug2 = require_src()("follow-redirects")
        } catch (error2) {
        }
        if (typeof debug2 !== "function") {
          debug2 = function () {
          }
        }
      }
      debug2.apply(null, arguments)
    }
  }
})

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    init_process()
    init_buffer()
    var url = require_url()
    var URL2 = url.URL
    var http = require_http()
    var https = require_https()
    var Writable2 = require_stream().Writable
    var assert3 = require_assert()
    var debug2 = require_debug()
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"]
    var eventHandlers = /* @__PURE__ */ Object.create(null)
    events.forEach(function (event) {
      eventHandlers[event] = function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3)
      }
    })
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    )
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    )
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    )
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    )
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    )
    function RedirectableRequest(options2, responseCallback) {
      Writable2.call(this)
      this._sanitizeOptions(options2)
      this._options = options2
      this._ended = false
      this._ending = false
      this._redirectCount = 0
      this._redirects = []
      this._requestBodyLength = 0
      this._requestBodyBuffers = []
      if (responseCallback) {
        this.on("response", responseCallback)
      }
      var self = this
      this._onNativeResponse = function (response) {
        self._processResponse(response)
      }
      this._performRequest()
    }
    RedirectableRequest.prototype = Object.create(Writable2.prototype)
    RedirectableRequest.prototype.abort = function () {
      abortRequest(this._currentRequest)
      this.emit("abort")
    }
    RedirectableRequest.prototype.write = function (data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError()
      }
      if (!isString2(data) && !isBuffer4(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array")
      }
      if (isFunction3(encoding)) {
        callback = encoding
        encoding = null
      }
      if (data.length === 0) {
        if (callback) {
          callback()
        }
        return
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length
        this._requestBodyBuffers.push({ data, encoding })
        this._currentRequest.write(data, encoding, callback)
      } else {
        this.emit("error", new MaxBodyLengthExceededError())
        this.abort()
      }
    }
    RedirectableRequest.prototype.end = function (data, encoding, callback) {
      if (isFunction3(data)) {
        callback = data
        data = encoding = null
      } else if (isFunction3(encoding)) {
        callback = encoding
        encoding = null
      }
      if (!data) {
        this._ended = this._ending = true
        this._currentRequest.end(null, null, callback)
      } else {
        var self = this
        var currentRequest = this._currentRequest
        this.write(data, encoding, function () {
          self._ended = true
          currentRequest.end(null, null, callback)
        })
        this._ending = true
      }
    }
    RedirectableRequest.prototype.setHeader = function (name, value) {
      this._options.headers[name] = value
      this._currentRequest.setHeader(name, value)
    }
    RedirectableRequest.prototype.removeHeader = function (name) {
      delete this._options.headers[name]
      this._currentRequest.removeHeader(name)
    }
    RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
      var self = this
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs)
        socket.removeListener("timeout", socket.destroy)
        socket.addListener("timeout", socket.destroy)
      }
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout)
        }
        self._timeout = setTimeout(function () {
          self.emit("timeout")
          clearTimer()
        }, msecs)
        destroyOnTimeout(socket)
      }
      function clearTimer() {
        if (self._timeout) {
          clearTimeout(self._timeout)
          self._timeout = null
        }
        self.removeListener("abort", clearTimer)
        self.removeListener("error", clearTimer)
        self.removeListener("response", clearTimer)
        if (callback) {
          self.removeListener("timeout", callback)
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer)
        }
      }
      if (callback) {
        this.on("timeout", callback)
      }
      if (this.socket) {
        startTimer(this.socket)
      } else {
        this._currentRequest.once("socket", startTimer)
      }
      this.on("socket", destroyOnTimeout)
      this.on("abort", clearTimer)
      this.on("error", clearTimer)
      this.on("response", clearTimer)
      return this
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function (method) {
      RedirectableRequest.prototype[method] = function (a, b) {
        return this._currentRequest[method](a, b)
      }
    });
    ["aborted", "connection", "socket"].forEach(function (property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function () {
          return this._currentRequest[property]
        }
      })
    })
    RedirectableRequest.prototype._sanitizeOptions = function (options2) {
      if (!options2.headers) {
        options2.headers = {}
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host
        }
        delete options2.host
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?")
        if (searchPos < 0) {
          options2.pathname = options2.path
        } else {
          options2.pathname = options2.path.substring(0, searchPos)
          options2.search = options2.path.substring(searchPos)
        }
      }
    }
    RedirectableRequest.prototype._performRequest = function () {
      var protocol2 = this._options.protocol
      var nativeProtocol = this._options.nativeProtocols[protocol2]
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol2))
        return
      }
      if (this._options.agents) {
        var scheme = protocol2.slice(0, -1)
        this._options.agent = this._options.agents[scheme]
      }
      var request3 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse)
      request3._redirectable = this
      for (var event of events) {
        request3.on(event, eventHandlers[event])
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      )
      if (this._isRedirect) {
        var i = 0
        var self = this
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request3 === self._currentRequest) {
            if (error2) {
              self.emit("error", error2)
            } else if (i < buffers.length) {
              var buffer = buffers[i++]
              if (!request3.finished) {
                request3.write(buffer.data, buffer.encoding, writeNext)
              }
            } else if (self._ended) {
              request3.end()
            }
          }
        })()
      }
    }
    RedirectableRequest.prototype._processResponse = function (response) {
      var statusCode = response.statusCode
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        })
      }
      var location = response.headers.location
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl
        response.redirects = this._redirects
        this.emit("response", response)
        this._requestBodyBuffers = []
        return
      }
      abortRequest(this._currentRequest)
      response.destroy()
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError())
        return
      }
      var requestHeaders
      var beforeRedirect = this._options.beforeRedirect
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers)
      }
      var method = this._options.method
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource []
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) []
        statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET"
        this._requestBodyBuffers = []
        removeMatchingHeaders(/^content-/i, this._options.headers)
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers)
      var currentUrlParts = url.parse(this._currentUrl)
      var currentHost = currentHostHeader || currentUrlParts.host
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }))
      var redirectUrl
      try {
        redirectUrl = url.resolve(currentUrl, location)
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }))
        return
      }
      debug2("redirecting to", redirectUrl)
      this._isRedirect = true
      var redirectUrlParts = url.parse(redirectUrl)
      Object.assign(this._options, redirectUrlParts)
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers)
      }
      if (isFunction3(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        }
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        }
        try {
          beforeRedirect(this._options, responseDetails, requestDetails)
        } catch (err2) {
          this.emit("error", err2)
          return
        }
        this._sanitizeOptions(this._options)
      }
      try {
        this._performRequest()
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }))
      }
    }
    function wrap2(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      }
      var nativeProtocols = {}
      Object.keys(protocols).forEach(function (scheme) {
        var protocol2 = scheme + ":"
        var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme]
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol)
        function request3(input, options2, callback) {
          if (isString2(input)) {
            var parsed
            try {
              parsed = urlToOptions(new URL2(input))
            } catch (err2) {
              parsed = url.parse(input)
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input })
            }
            input = parsed
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input)
          } else {
            callback = options2
            options2 = input
            input = { protocol: protocol2 }
          }
          if (isFunction3(options2)) {
            callback = options2
            options2 = null
          }
          options2 = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options2)
          options2.nativeProtocols = nativeProtocols
          if (!isString2(options2.host) && !isString2(options2.hostname)) {
            options2.hostname = "::1"
          }
          assert3.equal(options2.protocol, protocol2, "protocol mismatch")
          debug2("options", options2)
          return new RedirectableRequest(options2, callback)
        }
        function get3(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback)
          wrappedRequest.end()
          return wrappedRequest
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request3, configurable: true, enumerable: true, writable: true },
          get: { value: get3, configurable: true, enumerable: true, writable: true }
        })
      })
      return exports2
    }
    function noop3() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      }
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port)
      }
      return options2
    }
    function removeMatchingHeaders(regex2, headers) {
      var lastValue
      for (var header in headers) {
        if (regex2.test(header)) {
          lastValue = headers[header]
          delete headers[header]
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim()
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor)
        Object.assign(this, properties || {})
        this.code = code
        this.message = this.cause ? message + ": " + this.cause.message : message
      }
      CustomError.prototype = new (baseClass || Error)()
      CustomError.prototype.constructor = CustomError
      CustomError.prototype.name = "Error [" + code + "]"
      return CustomError
    }
    function abortRequest(request3) {
      for (var event of events) {
        request3.removeListener(event, eventHandlers[event])
      }
      request3.on("error", noop3)
      request3.abort()
    }
    function isSubdomain(subdomain, domain3) {
      assert3(isString2(subdomain) && isString2(domain3))
      var dot = subdomain.length - domain3.length - 1
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain3)
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String
    }
    function isFunction3(value) {
      return typeof value === "function"
    }
    function isBuffer4(value) {
      return typeof value === "object" && "length" in value
    }
    module2.exports = wrap2({ http, https })
    module2.exports.wrap = wrap2
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/messages.js
var messages_default
var init_messages = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/messages.js"() {
    init_process()
    init_buffer()
    messages_default = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    }
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/zstream.js
function ZStream() {
  this.input = null
  this.next_in = 0
  this.avail_in = 0
  this.total_in = 0
  this.output = null
  this.next_out = 0
  this.avail_out = 0
  this.total_out = 0
  this.msg = ""
  this.state = null
  this.data_type = 2
  this.adler = 0
}
var zstream_default
var init_zstream = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/zstream.js"() {
    init_process()
    init_buffer()
    zstream_default = ZStream
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/utils.js
function arraySet(dest, src, src_offs, len, dest_offs) {
  if (src.subarray && dest.subarray) {
    dest.set(src.subarray(src_offs, src_offs + len), dest_offs)
    return
  }
  for (var i = 0; i < len; i++) {
    dest[dest_offs + i] = src[src_offs + i]
  }
}
var Buf8, Buf16, Buf32
var init_utils = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/utils.js"() {
    "use strict"
    init_process()
    init_buffer()
    Buf8 = Uint8Array
    Buf16 = Uint16Array
    Buf32 = Int32Array
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/trees.js
function zero(buf) {
  var len = buf.length
  while (--len >= 0) {
    buf[len] = 0
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree
  this.extra_bits = extra_bits
  this.extra_base = extra_base
  this.elems = elems
  this.max_length = max_length
  this.has_stree = static_tree && static_tree.length
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree
  this.max_code = 0
  this.stat_desc = stat_desc
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255
  s.pending_buf[s.pending++] = w >>> 8 & 255
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535
    put_short(s, s.bi_buf)
    s.bi_buf = value >> Buf_size - s.bi_valid
    s.bi_valid += length - Buf_size
  } else {
    s.bi_buf |= value << s.bi_valid & 65535
    s.bi_valid += length
  }
}
function send_code(s, c, tree) {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  )
}
function bi_reverse(code, len) {
  var res = 0
  do {
    res |= code & 1
    code >>>= 1
    res <<= 1
  } while (--len > 0)
  return res >>> 1
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf)
    s.bi_buf = 0
    s.bi_valid = 0
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255
    s.bi_buf >>= 8
    s.bi_valid -= 8
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree
  var max_code = desc.max_code
  var stree = desc.stat_desc.static_tree
  var has_stree = desc.stat_desc.has_stree
  var extra = desc.stat_desc.extra_bits
  var base2 = desc.stat_desc.extra_base
  var max_length = desc.stat_desc.max_length
  var h
  var n, m
  var bits
  var xbits
  var f
  var overflow = 0
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h]
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1
    if (bits > max_length) {
      bits = max_length
      overflow++
    }
    tree[n * 2 + 1] = bits
    if (n > max_code) {
      continue
    }
    s.bl_count[bits]++
    xbits = 0
    if (n >= base2) {
      xbits = extra[n - base2]
    }
    f = tree[n * 2]
    s.opt_len += f * (bits + xbits)
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits)
    }
  }
  if (overflow === 0) {
    return
  }
  do {
    bits = max_length - 1
    while (s.bl_count[bits] === 0) {
      bits--
    }
    s.bl_count[bits]--
    s.bl_count[bits + 1] += 2
    s.bl_count[max_length]--
    overflow -= 2
  } while (overflow > 0)
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits]
    while (n !== 0) {
      m = s.heap[--h]
      if (m > max_code) {
        continue
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2]
        tree[m * 2 + 1] = bits
      }
      n--
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS + 1)
  var code = 0
  var bits
  var n
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    if (len === 0) {
      continue
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len)
  }
}
function tr_static_init() {
  var n
  var bits
  var length
  var code
  var dist
  var bl_count = new Array(MAX_BITS + 1)
  length = 0
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code
    }
  }
  _length_code[length - 1] = code
  dist = 0
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code
    }
  }
  dist >>= 7
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0
  }
  n = 0
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8
    n++
    bl_count[8]++
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9
    n++
    bl_count[9]++
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7
    n++
    bl_count[7]++
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8
    n++
    bl_count[8]++
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count)
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5
    static_dtree[n * 2] = bi_reverse(n, 5)
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS)
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
}
function init_block(s) {
  var n
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0
  }
  s.dyn_ltree[END_BLOCK * 2] = 1
  s.opt_len = s.static_len = 0
  s.last_lit = s.matches = 0
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf)
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf
  }
  s.bi_buf = 0
  s.bi_valid = 0
}
function copy_block(s, buf, len, header) {
  bi_windup(s)
  if (header) {
    put_short(s, len)
    put_short(s, ~len)
  }
  arraySet(s.pending_buf, s.window, buf, len, s.pending)
  s.pending += len
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2
  var _m2 = m * 2
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k]
  var j = k << 1
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break
    }
    s.heap[k] = s.heap[j]
    k = j
    j <<= 1
  }
  s.heap[k] = v
}
function compress_block(s, ltree, dtree) {
  var dist
  var lc
  var lx = 0
  var code
  var extra
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1]
      lc = s.pending_buf[s.l_buf + lx]
      lx++
      if (dist === 0) {
        send_code(s, lc, ltree)
      } else {
        code = _length_code[lc]
        send_code(s, code + LITERALS + 1, ltree)
        extra = extra_lbits[code]
        if (extra !== 0) {
          lc -= base_length[code]
          send_bits(s, lc, extra)
        }
        dist--
        code = d_code(dist)
        send_code(s, code, dtree)
        extra = extra_dbits[code]
        if (extra !== 0) {
          dist -= base_dist[code]
          send_bits(s, dist, extra)
        }
      }
    } while (lx < s.last_lit)
  }
  send_code(s, END_BLOCK, ltree)
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree
  var stree = desc.stat_desc.static_tree
  var has_stree = desc.stat_desc.has_stree
  var elems = desc.stat_desc.elems
  var n, m
  var max_code = -1
  var node
  s.heap_len = 0
  s.heap_max = HEAP_SIZE
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n
      s.depth[n] = 0
    } else {
      tree[n * 2 + 1] = 0
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0
    tree[node * 2] = 1
    s.depth[node] = 0
    s.opt_len--
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
    }
  }
  desc.max_code = max_code
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n)
  }
  node = elems
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ]
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--]
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    )
    m = s.heap[
      1
      /*SMALLEST*/
    ]
    s.heap[--s.heap_max] = n
    s.heap[--s.heap_max] = m
    tree[node * 2] = tree[n * 2] + tree[m * 2]
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1
    tree[n * 2 + 1] = tree[m * 2 + 1] = node
    s.heap[
      1
      /*SMALLEST*/
    ] = node++
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    )
  } while (s.heap_len >= 2)
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ]
  gen_bitlen(s, desc)
  gen_codes(tree, max_code, s.bl_count)
}
function scan_tree(s, tree, max_code) {
  var n
  var prevlen = -1
  var curlen
  var nextlen = tree[0 * 2 + 1]
  var count = 0
  var max_count = 7
  var min_count = 4
  if (nextlen === 0) {
    max_count = 138
    min_count = 3
  }
  tree[(max_code + 1) * 2 + 1] = 65535
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen
    nextlen = tree[(n + 1) * 2 + 1]
    if (++count < max_count && curlen === nextlen) {
      continue
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++
      }
      s.bl_tree[REP_3_6 * 2]++
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++
    } else {
      s.bl_tree[REPZ_11_138 * 2]++
    }
    count = 0
    prevlen = curlen
    if (nextlen === 0) {
      max_count = 138
      min_count = 3
    } else if (curlen === nextlen) {
      max_count = 6
      min_count = 3
    } else {
      max_count = 7
      min_count = 4
    }
  }
}
function send_tree(s, tree, max_code) {
  var n
  var prevlen = -1
  var curlen
  var nextlen = tree[0 * 2 + 1]
  var count = 0
  var max_count = 7
  var min_count = 4
  if (nextlen === 0) {
    max_count = 138
    min_count = 3
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen
    nextlen = tree[(n + 1) * 2 + 1]
    if (++count < max_count && curlen === nextlen) {
      continue
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree)
      } while (--count !== 0)
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree)
        count--
      }
      send_code(s, REP_3_6, s.bl_tree)
      send_bits(s, count - 3, 2)
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree)
      send_bits(s, count - 3, 3)
    } else {
      send_code(s, REPZ_11_138, s.bl_tree)
      send_bits(s, count - 11, 7)
    }
    count = 0
    prevlen = curlen
    if (nextlen === 0) {
      max_count = 138
      min_count = 3
    } else if (curlen === nextlen) {
      max_count = 6
      min_count = 3
    } else {
      max_count = 7
      min_count = 4
    }
  }
}
function build_bl_tree(s) {
  var max_blindex
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code)
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code)
  build_tree(s, s.bl_desc)
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4
  return max_blindex
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2
  send_bits(s, lcodes - 257, 5)
  send_bits(s, dcodes - 1, 5)
  send_bits(s, blcodes - 4, 4)
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3)
  }
  send_tree(s, s.dyn_ltree, lcodes - 1)
  send_tree(s, s.dyn_dtree, dcodes - 1)
}
function detect_data_type(s) {
  var black_mask = 4093624447
  var n
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT
    }
  }
  return Z_BINARY
}
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init()
    static_init_done = true
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)
  s.bi_buf = 0
  s.bi_valid = 0
  init_block(s)
}
function _tr_stored_block(s, buf, stored_len, last) {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3)
  copy_block(s, buf, stored_len, true)
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3)
  send_code(s, END_BLOCK, static_ltree)
  bi_flush(s)
}
function _tr_flush_block(s, buf, stored_len, last) {
  var opt_lenb, static_lenb
  var max_blindex = 0
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s)
    }
    build_tree(s, s.l_desc)
    build_tree(s, s.d_desc)
    max_blindex = build_bl_tree(s)
    opt_lenb = s.opt_len + 3 + 7 >>> 3
    static_lenb = s.static_len + 3 + 7 >>> 3
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last)
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)
    compress_block(s, static_ltree, static_dtree)
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1)
    compress_block(s, s.dyn_ltree, s.dyn_dtree)
  }
  init_block(s)
  if (last) {
    bi_windup(s)
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255
  s.last_lit++
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++
  } else {
    s.matches++
    dist--
    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++
    s.dyn_dtree[d_code(dist) * 2]++
  }
  return s.last_lit === s.lit_bufsize - 1
}
var Z_FIXED, Z_BINARY, Z_TEXT, Z_UNKNOWN, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH, MAX_MATCH, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, static_init_done
var init_trees = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/trees.js"() {
    "use strict"
    init_process()
    init_buffer()
    init_utils()
    Z_FIXED = 4
    Z_BINARY = 0
    Z_TEXT = 1
    Z_UNKNOWN = 2
    STORED_BLOCK = 0
    STATIC_TREES = 1
    DYN_TREES = 2
    MIN_MATCH = 3
    MAX_MATCH = 258
    LENGTH_CODES = 29
    LITERALS = 256
    L_CODES = LITERALS + 1 + LENGTH_CODES
    D_CODES = 30
    BL_CODES = 19
    HEAP_SIZE = 2 * L_CODES + 1
    MAX_BITS = 15
    Buf_size = 16
    MAX_BL_BITS = 7
    END_BLOCK = 256
    REP_3_6 = 16
    REPZ_3_10 = 17
    REPZ_11_138 = 18
    extra_lbits = /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    extra_dbits = /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    extra_blbits = /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    DIST_CODE_LEN = 512
    static_ltree = new Array((L_CODES + 2) * 2)
    zero(static_ltree)
    static_dtree = new Array(D_CODES * 2)
    zero(static_dtree)
    _dist_code = new Array(DIST_CODE_LEN)
    zero(_dist_code)
    _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)
    zero(_length_code)
    base_length = new Array(LENGTH_CODES)
    zero(base_length)
    base_dist = new Array(D_CODES)
    zero(base_dist)
    static_init_done = false
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/adler32.js
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len
    len -= n
    do {
      s1 = s1 + buf[pos++] | 0
      s2 = s2 + s1 | 0
    } while (--n)
    s1 %= 65521
    s2 %= 65521
  }
  return s1 | s2 << 16 | 0
}
var adler32_default
var init_adler32 = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/adler32.js"() {
    init_process()
    init_buffer()
    adler32_default = adler32
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/crc32.js
function makeTable() {
  var c, table = []
  for (var n = 0; n < 256; n++) {
    c = n
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1
    }
    table[n] = c
  }
  return table
}
function crc32(crc, buf, len, pos) {
  var t = crcTable, end = pos + len
  crc ^= -1
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255]
  }
  return crc ^ -1
}
var crcTable, crc32_default
var init_crc32 = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/crc32.js"() {
    init_process()
    init_buffer()
    crcTable = makeTable()
    crc32_default = crc32
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/deflate.js
function err(strm, errorCode) {
  strm.msg = messages_default[errorCode]
  return errorCode
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0)
}
function zero2(buf) {
  var len = buf.length
  while (--len >= 0) {
    buf[len] = 0
  }
}
function flush_pending(strm) {
  var s = strm.state
  var len = s.pending
  if (len > strm.avail_out) {
    len = strm.avail_out
  }
  if (len === 0) {
    return
  }
  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out)
  strm.next_out += len
  s.pending_out += len
  strm.total_out += len
  strm.avail_out -= len
  s.pending -= len
  if (s.pending === 0) {
    s.pending_out = 0
  }
}
function flush_block_only(s, last) {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last)
  s.block_start = s.strstart
  flush_pending(s.strm)
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255
  s.pending_buf[s.pending++] = b & 255
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in
  if (len > size) {
    len = size
  }
  if (len === 0) {
    return 0
  }
  strm.avail_in -= len
  arraySet(buf, strm.input, strm.next_in, len, start)
  if (strm.state.wrap === 1) {
    strm.adler = adler32_default(strm.adler, buf, len, start)
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_default(strm.adler, buf, len, start)
  }
  strm.next_in += len
  strm.total_in += len
  return len
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length
  var scan = s.strstart
  var match
  var len
  var best_len = s.prev_length
  var nice_match = s.nice_match
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  var _win = s.window
  var wmask = s.w_mask
  var prev = s.prev
  var strend = s.strstart + MAX_MATCH2
  var scan_end1 = _win[scan + best_len - 1]
  var scan_end = _win[scan + best_len]
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead
  }
  do {
    match = cur_match
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue
    }
    scan += 2
    match++
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend)
    len = MAX_MATCH2 - (strend - scan)
    scan = strend - MAX_MATCH2
    if (len > best_len) {
      s.match_start = cur_match
      best_len = len
      if (len >= nice_match) {
        break
      }
      scan_end1 = _win[scan + best_len - 1]
      scan_end = _win[scan + best_len]
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)
  if (best_len <= s.lookahead) {
    return best_len
  }
  return s.lookahead
}
function fill_window(s) {
  var _w_size = s.w_size
  var p, n, m, more, str
  do {
    more = s.window_size - s.lookahead - s.strstart
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      arraySet(s.window, s.window, _w_size, _w_size, 0)
      s.match_start -= _w_size
      s.strstart -= _w_size
      s.block_start -= _w_size
      n = s.hash_size
      p = n
      do {
        m = s.head[--p]
        s.head[p] = m >= _w_size ? m - _w_size : 0
      } while (--n)
      n = _w_size
      p = n
      do {
        m = s.prev[--p]
        s.prev[p] = m >= _w_size ? m - _w_size : 0
      } while (--n)
      more += _w_size
    }
    if (s.strm.avail_in === 0) {
      break
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)
    s.lookahead += n
    if (s.lookahead + s.insert >= MIN_MATCH2) {
      str = s.strstart - s.insert
      s.ins_h = s.window[str]
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH2 - 1]) & s.hash_mask
        s.prev[str & s.w_mask] = s.head[s.ins_h]
        s.head[s.ins_h] = str
        str++
        s.insert--
        if (s.lookahead + s.insert < MIN_MATCH2) {
          break
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
}
function deflate_stored(s, flush) {
  var max_block_size = 65535
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5
  }
  for (; ;) {
    if (s.lookahead <= 1) {
      fill_window(s)
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE
      }
      if (s.lookahead === 0) {
        break
      }
    }
    s.strstart += s.lookahead
    s.lookahead = 0
    var max_start = s.block_start + max_block_size
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start
      s.strstart = max_start
      flush_block_only(s, false)
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false)
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    }
  }
  s.insert = 0
  if (flush === Z_FINISH) {
    flush_block_only(s, true)
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED
    }
    return BS_FINISH_DONE
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false)
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE
    }
  }
  return BS_NEED_MORE
}
function deflate_fast(s, flush) {
  var hash_head
  var bflush
  for (; ;) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s)
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE
      }
      if (s.lookahead === 0) {
        break
      }
    }
    hash_head = 0
    if (s.lookahead >= MIN_MATCH2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
      s.head[s.ins_h] = s.strstart
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head)
    }
    if (s.match_length >= MIN_MATCH2) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH2)
      s.lookahead -= s.match_length
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH2) {
        s.match_length--
        do {
          s.strstart++
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
          s.head[s.ins_h] = s.strstart
        } while (--s.match_length !== 0)
        s.strstart++
      } else {
        s.strstart += s.match_length
        s.match_length = 0
        s.ins_h = s.window[s.strstart]
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart])
      s.lookahead--
      s.strstart++
    }
    if (bflush) {
      flush_block_only(s, false)
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1
  if (flush === Z_FINISH) {
    flush_block_only(s, true)
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED
    }
    return BS_FINISH_DONE
  }
  if (s.last_lit) {
    flush_block_only(s, false)
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE
    }
  }
  return BS_BLOCK_DONE
}
function deflate_slow(s, flush) {
  var hash_head
  var bflush
  var max_insert
  for (; ;) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s)
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE
      }
      if (s.lookahead === 0) {
        break
      }
    }
    hash_head = 0
    if (s.lookahead >= MIN_MATCH2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
      s.head[s.ins_h] = s.strstart
    }
    s.prev_length = s.match_length
    s.prev_match = s.match_start
    s.match_length = MIN_MATCH2 - 1
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head)
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH2 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH2 - 1
      }
    }
    if (s.prev_length >= MIN_MATCH2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH2
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH2)
      s.lookahead -= s.prev_length - 1
      s.prev_length -= 2
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]
          s.head[s.ins_h] = s.strstart
        }
      } while (--s.prev_length !== 0)
      s.match_available = 0
      s.match_length = MIN_MATCH2 - 1
      s.strstart++
      if (bflush) {
        flush_block_only(s, false)
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1])
      if (bflush) {
        flush_block_only(s, false)
      }
      s.strstart++
      s.lookahead--
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    } else {
      s.match_available = 1
      s.strstart++
      s.lookahead--
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1])
    s.match_available = 0
  }
  s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1
  if (flush === Z_FINISH) {
    flush_block_only(s, true)
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED
    }
    return BS_FINISH_DONE
  }
  if (s.last_lit) {
    flush_block_only(s, false)
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE
    }
  }
  return BS_BLOCK_DONE
}
function deflate_rle(s, flush) {
  var bflush
  var prev
  var scan, strend
  var _win = s.window
  for (; ;) {
    if (s.lookahead <= MAX_MATCH2) {
      fill_window(s)
      if (s.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE
      }
      if (s.lookahead === 0) {
        break
      }
    }
    s.match_length = 0
    if (s.lookahead >= MIN_MATCH2 && s.strstart > 0) {
      scan = s.strstart - 1
      prev = _win[scan]
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH2
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend)
        s.match_length = MAX_MATCH2 - (strend - scan)
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead
        }
      }
    }
    if (s.match_length >= MIN_MATCH2) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH2)
      s.lookahead -= s.match_length
      s.strstart += s.match_length
      s.match_length = 0
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart])
      s.lookahead--
      s.strstart++
    }
    if (bflush) {
      flush_block_only(s, false)
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    }
  }
  s.insert = 0
  if (flush === Z_FINISH) {
    flush_block_only(s, true)
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED
    }
    return BS_FINISH_DONE
  }
  if (s.last_lit) {
    flush_block_only(s, false)
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE
    }
  }
  return BS_BLOCK_DONE
}
function deflate_huff(s, flush) {
  var bflush
  for (; ;) {
    if (s.lookahead === 0) {
      fill_window(s)
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE
        }
        break
      }
    }
    s.match_length = 0
    bflush = _tr_tally(s, 0, s.window[s.strstart])
    s.lookahead--
    s.strstart++
    if (bflush) {
      flush_block_only(s, false)
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE
      }
    }
  }
  s.insert = 0
  if (flush === Z_FINISH) {
    flush_block_only(s, true)
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED
    }
    return BS_FINISH_DONE
  }
  if (s.last_lit) {
    flush_block_only(s, false)
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE
    }
  }
  return BS_BLOCK_DONE
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length
  this.max_lazy = max_lazy
  this.nice_length = nice_length
  this.max_chain = max_chain
  this.func = func
}
function lm_init(s) {
  s.window_size = 2 * s.w_size
  zero2(s.head)
  s.max_lazy_match = configuration_table[s.level].max_lazy
  s.good_match = configuration_table[s.level].good_length
  s.nice_match = configuration_table[s.level].nice_length
  s.max_chain_length = configuration_table[s.level].max_chain
  s.strstart = 0
  s.block_start = 0
  s.lookahead = 0
  s.insert = 0
  s.match_length = s.prev_length = MIN_MATCH2 - 1
  s.match_available = 0
  s.ins_h = 0
}
function DeflateState() {
  this.strm = null
  this.status = 0
  this.pending_buf = null
  this.pending_buf_size = 0
  this.pending_out = 0
  this.pending = 0
  this.wrap = 0
  this.gzhead = null
  this.gzindex = 0
  this.method = Z_DEFLATED
  this.last_flush = -1
  this.w_size = 0
  this.w_bits = 0
  this.w_mask = 0
  this.window = null
  this.window_size = 0
  this.prev = null
  this.head = null
  this.ins_h = 0
  this.hash_size = 0
  this.hash_bits = 0
  this.hash_mask = 0
  this.hash_shift = 0
  this.block_start = 0
  this.match_length = 0
  this.prev_match = 0
  this.match_available = 0
  this.strstart = 0
  this.match_start = 0
  this.lookahead = 0
  this.prev_length = 0
  this.max_chain_length = 0
  this.max_lazy_match = 0
  this.level = 0
  this.strategy = 0
  this.good_match = 0
  this.nice_match = 0
  this.dyn_ltree = new Buf16(HEAP_SIZE2 * 2)
  this.dyn_dtree = new Buf16((2 * D_CODES2 + 1) * 2)
  this.bl_tree = new Buf16((2 * BL_CODES2 + 1) * 2)
  zero2(this.dyn_ltree)
  zero2(this.dyn_dtree)
  zero2(this.bl_tree)
  this.l_desc = null
  this.d_desc = null
  this.bl_desc = null
  this.bl_count = new Buf16(MAX_BITS2 + 1)
  this.heap = new Buf16(2 * L_CODES2 + 1)
  zero2(this.heap)
  this.heap_len = 0
  this.heap_max = 0
  this.depth = new Buf16(2 * L_CODES2 + 1)
  zero2(this.depth)
  this.l_buf = 0
  this.lit_bufsize = 0
  this.last_lit = 0
  this.d_buf = 0
  this.opt_len = 0
  this.static_len = 0
  this.matches = 0
  this.insert = 0
  this.bi_buf = 0
  this.bi_valid = 0
}
function deflateResetKeep(strm) {
  var s
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR)
  }
  strm.total_in = strm.total_out = 0
  strm.data_type = Z_UNKNOWN2
  s = strm.state
  s.pending = 0
  s.pending_out = 0
  if (s.wrap < 0) {
    s.wrap = -s.wrap
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE
  strm.adler = s.wrap === 2 ? 0 : 1
  s.last_flush = Z_NO_FLUSH
  _tr_init(s)
  return Z_OK
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm)
  if (ret === Z_OK) {
    lm_init(strm.state)
  }
  return ret
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR
  }
  var wrap2 = 1
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6
  }
  if (windowBits < 0) {
    wrap2 = 0
    windowBits = -windowBits
  } else if (windowBits > 15) {
    wrap2 = 2
    windowBits -= 16
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
    return err(strm, Z_STREAM_ERROR)
  }
  if (windowBits === 8) {
    windowBits = 9
  }
  var s = new DeflateState()
  strm.state = s
  s.strm = strm
  s.wrap = wrap2
  s.gzhead = null
  s.w_bits = windowBits
  s.w_size = 1 << s.w_bits
  s.w_mask = s.w_size - 1
  s.hash_bits = memLevel + 7
  s.hash_size = 1 << s.hash_bits
  s.hash_mask = s.hash_size - 1
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2)
  s.window = new Buf8(s.w_size * 2)
  s.head = new Buf16(s.hash_size)
  s.prev = new Buf16(s.w_size)
  s.lit_bufsize = 1 << memLevel + 6
  s.pending_buf_size = s.lit_bufsize * 4
  s.pending_buf = new Buf8(s.pending_buf_size)
  s.d_buf = 1 * s.lit_bufsize
  s.l_buf = (1 + 2) * s.lit_bufsize
  s.level = level
  s.strategy = strategy
  s.method = method
  return deflateReset(strm)
}
function deflate(strm, flush) {
  var old_flush, s
  var beg, val
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
  }
  s = strm.state
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
  }
  s.strm = strm
  old_flush = s.last_flush
  s.last_flush = flush
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0
      put_byte(s, 31)
      put_byte(s, 139)
      put_byte(s, 8)
      if (!s.gzhead) {
        put_byte(s, 0)
        put_byte(s, 0)
        put_byte(s, 0)
        put_byte(s, 0)
        put_byte(s, 0)
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)
        put_byte(s, OS_CODE)
        s.status = BUSY_STATE
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        )
        put_byte(s, s.gzhead.time & 255)
        put_byte(s, s.gzhead.time >> 8 & 255)
        put_byte(s, s.gzhead.time >> 16 & 255)
        put_byte(s, s.gzhead.time >> 24 & 255)
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)
        put_byte(s, s.gzhead.os & 255)
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255)
          put_byte(s, s.gzhead.extra.length >> 8 & 255)
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending, 0)
        }
        s.gzindex = 0
        s.status = EXTRA_STATE
      }
    } else {
      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8
      var level_flags = -1
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0
      } else if (s.level < 6) {
        level_flags = 1
      } else if (s.level === 6) {
        level_flags = 2
      } else {
        level_flags = 3
      }
      header |= level_flags << 6
      if (s.strstart !== 0) {
        header |= PRESET_DICT
      }
      header += 31 - header % 31
      s.status = BUSY_STATE
      putShortMSB(s, header)
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16)
        putShortMSB(s, strm.adler & 65535)
      }
      strm.adler = 1
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
          }
          flush_pending(strm)
          beg = s.pending
          if (s.pending === s.pending_buf_size) {
            break
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255)
        s.gzindex++
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0
        s.status = NAME_STATE
      }
    } else {
      s.status = NAME_STATE
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
          }
          flush_pending(strm)
          beg = s.pending
          if (s.pending === s.pending_buf_size) {
            val = 1
            break
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255
        } else {
          val = 0
        }
        put_byte(s, val)
      } while (val !== 0)
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
      }
      if (val === 0) {
        s.gzindex = 0
        s.status = COMMENT_STATE
      }
    } else {
      s.status = COMMENT_STATE
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
          }
          flush_pending(strm)
          beg = s.pending
          if (s.pending === s.pending_buf_size) {
            val = 1
            break
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255
        } else {
          val = 0
        }
        put_byte(s, val)
      } while (val !== 0)
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg)
      }
      if (val === 0) {
        s.status = HCRC_STATE
      }
    } else {
      s.status = HCRC_STATE
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm)
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255)
        put_byte(s, strm.adler >> 8 & 255)
        strm.adler = 0
        s.status = BUSY_STATE
      }
    } else {
      s.status = BUSY_STATE
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm)
    if (strm.avail_out === 0) {
      s.last_flush = -1
      return Z_OK
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR)
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR)
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush)
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1
      }
      return Z_OK
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s)
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block(s, 0, 0, false)
        if (flush === Z_FULL_FLUSH) {
          zero2(s.head)
          if (s.lookahead === 0) {
            s.strstart = 0
            s.block_start = 0
            s.insert = 0
          }
        }
      }
      flush_pending(strm)
      if (strm.avail_out === 0) {
        s.last_flush = -1
        return Z_OK
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255)
    put_byte(s, strm.adler >> 8 & 255)
    put_byte(s, strm.adler >> 16 & 255)
    put_byte(s, strm.adler >> 24 & 255)
    put_byte(s, strm.total_in & 255)
    put_byte(s, strm.total_in >> 8 & 255)
    put_byte(s, strm.total_in >> 16 & 255)
    put_byte(s, strm.total_in >> 24 & 255)
  } else {
    putShortMSB(s, strm.adler >>> 16)
    putShortMSB(s, strm.adler & 65535)
  }
  flush_pending(strm)
  if (s.wrap > 0) {
    s.wrap = -s.wrap
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END
}
function deflateEnd(strm) {
  var status2
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR
  }
  status2 = strm.state.status
  if (status2 !== INIT_STATE && status2 !== EXTRA_STATE && status2 !== NAME_STATE && status2 !== COMMENT_STATE && status2 !== HCRC_STATE && status2 !== BUSY_STATE && status2 !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR)
  }
  strm.state = null
  return status2 === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
}
var Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR, Z_DEFAULT_COMPRESSION, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED2, Z_UNKNOWN2, Z_DEFLATED, MAX_MEM_LEVEL, LENGTH_CODES2, LITERALS2, L_CODES2, D_CODES2, BL_CODES2, HEAP_SIZE2, MAX_BITS2, MIN_MATCH2, MAX_MATCH2, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, configuration_table
var init_deflate = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/deflate.js"() {
    init_process()
    init_buffer()
    init_utils()
    init_trees()
    init_adler32()
    init_crc32()
    init_messages()
    Z_NO_FLUSH = 0
    Z_PARTIAL_FLUSH = 1
    Z_FULL_FLUSH = 3
    Z_FINISH = 4
    Z_BLOCK = 5
    Z_OK = 0
    Z_STREAM_END = 1
    Z_STREAM_ERROR = -2
    Z_DATA_ERROR = -3
    Z_BUF_ERROR = -5
    Z_DEFAULT_COMPRESSION = -1
    Z_FILTERED = 1
    Z_HUFFMAN_ONLY = 2
    Z_RLE = 3
    Z_FIXED2 = 4
    Z_UNKNOWN2 = 2
    Z_DEFLATED = 8
    MAX_MEM_LEVEL = 9
    LENGTH_CODES2 = 29
    LITERALS2 = 256
    L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2
    D_CODES2 = 30
    BL_CODES2 = 19
    HEAP_SIZE2 = 2 * L_CODES2 + 1
    MAX_BITS2 = 15
    MIN_MATCH2 = 3
    MAX_MATCH2 = 258
    MIN_LOOKAHEAD = MAX_MATCH2 + MIN_MATCH2 + 1
    PRESET_DICT = 32
    INIT_STATE = 42
    EXTRA_STATE = 69
    NAME_STATE = 73
    COMMENT_STATE = 91
    HCRC_STATE = 103
    BUSY_STATE = 113
    FINISH_STATE = 666
    BS_NEED_MORE = 1
    BS_BLOCK_DONE = 2
    BS_FINISH_STARTED = 3
    BS_FINISH_DONE = 4
    OS_CODE = 3
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ]
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inffast.js
function inflate_fast(strm, start) {
  var state
  var _in
  var last
  var _out
  var beg
  var end
  var dmax
  var wsize
  var whave
  var wnext
  var s_window
  var hold
  var bits
  var lcode
  var dcode
  var lmask
  var dmask
  var here
  var op
  var len
  var dist
  var from3
  var from_source
  var input, output
  state = strm.state
  _in = strm.next_in
  input = strm.input
  last = _in + (strm.avail_in - 5)
  _out = strm.next_out
  output = strm.output
  beg = _out - (start - strm.avail_out)
  end = _out + (strm.avail_out - 257)
  dmax = state.dmax
  wsize = state.wsize
  whave = state.whave
  wnext = state.wnext
  s_window = state.window
  hold = state.hold
  bits = state.bits
  lcode = state.lencode
  dcode = state.distcode
  lmask = (1 << state.lenbits) - 1
  dmask = (1 << state.distbits) - 1
  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits
      bits += 8
      hold += input[_in++] << bits
      bits += 8
    }
    here = lcode[hold & lmask]
    dolen:
    for (; ;) {
      op = here >>> 24
      hold >>>= op
      bits -= op
      op = here >>> 16 & 255
      if (op === 0) {
        output[_out++] = here & 65535
      } else if (op & 16) {
        len = here & 65535
        op &= 15
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits
            bits += 8
          }
          len += hold & (1 << op) - 1
          hold >>>= op
          bits -= op
        }
        if (bits < 15) {
          hold += input[_in++] << bits
          bits += 8
          hold += input[_in++] << bits
          bits += 8
        }
        here = dcode[hold & dmask]
        dodist:
        for (; ;) {
          op = here >>> 24
          hold >>>= op
          bits -= op
          op = here >>> 16 & 255
          if (op & 16) {
            dist = here & 65535
            op &= 15
            if (bits < op) {
              hold += input[_in++] << bits
              bits += 8
              if (bits < op) {
                hold += input[_in++] << bits
                bits += 8
              }
            }
            dist += hold & (1 << op) - 1
            if (dist > dmax) {
              strm.msg = "invalid distance too far back"
              state.mode = BAD
              break top
            }
            hold >>>= op
            bits -= op
            op = _out - beg
            if (dist > op) {
              op = dist - op
              if (op > whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back"
                  state.mode = BAD
                  break top
                }
              }
              from3 = 0
              from_source = s_window
              if (wnext === 0) {
                from3 += wsize - op
                if (op < len) {
                  len -= op
                  do {
                    output[_out++] = s_window[from3++]
                  } while (--op)
                  from3 = _out - dist
                  from_source = output
                }
              } else if (wnext < op) {
                from3 += wsize + wnext - op
                op -= wnext
                if (op < len) {
                  len -= op
                  do {
                    output[_out++] = s_window[from3++]
                  } while (--op)
                  from3 = 0
                  if (wnext < len) {
                    op = wnext
                    len -= op
                    do {
                      output[_out++] = s_window[from3++]
                    } while (--op)
                    from3 = _out - dist
                    from_source = output
                  }
                }
              } else {
                from3 += wnext - op
                if (op < len) {
                  len -= op
                  do {
                    output[_out++] = s_window[from3++]
                  } while (--op)
                  from3 = _out - dist
                  from_source = output
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from3++]
                output[_out++] = from_source[from3++]
                output[_out++] = from_source[from3++]
                len -= 3
              }
              if (len) {
                output[_out++] = from_source[from3++]
                if (len > 1) {
                  output[_out++] = from_source[from3++]
                }
              }
            } else {
              from3 = _out - dist
              do {
                output[_out++] = output[from3++]
                output[_out++] = output[from3++]
                output[_out++] = output[from3++]
                len -= 3
              } while (len > 2)
              if (len) {
                output[_out++] = output[from3++]
                if (len > 1) {
                  output[_out++] = output[from3++]
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)]
            continue dodist
          } else {
            strm.msg = "invalid distance code"
            state.mode = BAD
            break top
          }
          break
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)]
        continue dolen
      } else if (op & 32) {
        state.mode = TYPE
        break top
      } else {
        strm.msg = "invalid literal/length code"
        state.mode = BAD
        break top
      }
      break
    }
  } while (_in < last && _out < end)
  len = bits >> 3
  _in -= len
  bits -= len << 3
  hold &= (1 << bits) - 1
  strm.next_in = _in
  strm.next_out = _out
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last)
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end)
  state.hold = hold
  state.bits = bits
  return
}
var BAD, TYPE
var init_inffast = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inffast.js"() {
    init_process()
    init_buffer()
    BAD = 30
    TYPE = 12
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inftrees.js
function inflate_table(type2, lens, lens_index, codes2, table, table_index, work, opts) {
  var bits = opts.bits
  var len = 0
  var sym = 0
  var min = 0, max = 0
  var root = 0
  var curr = 0
  var drop = 0
  var left = 0
  var used = 0
  var huff = 0
  var incr
  var fill3
  var low
  var mask
  var next
  var base2 = null
  var base_index = 0
  var end
  var count = new Buf16(MAXBITS + 1)
  var offs = new Buf16(MAXBITS + 1)
  var extra = null
  var extra_index = 0
  var here_bits, here_op, here_val
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++
  }
  root = bits
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break
    }
  }
  if (root > max) {
    root = max
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0
    table[table_index++] = 1 << 24 | 64 << 16 | 0
    opts.bits = 1
    return 0
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break
    }
  }
  if (root < min) {
    root = min
  }
  left = 1
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1
    left -= count[len]
    if (left < 0) {
      return -1
    }
  }
  if (left > 0 && (type2 === CODES || max !== 1)) {
    return -1
  }
  offs[1] = 0
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len]
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym
    }
  }
  if (type2 === CODES) {
    base2 = extra = work
    end = 19
  } else if (type2 === LENS) {
    base2 = lbase
    base_index -= 257
    extra = lext
    extra_index -= 257
    end = 256
  } else {
    base2 = dbase
    extra = dext
    end = -1
  }
  huff = 0
  sym = 0
  len = min
  next = table_index
  curr = root
  drop = 0
  low = -1
  used = 1 << root
  mask = used - 1
  if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
    return 1
  }
  var i = 0
  for (; ;) {
    i++
    here_bits = len - drop
    if (work[sym] < end) {
      here_op = 0
      here_val = work[sym]
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]]
      here_val = base2[base_index + work[sym]]
    } else {
      here_op = 32 + 64
      here_val = 0
    }
    incr = 1 << len - drop
    fill3 = 1 << curr
    min = fill3
    do {
      fill3 -= incr
      table[next + (huff >> drop) + fill3] = here_bits << 24 | here_op << 16 | here_val | 0
    } while (fill3 !== 0)
    incr = 1 << len - 1
    while (huff & incr) {
      incr >>= 1
    }
    if (incr !== 0) {
      huff &= incr - 1
      huff += incr
    } else {
      huff = 0
    }
    sym++
    if (--count[len] === 0) {
      if (len === max) {
        break
      }
      len = lens[lens_index + work[sym]]
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root
      }
      next += min
      curr = len - drop
      left = 1 << curr
      while (curr + drop < max) {
        left -= count[curr + drop]
        if (left <= 0) {
          break
        }
        curr++
        left <<= 1
      }
      used += 1 << curr
      if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
        return 1
      }
      low = huff & mask
      table[low] = root << 24 | curr << 16 | next - table_index | 0
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0
  }
  opts.bits = root
  return 0
}
var MAXBITS, ENOUGH_LENS, ENOUGH_DISTS, CODES, LENS, DISTS, lbase, lext, dbase, dext
var init_inftrees = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inftrees.js"() {
    init_process()
    init_buffer()
    init_utils()
    MAXBITS = 15
    ENOUGH_LENS = 852
    ENOUGH_DISTS = 592
    CODES = 0
    LENS = 1
    DISTS = 2
    lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]
    lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]
    dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]
    dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inflate.js
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
}
function InflateState() {
  this.mode = 0
  this.last = false
  this.wrap = 0
  this.havedict = false
  this.flags = 0
  this.dmax = 0
  this.check = 0
  this.total = 0
  this.head = null
  this.wbits = 0
  this.wsize = 0
  this.whave = 0
  this.wnext = 0
  this.window = null
  this.hold = 0
  this.bits = 0
  this.length = 0
  this.offset = 0
  this.extra = 0
  this.lencode = null
  this.distcode = null
  this.lenbits = 0
  this.distbits = 0
  this.ncode = 0
  this.nlen = 0
  this.ndist = 0
  this.have = 0
  this.next = null
  this.lens = new Buf16(320)
  this.work = new Buf16(288)
  this.lendyn = null
  this.distdyn = null
  this.sane = 0
  this.back = 0
  this.was = 0
}
function inflateResetKeep(strm) {
  var state
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2
  }
  state = strm.state
  strm.total_in = strm.total_out = state.total = 0
  strm.msg = ""
  if (state.wrap) {
    strm.adler = state.wrap & 1
  }
  state.mode = HEAD
  state.last = 0
  state.havedict = 0
  state.dmax = 32768
  state.head = null
  state.hold = 0
  state.bits = 0
  state.lencode = state.lendyn = new Buf32(ENOUGH_LENS2)
  state.distcode = state.distdyn = new Buf32(ENOUGH_DISTS2)
  state.sane = 1
  state.back = -1
  return Z_OK2
}
function inflateReset(strm) {
  var state
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2
  }
  state = strm.state
  state.wsize = 0
  state.whave = 0
  state.wnext = 0
  return inflateResetKeep(strm)
}
function inflateReset2(strm, windowBits) {
  var wrap2
  var state
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2
  }
  state = strm.state
  if (windowBits < 0) {
    wrap2 = 0
    windowBits = -windowBits
  } else {
    wrap2 = (windowBits >> 4) + 1
    if (windowBits < 48) {
      windowBits &= 15
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR2
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null
  }
  state.wrap = wrap2
  state.wbits = windowBits
  return inflateReset(strm)
}
function inflateInit2(strm, windowBits) {
  var ret
  var state
  if (!strm) {
    return Z_STREAM_ERROR2
  }
  state = new InflateState()
  strm.state = state
  state.window = null
  ret = inflateReset2(strm, windowBits)
  if (ret !== Z_OK2) {
    strm.state = null
  }
  return ret
}
function fixedtables(state) {
  if (virgin) {
    var sym
    lenfix = new Buf32(512)
    distfix = new Buf32(32)
    sym = 0
    while (sym < 144) {
      state.lens[sym++] = 8
    }
    while (sym < 256) {
      state.lens[sym++] = 9
    }
    while (sym < 280) {
      state.lens[sym++] = 7
    }
    while (sym < 288) {
      state.lens[sym++] = 8
    }
    inflate_table(LENS2, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    })
    sym = 0
    while (sym < 32) {
      state.lens[sym++] = 5
    }
    inflate_table(DISTS2, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    })
    virgin = false
  }
  state.lencode = lenfix
  state.lenbits = 9
  state.distcode = distfix
  state.distbits = 5
}
function updatewindow(strm, src, end, copy3) {
  var dist
  var state = strm.state
  if (state.window === null) {
    state.wsize = 1 << state.wbits
    state.wnext = 0
    state.whave = 0
    state.window = new Buf8(state.wsize)
  }
  if (copy3 >= state.wsize) {
    arraySet(state.window, src, end - state.wsize, state.wsize, 0)
    state.wnext = 0
    state.whave = state.wsize
  } else {
    dist = state.wsize - state.wnext
    if (dist > copy3) {
      dist = copy3
    }
    arraySet(state.window, src, end - copy3, dist, state.wnext)
    copy3 -= dist
    if (copy3) {
      arraySet(state.window, src, end - copy3, copy3, 0)
      state.wnext = copy3
      state.whave = state.wsize
    } else {
      state.wnext += dist
      if (state.wnext === state.wsize) {
        state.wnext = 0
      }
      if (state.whave < state.wsize) {
        state.whave += dist
      }
    }
  }
  return 0
}
function inflate(strm, flush) {
  var state
  var input, output
  var next
  var put
  var have, left
  var hold
  var bits
  var _in, _out
  var copy3
  var from3
  var from_source
  var here = 0
  var here_bits, here_op, here_val
  var last_bits, last_op, last_val
  var len
  var ret
  var hbuf = new Buf8(4)
  var opts
  var n
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  )
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR2
  }
  state = strm.state
  if (state.mode === TYPE2) {
    state.mode = TYPEDO
  }
  put = strm.next_out
  output = strm.output
  left = strm.avail_out
  next = strm.next_in
  input = strm.input
  have = strm.avail_in
  hold = state.hold
  bits = state.bits
  _in = have
  _out = left
  ret = Z_OK2
  inf_leave:
  for (; ;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO
          break
        }
        while (bits < 16) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if (state.wrap & 2 && hold === 35615) {
          state.check = 0
          hbuf[0] = hold & 255
          hbuf[1] = hold >>> 8 & 255
          state.check = crc32_default(state.check, hbuf, 2, 0)
          hold = 0
          bits = 0
          state.mode = FLAGS
          break
        }
        state.flags = 0
        if (state.head) {
          state.head.done = false
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
          strm.msg = "incorrect header check"
          state.mode = BAD2
          break
        }
        if ((hold & 15) !== Z_DEFLATED2) {
          strm.msg = "unknown compression method"
          state.mode = BAD2
          break
        }
        hold >>>= 4
        bits -= 4
        len = (hold & 15) + 8
        if (state.wbits === 0) {
          state.wbits = len
        } else if (len > state.wbits) {
          strm.msg = "invalid window size"
          state.mode = BAD2
          break
        }
        state.dmax = 1 << len
        strm.adler = state.check = 1
        state.mode = hold & 512 ? DICTID : TYPE2
        hold = 0
        bits = 0
        break
      case FLAGS:
        while (bits < 16) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        state.flags = hold
        if ((state.flags & 255) !== Z_DEFLATED2) {
          strm.msg = "unknown compression method"
          state.mode = BAD2
          break
        }
        if (state.flags & 57344) {
          strm.msg = "unknown header flags set"
          state.mode = BAD2
          break
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1
        }
        if (state.flags & 512) {
          hbuf[0] = hold & 255
          hbuf[1] = hold >>> 8 & 255
          state.check = crc32_default(state.check, hbuf, 2, 0)
        }
        hold = 0
        bits = 0
        state.mode = TIME
      case TIME:
        while (bits < 32) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if (state.head) {
          state.head.time = hold
        }
        if (state.flags & 512) {
          hbuf[0] = hold & 255
          hbuf[1] = hold >>> 8 & 255
          hbuf[2] = hold >>> 16 & 255
          hbuf[3] = hold >>> 24 & 255
          state.check = crc32_default(state.check, hbuf, 4, 0)
        }
        hold = 0
        bits = 0
        state.mode = OS2
      case OS2:
        while (bits < 16) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if (state.head) {
          state.head.xflags = hold & 255
          state.head.os = hold >> 8
        }
        if (state.flags & 512) {
          hbuf[0] = hold & 255
          hbuf[1] = hold >>> 8 & 255
          state.check = crc32_default(state.check, hbuf, 2, 0)
        }
        hold = 0
        bits = 0
        state.mode = EXLEN
      case EXLEN:
        if (state.flags & 1024) {
          while (bits < 16) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          state.length = hold
          if (state.head) {
            state.head.extra_len = hold
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255
            hbuf[1] = hold >>> 8 & 255
            state.check = crc32_default(state.check, hbuf, 2, 0)
          }
          hold = 0
          bits = 0
        } else if (state.head) {
          state.head.extra = null
        }
        state.mode = EXTRA
      case EXTRA:
        if (state.flags & 1024) {
          copy3 = state.length
          if (copy3 > have) {
            copy3 = have
          }
          if (copy3) {
            if (state.head) {
              len = state.head.extra_len - state.length
              if (!state.head.extra) {
                state.head.extra = new Array(state.head.extra_len)
              }
              arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy3,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              )
            }
            if (state.flags & 512) {
              state.check = crc32_default(state.check, input, copy3, next)
            }
            have -= copy3
            next += copy3
            state.length -= copy3
          }
          if (state.length) {
            break inf_leave
          }
        }
        state.length = 0
        state.mode = NAME
      case NAME:
        if (state.flags & 2048) {
          if (have === 0) {
            break inf_leave
          }
          copy3 = 0
          do {
            len = input[next + copy3++]
            if (state.head && len && state.length < 65536) {
              state.head.name += String.fromCharCode(len)
            }
          } while (len && copy3 < have)
          if (state.flags & 512) {
            state.check = crc32_default(state.check, input, copy3, next)
          }
          have -= copy3
          next += copy3
          if (len) {
            break inf_leave
          }
        } else if (state.head) {
          state.head.name = null
        }
        state.length = 0
        state.mode = COMMENT
      case COMMENT:
        if (state.flags & 4096) {
          if (have === 0) {
            break inf_leave
          }
          copy3 = 0
          do {
            len = input[next + copy3++]
            if (state.head && len && state.length < 65536) {
              state.head.comment += String.fromCharCode(len)
            }
          } while (len && copy3 < have)
          if (state.flags & 512) {
            state.check = crc32_default(state.check, input, copy3, next)
          }
          have -= copy3
          next += copy3
          if (len) {
            break inf_leave
          }
        } else if (state.head) {
          state.head.comment = null
        }
        state.mode = HCRC
      case HCRC:
        if (state.flags & 512) {
          while (bits < 16) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          if (hold !== (state.check & 65535)) {
            strm.msg = "header crc mismatch"
            state.mode = BAD2
            break
          }
          hold = 0
          bits = 0
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1
          state.head.done = true
        }
        strm.adler = state.check = 0
        state.mode = TYPE2
        break
      case DICTID:
        while (bits < 32) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        strm.adler = state.check = zswap32(hold)
        hold = 0
        bits = 0
        state.mode = DICT
      case DICT:
        if (state.havedict === 0) {
          strm.next_out = put
          strm.avail_out = left
          strm.next_in = next
          strm.avail_in = have
          state.hold = hold
          state.bits = bits
          return Z_NEED_DICT
        }
        strm.adler = state.check = 1
        state.mode = TYPE2
      case TYPE2:
        if (flush === Z_BLOCK2 || flush === Z_TREES) {
          break inf_leave
        }
      case TYPEDO:
        if (state.last) {
          hold >>>= bits & 7
          bits -= bits & 7
          state.mode = CHECK
          break
        }
        while (bits < 3) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        state.last = hold & 1
        hold >>>= 1
        bits -= 1
        switch (hold & 3) {
          case 0:
            state.mode = STORED
            break
          case 1:
            fixedtables(state)
            state.mode = LEN_
            if (flush === Z_TREES) {
              hold >>>= 2
              bits -= 2
              break inf_leave
            }
            break
          case 2:
            state.mode = TABLE
            break
          case 3:
            strm.msg = "invalid block type"
            state.mode = BAD2
        }
        hold >>>= 2
        bits -= 2
        break
      case STORED:
        hold >>>= bits & 7
        bits -= bits & 7
        while (bits < 32) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
          strm.msg = "invalid stored block lengths"
          state.mode = BAD2
          break
        }
        state.length = hold & 65535
        hold = 0
        bits = 0
        state.mode = COPY_
        if (flush === Z_TREES) {
          break inf_leave
        }
      case COPY_:
        state.mode = COPY
      case COPY:
        copy3 = state.length
        if (copy3) {
          if (copy3 > have) {
            copy3 = have
          }
          if (copy3 > left) {
            copy3 = left
          }
          if (copy3 === 0) {
            break inf_leave
          }
          arraySet(output, input, next, copy3, put)
          have -= copy3
          next += copy3
          left -= copy3
          put += copy3
          state.length -= copy3
          break
        }
        state.mode = TYPE2
        break
      case TABLE:
        while (bits < 14) {
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        state.nlen = (hold & 31) + 257
        hold >>>= 5
        bits -= 5
        state.ndist = (hold & 31) + 1
        hold >>>= 5
        bits -= 5
        state.ncode = (hold & 15) + 4
        hold >>>= 4
        bits -= 4
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = "too many length or distance symbols"
          state.mode = BAD2
          break
        }
        state.have = 0
        state.mode = LENLENS
      case LENLENS:
        while (state.have < state.ncode) {
          while (bits < 3) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          state.lens[order[state.have++]] = hold & 7
          hold >>>= 3
          bits -= 3
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0
        }
        state.lencode = state.lendyn
        state.lenbits = 7
        opts = {
          bits: state.lenbits
        }
        ret = inflate_table(CODES2, state.lens, 0, 19, state.lencode, 0, state.work, opts)
        state.lenbits = opts.bits
        if (ret) {
          strm.msg = "invalid code lengths set"
          state.mode = BAD2
          break
        }
        state.have = 0
        state.mode = CODELENS
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (; ;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]
            here_bits = here >>> 24
            here_op = here >>> 16 & 255
            here_val = here & 65535
            if (here_bits <= bits) {
              break
            }
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          if (here_val < 16) {
            hold >>>= here_bits
            bits -= here_bits
            state.lens[state.have++] = here_val
          } else {
            if (here_val === 16) {
              n = here_bits + 2
              while (bits < n) {
                if (have === 0) {
                  break inf_leave
                }
                have--
                hold += input[next++] << bits
                bits += 8
              }
              hold >>>= here_bits
              bits -= here_bits
              if (state.have === 0) {
                strm.msg = "invalid bit length repeat"
                state.mode = BAD2
                break
              }
              len = state.lens[state.have - 1]
              copy3 = 3 + (hold & 3)
              hold >>>= 2
              bits -= 2
            } else if (here_val === 17) {
              n = here_bits + 3
              while (bits < n) {
                if (have === 0) {
                  break inf_leave
                }
                have--
                hold += input[next++] << bits
                bits += 8
              }
              hold >>>= here_bits
              bits -= here_bits
              len = 0
              copy3 = 3 + (hold & 7)
              hold >>>= 3
              bits -= 3
            } else {
              n = here_bits + 7
              while (bits < n) {
                if (have === 0) {
                  break inf_leave
                }
                have--
                hold += input[next++] << bits
                bits += 8
              }
              hold >>>= here_bits
              bits -= here_bits
              len = 0
              copy3 = 11 + (hold & 127)
              hold >>>= 7
              bits -= 7
            }
            if (state.have + copy3 > state.nlen + state.ndist) {
              strm.msg = "invalid bit length repeat"
              state.mode = BAD2
              break
            }
            while (copy3--) {
              state.lens[state.have++] = len
            }
          }
        }
        if (state.mode === BAD2) {
          break
        }
        if (state.lens[256] === 0) {
          strm.msg = "invalid code -- missing end-of-block"
          state.mode = BAD2
          break
        }
        state.lenbits = 9
        opts = {
          bits: state.lenbits
        }
        ret = inflate_table(LENS2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts)
        state.lenbits = opts.bits
        if (ret) {
          strm.msg = "invalid literal/lengths set"
          state.mode = BAD2
          break
        }
        state.distbits = 6
        state.distcode = state.distdyn
        opts = {
          bits: state.distbits
        }
        ret = inflate_table(DISTS2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts)
        state.distbits = opts.bits
        if (ret) {
          strm.msg = "invalid distances set"
          state.mode = BAD2
          break
        }
        state.mode = LEN_
        if (flush === Z_TREES) {
          break inf_leave
        }
      case LEN_:
        state.mode = LEN
      case LEN:
        if (have >= 6 && left >= 258) {
          strm.next_out = put
          strm.avail_out = left
          strm.next_in = next
          strm.avail_in = have
          state.hold = hold
          state.bits = bits
          inflate_fast(strm, _out)
          put = strm.next_out
          output = strm.output
          left = strm.avail_out
          next = strm.next_in
          input = strm.input
          have = strm.avail_in
          hold = state.hold
          bits = state.bits
          if (state.mode === TYPE2) {
            state.back = -1
          }
          break
        }
        state.back = 0
        for (; ;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]
          here_bits = here >>> 24
          here_op = here >>> 16 & 255
          here_val = here & 65535
          if (here_bits <= bits) {
            break
          }
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if (here_op && (here_op & 240) === 0) {
          last_bits = here_bits
          last_op = here_op
          last_val = here_val
          for (; ;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]
            here_bits = here >>> 24
            here_op = here >>> 16 & 255
            here_val = here & 65535
            if (last_bits + here_bits <= bits) {
              break
            }
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          hold >>>= last_bits
          bits -= last_bits
          state.back += last_bits
        }
        hold >>>= here_bits
        bits -= here_bits
        state.back += here_bits
        state.length = here_val
        if (here_op === 0) {
          state.mode = LIT
          break
        }
        if (here_op & 32) {
          state.back = -1
          state.mode = TYPE2
          break
        }
        if (here_op & 64) {
          strm.msg = "invalid literal/length code"
          state.mode = BAD2
          break
        }
        state.extra = here_op & 15
        state.mode = LENEXT
      case LENEXT:
        if (state.extra) {
          n = state.extra
          while (bits < n) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          state.length += hold & (1 << state.extra) - 1
          hold >>>= state.extra
          bits -= state.extra
          state.back += state.extra
        }
        state.was = state.length
        state.mode = DIST
      case DIST:
        for (; ;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]
          here_bits = here >>> 24
          here_op = here >>> 16 & 255
          here_val = here & 65535
          if (here_bits <= bits) {
            break
          }
          if (have === 0) {
            break inf_leave
          }
          have--
          hold += input[next++] << bits
          bits += 8
        }
        if ((here_op & 240) === 0) {
          last_bits = here_bits
          last_op = here_op
          last_val = here_val
          for (; ;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]
            here_bits = here >>> 24
            here_op = here >>> 16 & 255
            here_val = here & 65535
            if (last_bits + here_bits <= bits) {
              break
            }
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          hold >>>= last_bits
          bits -= last_bits
          state.back += last_bits
        }
        hold >>>= here_bits
        bits -= here_bits
        state.back += here_bits
        if (here_op & 64) {
          strm.msg = "invalid distance code"
          state.mode = BAD2
          break
        }
        state.offset = here_val
        state.extra = here_op & 15
        state.mode = DISTEXT
      case DISTEXT:
        if (state.extra) {
          n = state.extra
          while (bits < n) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          state.offset += hold & (1 << state.extra) - 1
          hold >>>= state.extra
          bits -= state.extra
          state.back += state.extra
        }
        if (state.offset > state.dmax) {
          strm.msg = "invalid distance too far back"
          state.mode = BAD2
          break
        }
        state.mode = MATCH
      case MATCH:
        if (left === 0) {
          break inf_leave
        }
        copy3 = _out - left
        if (state.offset > copy3) {
          copy3 = state.offset - copy3
          if (copy3 > state.whave) {
            if (state.sane) {
              strm.msg = "invalid distance too far back"
              state.mode = BAD2
              break
            }
          }
          if (copy3 > state.wnext) {
            copy3 -= state.wnext
            from3 = state.wsize - copy3
          } else {
            from3 = state.wnext - copy3
          }
          if (copy3 > state.length) {
            copy3 = state.length
          }
          from_source = state.window
        } else {
          from_source = output
          from3 = put - state.offset
          copy3 = state.length
        }
        if (copy3 > left) {
          copy3 = left
        }
        left -= copy3
        state.length -= copy3
        do {
          output[put++] = from_source[from3++]
        } while (--copy3)
        if (state.length === 0) {
          state.mode = LEN
        }
        break
      case LIT:
        if (left === 0) {
          break inf_leave
        }
        output[put++] = state.length
        left--
        state.mode = LEN
        break
      case CHECK:
        if (state.wrap) {
          while (bits < 32) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold |= input[next++] << bits
            bits += 8
          }
          _out -= left
          strm.total_out += _out
          state.total += _out
          if (_out) {
            strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32_default(state.check, output, _out, put - _out) : adler32_default(state.check, output, _out, put - _out)
          }
          _out = left
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = "incorrect data check"
            state.mode = BAD2
            break
          }
          hold = 0
          bits = 0
        }
        state.mode = LENGTH
      case LENGTH:
        if (state.wrap && state.flags) {
          while (bits < 32) {
            if (have === 0) {
              break inf_leave
            }
            have--
            hold += input[next++] << bits
            bits += 8
          }
          if (hold !== (state.total & 4294967295)) {
            strm.msg = "incorrect length check"
            state.mode = BAD2
            break
          }
          hold = 0
          bits = 0
        }
        state.mode = DONE
      case DONE:
        ret = Z_STREAM_END2
        break inf_leave
      case BAD2:
        ret = Z_DATA_ERROR2
        break inf_leave
      case MEM:
        return Z_MEM_ERROR
      case SYNC:
      default:
        return Z_STREAM_ERROR2
    }
  }
  strm.next_out = put
  strm.avail_out = left
  strm.next_in = next
  strm.avail_in = have
  state.hold = hold
  state.bits = bits
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD2 && (state.mode < CHECK || flush !== Z_FINISH2)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM
      return Z_MEM_ERROR
    }
  }
  _in -= strm.avail_in
  _out -= strm.avail_out
  strm.total_in += _in
  strm.total_out += _out
  state.total += _out
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32_default(state.check, output, _out, strm.next_out - _out) : adler32_default(state.check, output, _out, strm.next_out - _out)
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0)
  if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
    ret = Z_BUF_ERROR2
  }
  return ret
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2
  }
  var state = strm.state
  if (state.window) {
    state.window = null
  }
  strm.state = null
  return Z_OK2
}
var CODES2, LENS2, DISTS2, Z_FINISH2, Z_BLOCK2, Z_TREES, Z_OK2, Z_STREAM_END2, Z_NEED_DICT, Z_STREAM_ERROR2, Z_DATA_ERROR2, Z_MEM_ERROR, Z_BUF_ERROR2, Z_DEFLATED2, HEAD, FLAGS, TIME, OS2, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE2, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD2, MEM, SYNC, ENOUGH_LENS2, ENOUGH_DISTS2, virgin, lenfix, distfix
var init_inflate = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/inflate.js"() {
    "use strict"
    init_process()
    init_buffer()
    init_utils()
    init_adler32()
    init_crc32()
    init_inffast()
    init_inftrees()
    CODES2 = 0
    LENS2 = 1
    DISTS2 = 2
    Z_FINISH2 = 4
    Z_BLOCK2 = 5
    Z_TREES = 6
    Z_OK2 = 0
    Z_STREAM_END2 = 1
    Z_NEED_DICT = 2
    Z_STREAM_ERROR2 = -2
    Z_DATA_ERROR2 = -3
    Z_MEM_ERROR = -4
    Z_BUF_ERROR2 = -5
    Z_DEFLATED2 = 8
    HEAD = 1
    FLAGS = 2
    TIME = 3
    OS2 = 4
    EXLEN = 5
    EXTRA = 6
    NAME = 7
    COMMENT = 8
    HCRC = 9
    DICTID = 10
    DICT = 11
    TYPE2 = 12
    TYPEDO = 13
    STORED = 14
    COPY_ = 15
    COPY = 16
    TABLE = 17
    LENLENS = 18
    CODELENS = 19
    LEN_ = 20
    LEN = 21
    LENEXT = 22
    DIST = 23
    DISTEXT = 24
    MATCH = 25
    LIT = 26
    CHECK = 27
    LENGTH = 28
    DONE = 29
    BAD2 = 30
    MEM = 31
    SYNC = 32
    ENOUGH_LENS2 = 852
    ENOUGH_DISTS2 = 592
    virgin = true
  }
})

// node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/binding.js
var binding_exports = {}
__export(binding_exports, {
  DEFLATE: () => DEFLATE,
  DEFLATERAW: () => DEFLATERAW,
  GUNZIP: () => GUNZIP,
  GZIP: () => GZIP,
  INFLATE: () => INFLATE,
  INFLATERAW: () => INFLATERAW,
  NONE: () => NONE,
  UNZIP: () => UNZIP,
  Z_BEST_COMPRESSION: () => Z_BEST_COMPRESSION,
  Z_BEST_SPEED: () => Z_BEST_SPEED,
  Z_BINARY: () => Z_BINARY2,
  Z_BLOCK: () => Z_BLOCK3,
  Z_BUF_ERROR: () => Z_BUF_ERROR3,
  Z_DATA_ERROR: () => Z_DATA_ERROR3,
  Z_DEFAULT_COMPRESSION: () => Z_DEFAULT_COMPRESSION2,
  Z_DEFAULT_STRATEGY: () => Z_DEFAULT_STRATEGY,
  Z_DEFLATED: () => Z_DEFLATED3,
  Z_ERRNO: () => Z_ERRNO,
  Z_FILTERED: () => Z_FILTERED2,
  Z_FINISH: () => Z_FINISH3,
  Z_FIXED: () => Z_FIXED3,
  Z_FULL_FLUSH: () => Z_FULL_FLUSH2,
  Z_HUFFMAN_ONLY: () => Z_HUFFMAN_ONLY2,
  Z_NEED_DICT: () => Z_NEED_DICT2,
  Z_NO_COMPRESSION: () => Z_NO_COMPRESSION,
  Z_NO_FLUSH: () => Z_NO_FLUSH2,
  Z_OK: () => Z_OK3,
  Z_PARTIAL_FLUSH: () => Z_PARTIAL_FLUSH2,
  Z_RLE: () => Z_RLE2,
  Z_STREAM_END: () => Z_STREAM_END3,
  Z_STREAM_ERROR: () => Z_STREAM_ERROR3,
  Z_SYNC_FLUSH: () => Z_SYNC_FLUSH,
  Z_TEXT: () => Z_TEXT2,
  Z_TREES: () => Z_TREES2,
  Z_UNKNOWN: () => Z_UNKNOWN3,
  Zlib: () => Zlib
})
function Zlib(mode) {
  if (mode < DEFLATE || mode > UNZIP)
    throw new TypeError("Bad argument")
  this.mode = mode
  this.init_done = false
  this.write_in_progress = false
  this.pending_close = false
  this.windowBits = 0
  this.level = 0
  this.memLevel = 0
  this.strategy = 0
  this.dictionary = null
}
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i]
  }
}
var NONE, DEFLATE, INFLATE, GZIP, GUNZIP, DEFLATERAW, INFLATERAW, UNZIP, Z_NO_FLUSH2, Z_PARTIAL_FLUSH2, Z_SYNC_FLUSH, Z_FULL_FLUSH2, Z_FINISH3, Z_BLOCK3, Z_TREES2, Z_OK3, Z_STREAM_END3, Z_NEED_DICT2, Z_ERRNO, Z_STREAM_ERROR3, Z_DATA_ERROR3, Z_BUF_ERROR3, Z_NO_COMPRESSION, Z_BEST_SPEED, Z_BEST_COMPRESSION, Z_DEFAULT_COMPRESSION2, Z_FILTERED2, Z_HUFFMAN_ONLY2, Z_RLE2, Z_FIXED3, Z_DEFAULT_STRATEGY, Z_BINARY2, Z_TEXT2, Z_UNKNOWN3, Z_DEFLATED3, status
var init_binding = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/zlib-lib/binding.js"() {
    init_process()
    init_buffer()
    init_messages()
    init_zstream()
    init_deflate()
    init_inflate()
    NONE = 0
    DEFLATE = 1
    INFLATE = 2
    GZIP = 3
    GUNZIP = 4
    DEFLATERAW = 5
    INFLATERAW = 6
    UNZIP = 7
    Z_NO_FLUSH2 = 0
    Z_PARTIAL_FLUSH2 = 1
    Z_SYNC_FLUSH = 2
    Z_FULL_FLUSH2 = 3
    Z_FINISH3 = 4
    Z_BLOCK3 = 5
    Z_TREES2 = 6
    Z_OK3 = 0
    Z_STREAM_END3 = 1
    Z_NEED_DICT2 = 2
    Z_ERRNO = -1
    Z_STREAM_ERROR3 = -2
    Z_DATA_ERROR3 = -3
    Z_BUF_ERROR3 = -5
    Z_NO_COMPRESSION = 0
    Z_BEST_SPEED = 1
    Z_BEST_COMPRESSION = 9
    Z_DEFAULT_COMPRESSION2 = -1
    Z_FILTERED2 = 1
    Z_HUFFMAN_ONLY2 = 2
    Z_RLE2 = 3
    Z_FIXED3 = 4
    Z_DEFAULT_STRATEGY = 0
    Z_BINARY2 = 0
    Z_TEXT2 = 1
    Z_UNKNOWN3 = 2
    Z_DEFLATED3 = 8
    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
      this.windowBits = windowBits
      this.level = level
      this.memLevel = memLevel
      this.strategy = strategy
      if (this.mode === GZIP || this.mode === GUNZIP)
        this.windowBits += 16
      if (this.mode === UNZIP)
        this.windowBits += 32
      if (this.mode === DEFLATERAW || this.mode === INFLATERAW)
        this.windowBits = -this.windowBits
      this.strm = new zstream_default()
      var status2
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status2 = deflateInit2(
            this.strm,
            this.level,
            Z_DEFLATED3,
            this.windowBits,
            this.memLevel,
            this.strategy
          )
          break
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
          status2 = inflateInit2(
            this.strm,
            this.windowBits
          )
          break
        default:
          throw new Error("Unknown mode " + this.mode)
      }
      if (status2 !== Z_OK3) {
        this._error(status2)
        return
      }
      this.write_in_progress = false
      this.init_done = true
    }
    Zlib.prototype.params = function () {
      throw new Error("deflateParams Not supported")
    }
    Zlib.prototype._writeCheck = function () {
      if (!this.init_done)
        throw new Error("write before init")
      if (this.mode === NONE)
        throw new Error("already finalized")
      if (this.write_in_progress)
        throw new Error("write already in progress")
      if (this.pending_close)
        throw new Error("close is pending")
    }
    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck()
      this.write_in_progress = true
      var self = this
      process.nextTick(function () {
        self.write_in_progress = false
        var res = self._write(flush, input, in_off, in_len, out, out_off, out_len)
        self.callback(res[0], res[1])
        if (self.pending_close)
          self.close()
      })
      return this
    }
    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck()
      return this._write(flush, input, in_off, in_len, out, out_off, out_len)
    }
    Zlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this.write_in_progress = true
      if (flush !== Z_NO_FLUSH2 && flush !== Z_PARTIAL_FLUSH2 && flush !== Z_SYNC_FLUSH && flush !== Z_FULL_FLUSH2 && flush !== Z_FINISH3 && flush !== Z_BLOCK3) {
        throw new Error("Invalid flush value")
      }
      if (input == null) {
        input = new Buffer2(0)
        in_len = 0
        in_off = 0
      }
      if (out._set)
        out.set = out._set
      else
        out.set = bufferSet
      var strm = this.strm
      strm.avail_in = in_len
      strm.input = input
      strm.next_in = in_off
      strm.avail_out = out_len
      strm.output = out
      strm.next_out = out_off
      var status2
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status2 = deflate(strm, flush)
          break
        case UNZIP:
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
          status2 = inflate(strm, flush)
          break
        default:
          throw new Error("Unknown mode " + this.mode)
      }
      if (status2 !== Z_STREAM_END3 && status2 !== Z_OK3) {
        this._error(status2)
      }
      this.write_in_progress = false
      return [strm.avail_in, strm.avail_out]
    }
    Zlib.prototype.close = function () {
      if (this.write_in_progress) {
        this.pending_close = true
        return
      }
      this.pending_close = false
      if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {
        deflateEnd(this.strm)
      } else {
        inflateEnd(this.strm)
      }
      this.mode = NONE
    }
    Zlib.prototype.reset = function () {
      switch (this.mode) {
        case DEFLATE:
        case DEFLATERAW:
          status = deflateReset(this.strm)
          break
        case INFLATE:
        case INFLATERAW:
          status = inflateReset(this.strm)
          break
      }
      if (status !== Z_OK3) {
        this._error(status)
      }
    }
    Zlib.prototype._error = function (status2) {
      this.onerror(messages_default[status2] + ": " + this.strm.msg, status2)
      this.write_in_progress = false
      if (this.pending_close)
        this.close()
    }
  }
})

// node-modules-polyfills:zlib
var zlib_exports = {}
__export(zlib_exports, {
  Deflate: () => Deflate,
  DeflateRaw: () => DeflateRaw,
  Gunzip: () => Gunzip,
  Gzip: () => Gzip,
  Inflate: () => Inflate,
  InflateRaw: () => InflateRaw,
  Unzip: () => Unzip,
  Zlib: () => Zlib2,
  codes: () => codes,
  createDeflate: () => createDeflate,
  createDeflateRaw: () => createDeflateRaw,
  createGunzip: () => createGunzip,
  createGzip: () => createGzip,
  createInflate: () => createInflate,
  createInflateRaw: () => createInflateRaw,
  createUnzip: () => createUnzip,
  default: () => zlib_default,
  deflate: () => deflate2,
  deflateRaw: () => deflateRaw,
  deflateRawSync: () => deflateRawSync,
  deflateSync: () => deflateSync,
  gunzip: () => gunzip,
  gunzipSync: () => gunzipSync,
  gzip: () => gzip,
  gzipSync: () => gzipSync,
  inflate: () => inflate2,
  inflateRaw: () => inflateRaw,
  inflateRawSync: () => inflateRawSync,
  inflateSync: () => inflateSync,
  unzip: () => unzip,
  unzipSync: () => unzipSync
})
function assert2(a, msg) {
  if (!a) {
    throw new Error(msg)
  }
}
function createDeflate(o) {
  return new Deflate(o)
}
function createInflate(o) {
  return new Inflate(o)
}
function createDeflateRaw(o) {
  return new DeflateRaw(o)
}
function createInflateRaw(o) {
  return new InflateRaw(o)
}
function createGzip(o) {
  return new Gzip(o)
}
function createGunzip(o) {
  return new Gunzip(o)
}
function createUnzip(o) {
  return new Unzip(o)
}
function deflate2(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new Deflate(opts), buffer, callback)
}
function deflateSync(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer)
}
function gzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new Gzip(opts), buffer, callback)
}
function gzipSync(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer)
}
function deflateRaw(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback)
}
function deflateRawSync(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer)
}
function unzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new Unzip(opts), buffer, callback)
}
function unzipSync(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer)
}
function inflate2(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new Inflate(opts), buffer, callback)
}
function inflateSync(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer)
}
function gunzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback)
}
function gunzipSync(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer)
}
function inflateRaw(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts
    opts = {}
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback)
}
function inflateRawSync(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer)
}
function zlibBuffer(engine, buffer, callback) {
  var buffers = []
  var nread = 0
  engine.on("error", onError2)
  engine.on("end", onEnd)
  engine.end(buffer)
  flow2()
  function flow2() {
    var chunk
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk)
      nread += chunk.length
    }
    engine.once("readable", flow2)
  }
  function onError2(err2) {
    engine.removeListener("end", onEnd)
    engine.removeListener("readable", flow2)
    callback(err2)
  }
  function onEnd() {
    var buf = Buffer2.concat(buffers, nread)
    buffers = []
    callback(null, buf)
    engine.close()
  }
}
function zlibBufferSync(engine, buffer) {
  if (typeof buffer === "string")
    buffer = new Buffer2(buffer)
  if (!Buffer2.isBuffer(buffer))
    throw new TypeError("Not a string or buffer")
  var flushFlag = binding3.Z_FINISH
  return engine._processChunk(buffer, flushFlag)
}
function Deflate(opts) {
  if (!(this instanceof Deflate))
    return new Deflate(opts)
  Zlib2.call(this, opts, binding3.DEFLATE)
}
function Inflate(opts) {
  if (!(this instanceof Inflate))
    return new Inflate(opts)
  Zlib2.call(this, opts, binding3.INFLATE)
}
function Gzip(opts) {
  if (!(this instanceof Gzip))
    return new Gzip(opts)
  Zlib2.call(this, opts, binding3.GZIP)
}
function Gunzip(opts) {
  if (!(this instanceof Gunzip))
    return new Gunzip(opts)
  Zlib2.call(this, opts, binding3.GUNZIP)
}
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw))
    return new DeflateRaw(opts)
  Zlib2.call(this, opts, binding3.DEFLATERAW)
}
function InflateRaw(opts) {
  if (!(this instanceof InflateRaw))
    return new InflateRaw(opts)
  Zlib2.call(this, opts, binding3.INFLATERAW)
}
function Unzip(opts) {
  if (!(this instanceof Unzip))
    return new Unzip(opts)
  Zlib2.call(this, opts, binding3.UNZIP)
}
function Zlib2(opts, mode) {
  this._opts = opts = opts || {}
  this._chunkSize = opts.chunkSize || binding3.Z_DEFAULT_CHUNK
  Transform.call(this, opts)
  if (opts.flush) {
    if (opts.flush !== binding3.Z_NO_FLUSH && opts.flush !== binding3.Z_PARTIAL_FLUSH && opts.flush !== binding3.Z_SYNC_FLUSH && opts.flush !== binding3.Z_FULL_FLUSH && opts.flush !== binding3.Z_FINISH && opts.flush !== binding3.Z_BLOCK) {
      throw new Error("Invalid flush flag: " + opts.flush)
    }
  }
  this._flushFlag = opts.flush || binding3.Z_NO_FLUSH
  if (opts.chunkSize) {
    if (opts.chunkSize < binding3.Z_MIN_CHUNK || opts.chunkSize > binding3.Z_MAX_CHUNK) {
      throw new Error("Invalid chunk size: " + opts.chunkSize)
    }
  }
  if (opts.windowBits) {
    if (opts.windowBits < binding3.Z_MIN_WINDOWBITS || opts.windowBits > binding3.Z_MAX_WINDOWBITS) {
      throw new Error("Invalid windowBits: " + opts.windowBits)
    }
  }
  if (opts.level) {
    if (opts.level < binding3.Z_MIN_LEVEL || opts.level > binding3.Z_MAX_LEVEL) {
      throw new Error("Invalid compression level: " + opts.level)
    }
  }
  if (opts.memLevel) {
    if (opts.memLevel < binding3.Z_MIN_MEMLEVEL || opts.memLevel > binding3.Z_MAX_MEMLEVEL) {
      throw new Error("Invalid memLevel: " + opts.memLevel)
    }
  }
  if (opts.strategy) {
    if (opts.strategy != binding3.Z_FILTERED && opts.strategy != binding3.Z_HUFFMAN_ONLY && opts.strategy != binding3.Z_RLE && opts.strategy != binding3.Z_FIXED && opts.strategy != binding3.Z_DEFAULT_STRATEGY) {
      throw new Error("Invalid strategy: " + opts.strategy)
    }
  }
  if (opts.dictionary) {
    if (!Buffer2.isBuffer(opts.dictionary)) {
      throw new Error("Invalid dictionary: it should be a Buffer instance")
    }
  }
  this._binding = new binding3.Zlib(mode)
  var self = this
  this._hadError = false
  this._binding.onerror = function (message, errno) {
    self._binding = null
    self._hadError = true
    var error2 = new Error(message)
    error2.errno = errno
    error2.code = binding3.codes[errno]
    self.emit("error", error2)
  }
  var level = binding3.Z_DEFAULT_COMPRESSION
  if (typeof opts.level === "number")
    level = opts.level
  var strategy = binding3.Z_DEFAULT_STRATEGY
  if (typeof opts.strategy === "number")
    strategy = opts.strategy
  this._binding.init(
    opts.windowBits || binding3.Z_DEFAULT_WINDOWBITS,
    level,
    opts.memLevel || binding3.Z_DEFAULT_MEMLEVEL,
    strategy,
    opts.dictionary
  )
  this._buffer = new Buffer2(this._chunkSize)
  this._offset = 0
  this._closed = false
  this._level = level
  this._strategy = strategy
  this.once("end", this.close)
}
var binding3, codes, zlib_default
var init_zlib = __esm({
  "node-modules-polyfills:zlib"() {
    init_process()
    init_buffer()
    init_stream()
    init_binding()
    init_util()
    binding3 = {}
    Object.keys(binding_exports).forEach(function (key) {
      binding3[key] = binding_exports[key]
    })
    binding3.Z_MIN_WINDOWBITS = 8
    binding3.Z_MAX_WINDOWBITS = 15
    binding3.Z_DEFAULT_WINDOWBITS = 15
    binding3.Z_MIN_CHUNK = 64
    binding3.Z_MAX_CHUNK = Infinity
    binding3.Z_DEFAULT_CHUNK = 16 * 1024
    binding3.Z_MIN_MEMLEVEL = 1
    binding3.Z_MAX_MEMLEVEL = 9
    binding3.Z_DEFAULT_MEMLEVEL = 8
    binding3.Z_MIN_LEVEL = -1
    binding3.Z_MAX_LEVEL = 9
    binding3.Z_DEFAULT_LEVEL = binding3.Z_DEFAULT_COMPRESSION
    codes = {
      Z_OK: binding3.Z_OK,
      Z_STREAM_END: binding3.Z_STREAM_END,
      Z_NEED_DICT: binding3.Z_NEED_DICT,
      Z_ERRNO: binding3.Z_ERRNO,
      Z_STREAM_ERROR: binding3.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding3.Z_DATA_ERROR,
      Z_MEM_ERROR: binding3.Z_MEM_ERROR,
      Z_BUF_ERROR: binding3.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding3.Z_VERSION_ERROR
    }
    Object.keys(codes).forEach(function (k) {
      codes[codes[k]] = k
    })
    inherits_default(Zlib2, Transform)
    Zlib2.prototype.params = function (level, strategy, callback) {
      if (level < binding3.Z_MIN_LEVEL || level > binding3.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level)
      }
      if (strategy != binding3.Z_FILTERED && strategy != binding3.Z_HUFFMAN_ONLY && strategy != binding3.Z_RLE && strategy != binding3.Z_FIXED && strategy != binding3.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy)
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self = this
        this.flush(binding3.Z_SYNC_FLUSH, function () {
          self._binding.params(level, strategy)
          if (!self._hadError) {
            self._level = level
            self._strategy = strategy
            if (callback)
              callback()
          }
        })
      } else {
        process.nextTick(callback)
      }
    }
    Zlib2.prototype.reset = function () {
      return this._binding.reset()
    }
    Zlib2.prototype._flush = function (callback) {
      this._transform(new Buffer2(0), "", callback)
    }
    Zlib2.prototype.flush = function (kind, callback) {
      var ws = this._writableState
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind
        kind = binding3.Z_FULL_FLUSH
      }
      if (ws.ended) {
        if (callback)
          process.nextTick(callback)
      } else if (ws.ending) {
        if (callback)
          this.once("end", callback)
      } else if (ws.needDrain) {
        var self = this
        this.once("drain", function () {
          self.flush(callback)
        })
      } else {
        this._flushFlag = kind
        this.write(new Buffer2(0), "", callback)
      }
    }
    Zlib2.prototype.close = function (callback) {
      if (callback)
        process.nextTick(callback)
      if (this._closed)
        return
      this._closed = true
      this._binding.close()
      var self = this
      process.nextTick(function () {
        self.emit("close")
      })
    }
    Zlib2.prototype._transform = function (chunk, encoding, cb) {
      var flushFlag
      var ws = this._writableState
      var ending = ws.ending || ws.ended
      var last = ending && (!chunk || ws.length === chunk.length)
      if (!chunk === null && !Buffer2.isBuffer(chunk))
        return cb(new Error("invalid input"))
      if (last)
        flushFlag = binding3.Z_FINISH
      else {
        flushFlag = this._flushFlag
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding3.Z_NO_FLUSH
        }
      }
      this._processChunk(chunk, flushFlag, cb)
    }
    Zlib2.prototype._processChunk = function (chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length
      var availOutBefore = this._chunkSize - this._offset
      var inOff = 0
      var self = this
      var async = typeof cb === "function"
      if (!async) {
        var buffers = []
        var nread = 0
        var error2
        this.on("error", function (er) {
          error2 = er
        })
        do {
          var res = this._binding.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          )
        } while (!this._hadError && callback(res[0], res[1]))
        if (this._hadError) {
          throw error2
        }
        var buf = Buffer2.concat(buffers, nread)
        this.close()
        return buf
      }
      var req = this._binding.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      )
      req.buffer = chunk
      req.callback = callback
      function callback(availInAfter, availOutAfter) {
        if (self._hadError)
          return
        var have = availOutBefore - availOutAfter
        assert2(have >= 0, "have should not go down")
        if (have > 0) {
          var out = self._buffer.slice(self._offset, self._offset + have)
          self._offset += have
          if (async) {
            self.push(out)
          } else {
            buffers.push(out)
            nread += out.length
          }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
          availOutBefore = self._chunkSize
          self._offset = 0
          self._buffer = new Buffer2(self._chunkSize)
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter
          availInBefore = availInAfter
          if (!async)
            return true
          var newReq = self._binding.write(
            flushFlag,
            chunk,
            inOff,
            availInBefore,
            self._buffer,
            self._offset,
            self._chunkSize
          )
          newReq.callback = callback
          newReq.buffer = chunk
          return
        }
        if (!async)
          return false
        cb()
      }
    }
    inherits_default(Deflate, Zlib2)
    inherits_default(Inflate, Zlib2)
    inherits_default(Gzip, Zlib2)
    inherits_default(Gunzip, Zlib2)
    inherits_default(DeflateRaw, Zlib2)
    inherits_default(InflateRaw, Zlib2)
    inherits_default(Unzip, Zlib2)
    zlib_default = {
      codes,
      createDeflate,
      createInflate,
      createDeflateRaw,
      createInflateRaw,
      createGzip,
      createGunzip,
      createUnzip,
      deflate: deflate2,
      deflateSync,
      gzip,
      gzipSync,
      deflateRaw,
      deflateRawSync,
      unzip,
      unzipSync,
      inflate: inflate2,
      inflateSync,
      gunzip,
      gunzipSync,
      inflateRaw,
      inflateRawSync,
      Deflate,
      Inflate,
      Gzip,
      Gunzip,
      DeflateRaw,
      InflateRaw,
      Unzip,
      Zlib: Zlib2
    }
  }
})

// node-modules-polyfills-commonjs:zlib
var require_zlib = __commonJS({
  "node-modules-polyfills-commonjs:zlib"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_zlib(), __toCommonJS(zlib_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = {
      "version": "0.26.1"
    }
  }
})

// node_modules/axios/lib/adapters/http.js
var require_http2 = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var settle2 = require_settle()
    var buildFullPath2 = require_buildFullPath()
    var buildURL2 = require_buildURL()
    var http = require_http()
    var https = require_https()
    var httpFollow = require_follow_redirects().http
    var httpsFollow = require_follow_redirects().https
    var url = require_url()
    var zlib = require_zlib()
    var VERSION = require_data().version
    var createError2 = require_createError()
    var enhanceError2 = require_enhanceError()
    var transitionalDefaults = require_transitional()
    var Cancel = require_Cancel()
    var isHttps = /https:?/
    function setProxy(options2, proxy, location) {
      options2.hostname = proxy.host
      options2.host = proxy.host
      options2.port = proxy.port
      options2.path = location
      if (proxy.auth) {
        var base64 = Buffer2.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64")
        options2.headers["Proxy-Authorization"] = "Basic " + base64
      }
      options2.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host
        setProxy(redirection, proxy, redirection.href)
      }
    }
    module2.exports = function httpAdapter(config4) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled
        function done2() {
          if (config4.cancelToken) {
            config4.cancelToken.unsubscribe(onCanceled)
          }
          if (config4.signal) {
            config4.signal.removeEventListener("abort", onCanceled)
          }
        }
        var resolve2 = function resolve3(value) {
          done2()
          resolvePromise(value)
        }
        var rejected = false
        var reject = function reject2(value) {
          done2()
          rejected = true
          rejectPromise(value)
        }
        var data = config4.data
        var headers = config4.headers
        var headerNames = {}
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name
        })
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]]
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION
        }
        if (data && !utils.isStream(data)) {
          if (Buffer2.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer2.from(new Uint8Array(data))
          } else if (utils.isString(data)) {
            data = Buffer2.from(data, "utf-8")
          } else {
            return reject(createError2(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config4
            ))
          }
          if (config4.maxBodyLength > -1 && data.length > config4.maxBodyLength) {
            return reject(createError2("Request body larger than maxBodyLength limit", config4))
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length
          }
        }
        var auth = void 0
        if (config4.auth) {
          var username = config4.auth.username || ""
          var password = config4.auth.password || ""
          auth = username + ":" + password
        }
        var fullPath = buildFullPath2(config4.baseURL, config4.url)
        var parsed = url.parse(fullPath)
        var protocol2 = parsed.protocol || "http:"
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":")
          var urlUsername = urlAuth[0] || ""
          var urlPassword = urlAuth[1] || ""
          auth = urlUsername + ":" + urlPassword
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization]
        }
        var isHttpsRequest = isHttps.test(protocol2)
        var agent = isHttpsRequest ? config4.httpsAgent : config4.httpAgent
        try {
          buildURL2(parsed.path, config4.params, config4.paramsSerializer).replace(/^\?/, "")
        } catch (err2) {
          var customErr = new Error(err2.message)
          customErr.config = config4
          customErr.url = config4.url
          customErr.exists = true
          reject(customErr)
        }
        var options2 = {
          path: buildURL2(parsed.path, config4.params, config4.paramsSerializer).replace(/^\?/, ""),
          method: config4.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config4.httpAgent, https: config4.httpsAgent },
          auth
        }
        if (config4.socketPath) {
          options2.socketPath = config4.socketPath
        } else {
          options2.hostname = parsed.hostname
          options2.port = parsed.port
        }
        var proxy = config4.proxy
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol2.slice(0, -1) + "_proxy"
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()]
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl)
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY
            var shouldProxy = true
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim()
              })
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false
                }
                if (proxyElement === "*") {
                  return true
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true
                }
                return parsed.hostname === proxyElement
              })
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              }
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":")
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                }
              }
            }
          }
        }
        if (proxy) {
          options2.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "")
          setProxy(options2, proxy, protocol2 + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options2.path)
        }
        var transport
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true)
        if (config4.transport) {
          transport = config4.transport
        } else if (config4.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http
        } else {
          if (config4.maxRedirects) {
            options2.maxRedirects = config4.maxRedirects
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow
        }
        if (config4.maxBodyLength > -1) {
          options2.maxBodyLength = config4.maxBodyLength
        }
        if (config4.insecureHTTPParser) {
          options2.insecureHTTPParser = config4.insecureHTTPParser
        }
        var req = transport.request(options2, function handleResponse(res) {
          if (req.aborted)
            return
          var stream = res
          var lastRequest = res.req || req
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config4.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip())
                delete res.headers["content-encoding"]
                break
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config4,
            request: lastRequest
          }
          if (config4.responseType === "stream") {
            response.data = stream
            settle2(resolve2, reject, response)
          } else {
            var responseBuffer = []
            var totalResponseBytes = 0
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk)
              totalResponseBytes += chunk.length
              if (config4.maxContentLength > -1 && totalResponseBytes > config4.maxContentLength) {
                rejected = true
                stream.destroy()
                reject(createError2(
                  "maxContentLength size of " + config4.maxContentLength + " exceeded",
                  config4,
                  null,
                  lastRequest
                ))
              }
            })
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return
              }
              stream.destroy()
              reject(createError2("error request aborted", config4, "ERR_REQUEST_ABORTED", lastRequest))
            })
            stream.on("error", function handleStreamError(err2) {
              if (req.aborted)
                return
              reject(enhanceError2(err2, config4, null, lastRequest))
            })
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer2.concat(responseBuffer)
                if (config4.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config4.responseEncoding)
                  if (!config4.responseEncoding || config4.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData)
                  }
                }
                response.data = responseData
              } catch (err2) {
                reject(enhanceError2(err2, config4, err2.code, response.request, response))
              }
              settle2(resolve2, reject, response)
            })
          }
        })
        req.on("error", function handleRequestError(err2) {
          if (req.aborted && err2.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return
          reject(enhanceError2(err2, config4, null, req))
        })
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60)
        })
        if (config4.timeout) {
          var timeout = parseInt(config4.timeout, 10)
          if (isNaN(timeout)) {
            reject(createError2(
              "error trying to parse `config.timeout` to int",
              config4,
              "ERR_PARSE_TIMEOUT",
              req
            ))
            return
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort()
            var timeoutErrorMessage = ""
            if (config4.timeoutErrorMessage) {
              timeoutErrorMessage = config4.timeoutErrorMessage
            } else {
              timeoutErrorMessage = "timeout of " + config4.timeout + "ms exceeded"
            }
            var transitional = config4.transitional || transitionalDefaults
            reject(createError2(
              timeoutErrorMessage,
              config4,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ))
          })
        }
        if (config4.cancelToken || config4.signal) {
          onCanceled = function (cancel) {
            if (req.aborted)
              return
            req.abort()
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel)
          }
          config4.cancelToken && config4.cancelToken.subscribe(onCanceled)
          if (config4.signal) {
            config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled)
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err2) {
            reject(enhanceError2(err2, config4, null, req))
          }).pipe(req)
        } else {
          req.end(data)
        }
      })
    }
  }
})

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var normalizeHeaderName = require_normalizeHeaderName()
    var enhanceError2 = require_enhanceError()
    var transitionalDefaults = require_transitional()
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    }
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value
      }
    }
    function getDefaultAdapter() {
      var adapter
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr()
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http2()
      }
      return adapter
    }
    function stringifySafely(rawValue, parser2, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser2 || JSON.parse)(rawValue)
          return utils.trim(rawValue)
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue)
    }
    var defaults2 = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept")
        normalizeHeaderName(headers, "Content-Type")
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8")
          return data.toString()
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json")
          return stringifySafely(data)
        }
        return data
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults2.transitional
        var silentJSONParsing = transitional && transitional.silentJSONParsing
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json"
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data)
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError2(e, this, "E_JSON_PARSE")
              }
              throw e
            }
          }
        }
        return data
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status2) {
        return status2 >= 200 && status2 < 300
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    }
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults2.headers[method] = {}
    })
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE)
    })
    module2.exports = defaults2
  }
})

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var defaults2 = require_defaults()
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults2
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers)
      })
      return data
    }
  }
})

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__)
    }
  }
})

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var transformData = require_transformData()
    var isCancel = require_isCancel()
    var defaults2 = require_defaults()
    var Cancel = require_Cancel()
    function throwIfCancellationRequested(config4) {
      if (config4.cancelToken) {
        config4.cancelToken.throwIfRequested()
      }
      if (config4.signal && config4.signal.aborted) {
        throw new Cancel("canceled")
      }
    }
    module2.exports = function dispatchRequest(config4) {
      throwIfCancellationRequested(config4)
      config4.headers = config4.headers || {}
      config4.data = transformData.call(
        config4,
        config4.data,
        config4.headers,
        config4.transformRequest
      )
      config4.headers = utils.merge(
        config4.headers.common || {},
        config4.headers[config4.method] || {},
        config4.headers
      )
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config4.headers[method]
        }
      )
      var adapter = config4.adapter || defaults2.adapter
      return adapter(config4).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config4)
        response.data = transformData.call(
          config4,
          response.data,
          response.headers,
          config4.transformResponse
        )
        return response
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config4)
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config4,
              reason.response.data,
              reason.response.headers,
              config4.transformResponse
            )
          }
        }
        return Promise.reject(reason)
      })
    }
  }
})

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    module2.exports = function mergeConfig(config1, config22) {
      config22 = config22 || {}
      var config4 = {}
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source)
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source)
        } else if (utils.isArray(source)) {
          return source.slice()
        }
        return source
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(config1[prop], config22[prop])
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop])
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop])
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop])
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop])
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config22) {
          return getMergedValue(config1[prop], config22[prop])
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop])
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      }
      utils.forEach(Object.keys(config1).concat(Object.keys(config22)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties
        var configValue = merge(prop)
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config4[prop] = configValue)
      })
      return config4
    }
  }
})

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var VERSION = require_data().version
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function (type2, i) {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2
      }
    })
    var deprecatedWarnings = {}
    validators.transitional = function transitional(validator, version5, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "")
      }
      return function (value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version5 ? " in " + version5 : "")))
        }
        if (version5 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version5 + " and will be removed in the near future"
            )
          )
        }
        return validator ? validator(value, opt, opts) : true
      }
    }
    function assertOptions(options2, schema, allowUnknown) {
      if (typeof options2 !== "object") {
        throw new TypeError("options must be an object")
      }
      var keys2 = Object.keys(options2)
      var i = keys2.length
      while (i-- > 0) {
        var opt = keys2[i]
        var validator = schema[opt]
        if (validator) {
          var value = options2[opt]
          var result = value === void 0 || validator(value, opt, options2)
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result)
          }
          continue
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt)
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    }
  }
})

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var buildURL2 = require_buildURL()
    var InterceptorManager = require_InterceptorManager()
    var dispatchRequest = require_dispatchRequest()
    var mergeConfig = require_mergeConfig()
    var validator = require_validator()
    var validators = validator.validators
    function Axios(instanceConfig) {
      this.defaults = instanceConfig
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      }
    }
    Axios.prototype.request = function request3(configOrUrl, config4) {
      if (typeof configOrUrl === "string") {
        config4 = config4 || {}
        config4.url = configOrUrl
      } else {
        config4 = configOrUrl || {}
      }
      config4 = mergeConfig(this.defaults, config4)
      if (config4.method) {
        config4.method = config4.method.toLowerCase()
      } else if (this.defaults.method) {
        config4.method = this.defaults.method.toLowerCase()
      } else {
        config4.method = "get"
      }
      var transitional = config4.transitional
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false)
      }
      var requestInterceptorChain = []
      var synchronousRequestInterceptors = true
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config4) === false) {
          return
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected)
      })
      var responseInterceptorChain = []
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected)
      })
      var promise
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0]
        Array.prototype.unshift.apply(chain, requestInterceptorChain)
        chain = chain.concat(responseInterceptorChain)
        promise = Promise.resolve(config4)
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift())
        }
        return promise
      }
      var newConfig = config4
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift()
        var onRejected = requestInterceptorChain.shift()
        try {
          newConfig = onFulfilled(newConfig)
        } catch (error2) {
          onRejected(error2)
          break
        }
      }
      try {
        promise = dispatchRequest(newConfig)
      } catch (error2) {
        return Promise.reject(error2)
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift())
      }
      return promise
    }
    Axios.prototype.getUri = function getUri(config4) {
      config4 = mergeConfig(this.defaults, config4)
      return buildURL2(config4.url, config4.params, config4.paramsSerializer).replace(/^\?/, "")
    }
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function (url, config4) {
        return this.request(mergeConfig(config4 || {}, {
          method,
          url,
          data: (config4 || {}).data
        }))
      }
    })
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function (url, data, config4) {
        return this.request(mergeConfig(config4 || {}, {
          method,
          url,
          data
        }))
      }
    })
    module2.exports = Axios
  }
})

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var Cancel = require_Cancel()
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.")
      }
      var resolvePromise
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2
      })
      var token = this
      this.promise.then(function (cancel) {
        if (!token._listeners)
          return
        var i
        var l = token._listeners.length
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel)
        }
        token._listeners = null
      })
      this.promise.then = function (onfulfilled) {
        var _resolve
        var promise = new Promise(function (resolve2) {
          token.subscribe(resolve2)
          _resolve = resolve2
        }).then(onfulfilled)
        promise.cancel = function reject() {
          token.unsubscribe(_resolve)
        }
        return promise
      }
      executor(function cancel(message) {
        if (token.reason) {
          return
        }
        token.reason = new Cancel(message)
        resolvePromise(token.reason)
      })
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason
      }
    }
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason)
        return
      }
      if (this._listeners) {
        this._listeners.push(listener)
      } else {
        this._listeners = [listener]
      }
    }
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return
      }
      var index = this._listeners.indexOf(listener)
      if (index !== -1) {
        this._listeners.splice(index, 1)
      }
    }
    CancelToken.source = function source() {
      var cancel
      var token = new CancelToken(function executor(c) {
        cancel = c
      })
      return {
        token,
        cancel
      }
    }
    module2.exports = CancelToken
  }
})

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports = function spread(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr)
      }
    }
  }
})

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true
    }
  }
})

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var utils = require_utils()
    var bind = require_bind()
    var Axios = require_Axios()
    var mergeConfig = require_mergeConfig()
    var defaults2 = require_defaults()
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig)
      var instance = bind(Axios.prototype.request, context)
      utils.extend(instance, Axios.prototype, context)
      utils.extend(instance, context)
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig))
      }
      return instance
    }
    var axios2 = createInstance(defaults2)
    axios2.Axios = Axios
    axios2.Cancel = require_Cancel()
    axios2.CancelToken = require_CancelToken()
    axios2.isCancel = require_isCancel()
    axios2.VERSION = require_data().version
    axios2.all = function all(promises) {
      return Promise.all(promises)
    }
    axios2.spread = require_spread()
    axios2.isAxiosError = require_isAxiosError()
    module2.exports = axios2
    module2.exports.default = axios2
  }
})

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = require_axios()
  }
})

// node_modules/openai/dist/base.js
var require_base = __commonJS({
  "node_modules/openai/dist/base.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0
    var axios_1 = require_axios2()
    exports.BASE_PATH = "https://api.openai.com/v1".replace(/\/+$/, "")
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    }
    var BaseAPI = class {
      constructor(configuration, basePath = exports.BASE_PATH, axios2 = axios_1.default) {
        this.basePath = basePath
        this.axios = axios2
        if (configuration) {
          this.configuration = configuration
          this.basePath = configuration.basePath || this.basePath
        }
      }
    }
    exports.BaseAPI = BaseAPI
    var RequiredError = class extends Error {
      constructor(field, msg) {
        super(msg)
        this.field = field
        this.name = "RequiredError"
      }
    }
    exports.RequiredError = RequiredError
  }
})

// node_modules/openai/dist/common.js
var require_common2 = __commonJS({
  "node_modules/openai/dist/common.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __awaiter = exports && exports.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve2) {
          resolve2(value)
        })
      }
      return new (P || (P = Promise))(function (resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value))
          } catch (e) {
            reject(e)
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value))
          } catch (e) {
            reject(e)
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next())
      })
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0
    var base_1 = require_base()
    exports.DUMMY_BASE_URL = "https://example.com"
    exports.assertParamExists = function (functionName, paramName, paramValue) {
      if (paramValue === null || paramValue === void 0) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`)
      }
    }
    exports.setApiKeyToObject = function (object, keyParamName, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
          const localVarApiKeyValue = typeof configuration.apiKey === "function" ? yield configuration.apiKey(keyParamName) : yield configuration.apiKey
          object[keyParamName] = localVarApiKeyValue
        }
      })
    }
    exports.setBasicAuthToObject = function (object, configuration) {
      if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password }
      }
    }
    exports.setBearerAuthToObject = function (object, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
          const accessToken = typeof configuration.accessToken === "function" ? yield configuration.accessToken() : yield configuration.accessToken
          object["Authorization"] = "Bearer " + accessToken
        }
      })
    }
    exports.setOAuthToObject = function (object, name, scopes, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
          const localVarAccessTokenValue = typeof configuration.accessToken === "function" ? yield configuration.accessToken(name, scopes) : yield configuration.accessToken
          object["Authorization"] = "Bearer " + localVarAccessTokenValue
        }
      })
    }
    function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
      if (parameter == null)
        return
      if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
          parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key))
        } else {
          Object.keys(parameter).forEach((currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`))
        }
      } else {
        if (urlSearchParams.has(key)) {
          urlSearchParams.append(key, parameter)
        } else {
          urlSearchParams.set(key, parameter)
        }
      }
    }
    exports.setSearchParams = function (url, ...objects) {
      const searchParams = new URLSearchParams(url.search)
      setFlattenedQueryParams(searchParams, objects)
      url.search = searchParams.toString()
    }
    exports.serializeDataIfNeeded = function (value, requestOptions, configuration) {
      const nonString = typeof value !== "string"
      const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString
      return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || ""
    }
    exports.toPathString = function (url) {
      return url.pathname + url.search + url.hash
    }
    exports.createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
      return (axios2 = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url })
        return axios2.request(axiosRequestArgs)
      }
    }
  }
})

// node_modules/openai/dist/api.js
var require_api = __commonJS({
  "node_modules/openai/dist/api.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __awaiter = exports && exports.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve2) {
          resolve2(value)
        })
      }
      return new (P || (P = Promise))(function (resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value))
          } catch (e) {
            reject(e)
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value))
          } catch (e) {
            reject(e)
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next())
      })
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.OpenAIApi = exports.OpenAIApiFactory = exports.OpenAIApiFp = exports.OpenAIApiAxiosParamCreator = exports.CreateImageRequestResponseFormatEnum = exports.CreateImageRequestSizeEnum = exports.ChatCompletionResponseMessageRoleEnum = exports.ChatCompletionRequestMessageRoleEnum = void 0
    var axios_1 = require_axios2()
    var common_1 = require_common2()
    var base_1 = require_base()
    exports.ChatCompletionRequestMessageRoleEnum = {
      System: "system",
      User: "user",
      Assistant: "assistant"
    }
    exports.ChatCompletionResponseMessageRoleEnum = {
      System: "system",
      User: "user",
      Assistant: "assistant"
    }
    exports.CreateImageRequestSizeEnum = {
      _256x256: "256x256",
      _512x512: "512x512",
      _1024x1024: "1024x1024"
    }
    exports.CreateImageRequestResponseFormatEnum = {
      Url: "url",
      B64Json: "b64_json"
    }
    exports.OpenAIApiAxiosParamCreator = function (configuration) {
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune: (fineTuneId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("cancelFineTune", "fineTuneId", fineTuneId)
          const localVarPath = `/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer: (createAnswerRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createAnswer", "createAnswerRequest", createAnswerRequest)
          const localVarPath = `/answers`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createAnswerRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates a completion for the chat message
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion: (createChatCompletionRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createChatCompletion", "createChatCompletionRequest", createChatCompletionRequest)
          const localVarPath = `/chat/completions`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createChatCompletionRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification: (createClassificationRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createClassification", "createClassificationRequest", createClassificationRequest)
          const localVarPath = `/classifications`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createClassificationRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion: (createCompletionRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createCompletion", "createCompletionRequest", createCompletionRequest)
          const localVarPath = `/completions`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit: (createEditRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createEdit", "createEditRequest", createEditRequest)
          const localVarPath = `/edits`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEditRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding: (createEmbeddingRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createEmbedding", "createEmbeddingRequest", createEmbeddingRequest)
          const localVarPath = `/embeddings`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: (file, purpose, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createFile", "file", file)
          common_1.assertParamExists("createFile", "purpose", purpose)
          const localVarPath = `/files`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)()
          if (file !== void 0) {
            localVarFormParams.append("file", file)
          }
          if (purpose !== void 0) {
            localVarFormParams.append("purpose", purpose)
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = localVarFormParams
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune: (createFineTuneRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createFineTune", "createFineTuneRequest", createFineTuneRequest)
          const localVarPath = `/fine-tunes`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createFineTuneRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: (createImageRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImage", "createImageRequest", createImageRequest)
          const localVarPath = `/images/generations`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit: (image, prompt, mask, n, size, responseFormat, user, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImageEdit", "image", image)
          common_1.assertParamExists("createImageEdit", "prompt", prompt)
          const localVarPath = `/images/edits`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)()
          if (image !== void 0) {
            localVarFormParams.append("image", image)
          }
          if (mask !== void 0) {
            localVarFormParams.append("mask", mask)
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt)
          }
          if (n !== void 0) {
            localVarFormParams.append("n", n)
          }
          if (size !== void 0) {
            localVarFormParams.append("size", size)
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat)
          }
          if (user !== void 0) {
            localVarFormParams.append("user", user)
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = localVarFormParams
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation: (image, n, size, responseFormat, user, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImageVariation", "image", image)
          const localVarPath = `/images/variations`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)()
          if (image !== void 0) {
            localVarFormParams.append("image", image)
          }
          if (n !== void 0) {
            localVarFormParams.append("n", n)
          }
          if (size !== void 0) {
            localVarFormParams.append("size", size)
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat)
          }
          if (user !== void 0) {
            localVarFormParams.append("user", user)
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = localVarFormParams
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration: (createModerationRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createModeration", "createModerationRequest", createModerationRequest)
          const localVarPath = `/moderations`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch: (engineId, createSearchRequest, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createSearch", "engineId", engineId)
          common_1.assertParamExists("createSearch", "createSearchRequest", createSearchRequest)
          const localVarPath = `/engines/{engine_id}/search`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          localVarHeaderParameter["Content-Type"] = "application/json"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createSearchRequest, localVarRequestOptions, configuration)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription: (file, model, prompt, responseFormat, temperature, language, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createTranscription", "file", file)
          common_1.assertParamExists("createTranscription", "model", model)
          const localVarPath = `/audio/transcriptions`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)()
          if (file !== void 0) {
            localVarFormParams.append("file", file)
          }
          if (model !== void 0) {
            localVarFormParams.append("model", model)
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt)
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat)
          }
          if (temperature !== void 0) {
            localVarFormParams.append("temperature", temperature)
          }
          if (language !== void 0) {
            localVarFormParams.append("language", language)
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = localVarFormParams
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file to translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation: (file, model, prompt, responseFormat, temperature, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createTranslation", "file", file)
          common_1.assertParamExists("createTranslation", "model", model)
          const localVarPath = `/audio/translations`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)()
          if (file !== void 0) {
            localVarFormParams.append("file", file)
          }
          if (model !== void 0) {
            localVarFormParams.append("model", model)
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt)
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat)
          }
          if (temperature !== void 0) {
            localVarFormParams.append("temperature", temperature)
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data"
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options2.headers)
          localVarRequestOptions.data = localVarFormParams
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: (fileId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("deleteFile", "fileId", fileId)
          const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: (model, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("deleteModel", "model", model)
          const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: (fileId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("downloadFile", "fileId", fileId)
          const localVarPath = `/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines: (options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/engines`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: (options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/files`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents: (fineTuneId, stream, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("listFineTuneEvents", "fineTuneId", fineTuneId)
          const localVarPath = `/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          if (stream !== void 0) {
            localVarQueryParameter["stream"] = stream
          }
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes: (options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/fine-tunes`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: (options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/models`
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine: (engineId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveEngine", "engineId", engineId)
          const localVarPath = `/engines/{engine_id}`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: (fileId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveFile", "fileId", fileId)
          const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune: (fineTuneId, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveFineTune", "fineTuneId", fineTuneId)
          const localVarPath = `/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        }),
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel: (model, options2 = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveModel", "model", model)
          const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)))
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL)
          let baseOptions
          if (configuration) {
            baseOptions = configuration.baseOptions
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options2)
          const localVarHeaderParameter = {}
          const localVarQueryParameter = {}
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter)
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options2.headers)
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          }
        })
      }
    }
    exports.OpenAIApiFp = function (configuration) {
      const localVarAxiosParamCreator = exports.OpenAIApiAxiosParamCreator(configuration)
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune(fineTuneId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelFineTune(fineTuneId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer(createAnswerRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createAnswer(createAnswerRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates a completion for the chat message
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createChatCompletion(createChatCompletionRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification(createClassificationRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createClassification(createClassificationRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createCompletion(createCompletionRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit(createEditRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createEdit(createEditRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createEmbedding(createEmbeddingRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, purpose, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(file, purpose, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune(createFineTuneRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createFineTune(createFineTuneRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImage(createImageRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation(image, n, size, responseFormat, user, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageVariation(image, n, size, responseFormat, user, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createModeration(createModerationRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch(engineId, createSearchRequest, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createSearch(engineId, createSearchRequest, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription(file, model, prompt, responseFormat, temperature, language, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranscription(file, model, prompt, responseFormat, temperature, language, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file to translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation(file, model, prompt, responseFormat, temperature, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranslation(file, model, prompt, responseFormat, temperature, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(fileId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(model, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteModel(model, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadFile(fileId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines(options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listEngines(options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFiles(options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents(fineTuneId, stream, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTuneEvents(fineTuneId, stream, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes(options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTunes(options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listModels(options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine(engineId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveEngine(engineId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(fileId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFile(fileId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune(fineTuneId, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFineTune(fineTuneId, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel(model, options2) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveModel(model, options2)
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)
          })
        }
      }
    }
    exports.OpenAIApiFactory = function (configuration, basePath, axios2) {
      const localVarFp = exports.OpenAIApiFp(configuration)
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune(fineTuneId, options2) {
          return localVarFp.cancelFineTune(fineTuneId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer(createAnswerRequest, options2) {
          return localVarFp.createAnswer(createAnswerRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates a completion for the chat message
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest, options2) {
          return localVarFp.createChatCompletion(createChatCompletionRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification(createClassificationRequest, options2) {
          return localVarFp.createClassification(createClassificationRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest, options2) {
          return localVarFp.createCompletion(createCompletionRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit(createEditRequest, options2) {
          return localVarFp.createEdit(createEditRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest, options2) {
          return localVarFp.createEmbedding(createEmbeddingRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, purpose, options2) {
          return localVarFp.createFile(file, purpose, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune(createFineTuneRequest, options2) {
          return localVarFp.createFineTune(createFineTuneRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageRequest, options2) {
          return localVarFp.createImage(createImageRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2) {
          return localVarFp.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation(image, n, size, responseFormat, user, options2) {
          return localVarFp.createImageVariation(image, n, size, responseFormat, user, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest, options2) {
          return localVarFp.createModeration(createModerationRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch(engineId, createSearchRequest, options2) {
          return localVarFp.createSearch(engineId, createSearchRequest, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription(file, model, prompt, responseFormat, temperature, language, options2) {
          return localVarFp.createTranscription(file, model, prompt, responseFormat, temperature, language, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file to translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation(file, model, prompt, responseFormat, temperature, options2) {
          return localVarFp.createTranslation(file, model, prompt, responseFormat, temperature, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options2) {
          return localVarFp.deleteFile(fileId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(model, options2) {
          return localVarFp.deleteModel(model, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId, options2) {
          return localVarFp.downloadFile(fileId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines(options2) {
          return localVarFp.listEngines(options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(options2) {
          return localVarFp.listFiles(options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents(fineTuneId, stream, options2) {
          return localVarFp.listFineTuneEvents(fineTuneId, stream, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes(options2) {
          return localVarFp.listFineTunes(options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(options2) {
          return localVarFp.listModels(options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine(engineId, options2) {
          return localVarFp.retrieveEngine(engineId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(fileId, options2) {
          return localVarFp.retrieveFile(fileId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune(fineTuneId, options2) {
          return localVarFp.retrieveFineTune(fineTuneId, options2).then((request3) => request3(axios2, basePath))
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel(model, options2) {
          return localVarFp.retrieveModel(model, options2).then((request3) => request3(axios2, basePath))
        }
      }
    }
    var OpenAIApi4 = class extends base_1.BaseAPI {
      /**
       *
       * @summary Immediately cancel a fine-tune job.
       * @param {string} fineTuneId The ID of the fine-tune job to cancel
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      cancelFineTune(fineTuneId, options2) {
        return exports.OpenAIApiFp(this.configuration).cancelFineTune(fineTuneId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
       * @param {CreateAnswerRequest} createAnswerRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createAnswer(createAnswerRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createAnswer(createAnswerRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates a completion for the chat message
       * @param {CreateChatCompletionRequest} createChatCompletionRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createChatCompletion(createChatCompletionRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createChatCompletion(createChatCompletionRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
       * @param {CreateClassificationRequest} createClassificationRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createClassification(createClassificationRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createClassification(createClassificationRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates a completion for the provided prompt and parameters
       * @param {CreateCompletionRequest} createCompletionRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createCompletion(createCompletionRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createCompletion(createCompletionRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates a new edit for the provided input, instruction, and parameters.
       * @param {CreateEditRequest} createEditRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createEdit(createEditRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createEdit(createEditRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates an embedding vector representing the input text.
       * @param {CreateEmbeddingRequest} createEmbeddingRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createEmbedding(createEmbeddingRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
       * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
       * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createFile(file, purpose, options2) {
        return exports.OpenAIApiFp(this.configuration).createFile(file, purpose, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
       * @param {CreateFineTuneRequest} createFineTuneRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createFineTune(createFineTuneRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createFineTune(createFineTuneRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates an image given a prompt.
       * @param {CreateImageRequest} createImageRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImage(createImageRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createImage(createImageRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates an edited or extended image given an original image and a prompt.
       * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
       * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
       * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
       * @param {number} [n] The number of images to generate. Must be between 1 and 10.
       * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
       * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
       * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2) {
        return exports.OpenAIApiFp(this.configuration).createImageEdit(image, prompt, mask, n, size, responseFormat, user, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Creates a variation of a given image.
       * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
       * @param {number} [n] The number of images to generate. Must be between 1 and 10.
       * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
       * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
       * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImageVariation(image, n, size, responseFormat, user, options2) {
        return exports.OpenAIApiFp(this.configuration).createImageVariation(image, n, size, responseFormat, user, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Classifies if text violates OpenAI\'s Content Policy
       * @param {CreateModerationRequest} createModerationRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createModeration(createModerationRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createModeration(createModerationRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
       * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
       * @param {CreateSearchRequest} createSearchRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createSearch(engineId, createSearchRequest, options2) {
        return exports.OpenAIApiFp(this.configuration).createSearch(engineId, createSearchRequest, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Transcribes audio into the input language.
       * @param {File} file The audio file to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
       * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
       * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
       * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
       * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
       * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createTranscription(file, model, prompt, responseFormat, temperature, language, options2) {
        return exports.OpenAIApiFp(this.configuration).createTranscription(file, model, prompt, responseFormat, temperature, language, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Translates audio into into English.
       * @param {File} file The audio file to translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
       * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
       * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
       * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
       * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createTranslation(file, model, prompt, responseFormat, temperature, options2) {
        return exports.OpenAIApiFp(this.configuration).createTranslation(file, model, prompt, responseFormat, temperature, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Delete a file.
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      deleteFile(fileId, options2) {
        return exports.OpenAIApiFp(this.configuration).deleteFile(fileId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
       * @param {string} model The model to delete
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      deleteModel(model, options2) {
        return exports.OpenAIApiFp(this.configuration).deleteModel(model, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Returns the contents of the specified file
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      downloadFile(fileId, options2) {
        return exports.OpenAIApiFp(this.configuration).downloadFile(fileId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listEngines(options2) {
        return exports.OpenAIApiFp(this.configuration).listEngines(options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Returns a list of files that belong to the user\'s organization.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFiles(options2) {
        return exports.OpenAIApiFp(this.configuration).listFiles(options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Get fine-grained status updates for a fine-tune job.
       * @param {string} fineTuneId The ID of the fine-tune job to get events for.
       * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFineTuneEvents(fineTuneId, stream, options2) {
        return exports.OpenAIApiFp(this.configuration).listFineTuneEvents(fineTuneId, stream, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary List your organization\'s fine-tuning jobs
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFineTunes(options2) {
        return exports.OpenAIApiFp(this.configuration).listFineTunes(options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listModels(options2) {
        return exports.OpenAIApiFp(this.configuration).listModels(options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
       * @param {string} engineId The ID of the engine to use for this request
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveEngine(engineId, options2) {
        return exports.OpenAIApiFp(this.configuration).retrieveEngine(engineId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Returns information about a specific file.
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveFile(fileId, options2) {
        return exports.OpenAIApiFp(this.configuration).retrieveFile(fileId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
       * @param {string} fineTuneId The ID of the fine-tune job
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveFineTune(fineTuneId, options2) {
        return exports.OpenAIApiFp(this.configuration).retrieveFineTune(fineTuneId, options2).then((request3) => request3(this.axios, this.basePath))
      }
      /**
       *
       * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
       * @param {string} model The ID of the model to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveModel(model, options2) {
        return exports.OpenAIApiFp(this.configuration).retrieveModel(model, options2).then((request3) => request3(this.axios, this.basePath))
      }
    }
    exports.OpenAIApi = OpenAIApi4
  }
})

// node_modules/openai/package.json
var require_package = __commonJS({
  "node_modules/openai/package.json"(exports, module2) {
    module2.exports = {
      name: "openai",
      version: "3.2.1",
      description: "Node.js library for the OpenAI API",
      repository: {
        type: "git",
        url: "git@github.com:openai/openai-node.git"
      },
      keywords: [
        "openai",
        "open",
        "ai",
        "gpt-3",
        "gpt3"
      ],
      author: "OpenAI",
      license: "MIT",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      scripts: {
        build: "tsc --outDir dist/"
      },
      dependencies: {
        axios: "^0.26.0",
        "form-data": "^4.0.0"
      },
      devDependencies: {
        "@types/node": "^12.11.5",
        typescript: "^3.6.4"
      }
    }
  }
})

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    init_process()
    init_buffer()
    var Stream2 = require_stream().Stream
    var util2 = require_util()
    module2.exports = DelayedStream
    function DelayedStream() {
      this.source = null
      this.dataSize = 0
      this.maxDataSize = 1024 * 1024
      this.pauseStream = true
      this._maxDataSizeExceeded = false
      this._released = false
      this._bufferedEvents = []
    }
    util2.inherits(DelayedStream, Stream2)
    DelayedStream.create = function (source, options2) {
      var delayedStream = new this()
      options2 = options2 || {}
      for (var option in options2) {
        delayedStream[option] = options2[option]
      }
      delayedStream.source = source
      var realEmit = source.emit
      source.emit = function () {
        delayedStream._handleEmit(arguments)
        return realEmit.apply(source, arguments)
      }
      source.on("error", function () {
      })
      if (delayedStream.pauseStream) {
        source.pause()
      }
      return delayedStream
    }
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function () {
        return this.source.readable
      }
    })
    DelayedStream.prototype.setEncoding = function () {
      return this.source.setEncoding.apply(this.source, arguments)
    }
    DelayedStream.prototype.resume = function () {
      if (!this._released) {
        this.release()
      }
      this.source.resume()
    }
    DelayedStream.prototype.pause = function () {
      this.source.pause()
    }
    DelayedStream.prototype.release = function () {
      this._released = true
      this._bufferedEvents.forEach(function (args) {
        this.emit.apply(this, args)
      }.bind(this))
      this._bufferedEvents = []
    }
    DelayedStream.prototype.pipe = function () {
      var r = Stream2.prototype.pipe.apply(this, arguments)
      this.resume()
      return r
    }
    DelayedStream.prototype._handleEmit = function (args) {
      if (this._released) {
        this.emit.apply(this, args)
        return
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length
        this._checkIfMaxDataSizeExceeded()
      }
      this._bufferedEvents.push(args)
    }
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
      if (this._maxDataSizeExceeded) {
        return
      }
      if (this.dataSize <= this.maxDataSize) {
        return
      }
      this._maxDataSizeExceeded = true
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded."
      this.emit("error", new Error(message))
    }
  }
})

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    init_process()
    init_buffer()
    var util2 = require_util()
    var Stream2 = require_stream().Stream
    var DelayedStream = require_delayed_stream()
    module2.exports = CombinedStream
    function CombinedStream() {
      this.writable = false
      this.readable = true
      this.dataSize = 0
      this.maxDataSize = 2 * 1024 * 1024
      this.pauseStreams = true
      this._released = false
      this._streams = []
      this._currentStream = null
      this._insideLoop = false
      this._pendingNext = false
    }
    util2.inherits(CombinedStream, Stream2)
    CombinedStream.create = function (options2) {
      var combinedStream = new this()
      options2 = options2 || {}
      for (var option in options2) {
        combinedStream[option] = options2[option]
      }
      return combinedStream
    }
    CombinedStream.isStreamLike = function (stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer2.isBuffer(stream)
    }
    CombinedStream.prototype.append = function (stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream)
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          })
          stream.on("data", this._checkDataSize.bind(this))
          stream = newStream
        }
        this._handleErrors(stream)
        if (this.pauseStreams) {
          stream.pause()
        }
      }
      this._streams.push(stream)
      return this
    }
    CombinedStream.prototype.pipe = function (dest, options2) {
      Stream2.prototype.pipe.call(this, dest, options2)
      this.resume()
      return dest
    }
    CombinedStream.prototype._getNext = function () {
      this._currentStream = null
      if (this._insideLoop) {
        this._pendingNext = true
        return
      }
      this._insideLoop = true
      try {
        do {
          this._pendingNext = false
          this._realGetNext()
        } while (this._pendingNext)
      } finally {
        this._insideLoop = false
      }
    }
    CombinedStream.prototype._realGetNext = function () {
      var stream = this._streams.shift()
      if (typeof stream == "undefined") {
        this.end()
        return
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream)
        return
      }
      var getStream = stream
      getStream(function (stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2)
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this))
          this._handleErrors(stream2)
        }
        this._pipeNext(stream2)
      }.bind(this))
    }
    CombinedStream.prototype._pipeNext = function (stream) {
      this._currentStream = stream
      var isStreamLike = CombinedStream.isStreamLike(stream)
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this))
        stream.pipe(this, { end: false })
        return
      }
      var value = stream
      this.write(value)
      this._getNext()
    }
    CombinedStream.prototype._handleErrors = function (stream) {
      var self = this
      stream.on("error", function (err2) {
        self._emitError(err2)
      })
    }
    CombinedStream.prototype.write = function (data) {
      this.emit("data", data)
    }
    CombinedStream.prototype.pause = function () {
      if (!this.pauseStreams) {
        return
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause()
      this.emit("pause")
    }
    CombinedStream.prototype.resume = function () {
      if (!this._released) {
        this._released = true
        this.writable = true
        this._getNext()
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume()
      this.emit("resume")
    }
    CombinedStream.prototype.end = function () {
      this._reset()
      this.emit("end")
    }
    CombinedStream.prototype.destroy = function () {
      this._reset()
      this.emit("close")
    }
    CombinedStream.prototype._reset = function () {
      this.writable = false
      this._streams = []
      this._currentStream = null
    }
    CombinedStream.prototype._checkDataSize = function () {
      this._updateDataSize()
      if (this.dataSize <= this.maxDataSize) {
        return
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded."
      this._emitError(new Error(message))
    }
    CombinedStream.prototype._updateDataSize = function () {
      this.dataSize = 0
      var self = this
      this._streams.forEach(function (stream) {
        if (!stream.dataSize) {
          return
        }
        self.dataSize += stream.dataSize
      })
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize
      }
    }
    CombinedStream.prototype._emitError = function (err2) {
      this._reset()
      this.emit("error", err2)
    }
  }
})

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    }
  }
})

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = require_db()
  }
})

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var db = require_mime_db()
    var extname2 = require_path().extname
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
    var TEXT_TYPE_REGEXP = /^text\//i
    exports.charset = charset
    exports.charsets = { lookup: charset }
    exports.contentType = contentType
    exports.extension = extension
    exports.extensions = /* @__PURE__ */ Object.create(null)
    exports.lookup = lookup3
    exports.types = /* @__PURE__ */ Object.create(null)
    populateMaps(exports.extensions, exports.types)
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2)
      var mime = match && db[match[1].toLowerCase()]
      if (mime && mime.charset) {
        return mime.charset
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8"
      }
      return false
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str
      if (!mime) {
        return false
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime)
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase()
      }
      return mime
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2)
      var exts = match && exports.extensions[match[1].toLowerCase()]
      if (!exts || !exts.length) {
        return false
      }
      return exts[0]
    }
    function lookup3(path) {
      if (!path || typeof path !== "string") {
        return false
      }
      var extension2 = extname2("x." + path).toLowerCase().substr(1)
      if (!extension2) {
        return false
      }
      return exports.types[extension2] || false
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"]
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2]
        var exts = mime.extensions
        if (!exts || !exts.length) {
          return
        }
        extensions[type2] = exts
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i]
          if (types[extension2]) {
            var from3 = preference.indexOf(db[types[extension2]].source)
            var to = preference.indexOf(mime.source)
            if (types[extension2] !== "application/octet-stream" && (from3 > to || from3 === to && types[extension2].substr(0, 12) === "application/")) {
              continue
            }
          }
          types[extension2] = type2
        }
      })
    }
  }
})

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = defer
    function defer(fn) {
      var nextTick3 = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null
      if (nextTick3) {
        nextTick3(fn)
      } else {
        setTimeout(fn, 0)
      }
    }
  }
})

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    init_process()
    init_buffer()
    var defer = require_defer()
    module2.exports = async
    function async(callback) {
      var isAsync2 = false
      defer(function () {
        isAsync2 = true
      })
      return function async_callback(err2, result) {
        if (isAsync2) {
          callback(err2, result)
        } else {
          defer(function nextTick_callback() {
            callback(err2, result)
          })
        }
      }
    }
  }
})

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = abort
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state))
      state.jobs = {}
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]()
      }
    }
  }
})

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    init_process()
    init_buffer()
    var async = require_async()
    var abort = require_abort()
    module2.exports = iterate
    function iterate(list2, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index
      state.jobs[key] = runJob(iterator, key, list2[key], function (error2, output) {
        if (!(key in state.jobs)) {
          return
        }
        delete state.jobs[key]
        if (error2) {
          abort(state)
        } else {
          state.results[key] = output
        }
        callback(error2, state.results)
      })
    }
    function runJob(iterator, key, item, callback) {
      var aborter
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback))
      } else {
        aborter = iterator(item, key, async(callback))
      }
      return aborter
    }
  }
})

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = state
    function state(list2, sortMethod) {
      var isNamedList = !Array.isArray(list2), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list2).length : list2.length
      }
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function (a, b) {
          return sortMethod(list2[a], list2[b])
        })
      }
      return initState
    }
  }
})

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    init_process()
    init_buffer()
    var abort = require_abort()
    var async = require_async()
    module2.exports = terminator
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return
      }
      this.index = this.size
      abort(this)
      async(callback)(null, this.results)
    }
  }
})

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    init_process()
    init_buffer()
    var iterate = require_iterate()
    var initState = require_state()
    var terminator = require_terminator()
    module2.exports = parallel
    function parallel(list2, iterator, callback) {
      var state = initState(list2)
      while (state.index < (state["keyedList"] || list2).length) {
        iterate(list2, iterator, state, function (error2, result) {
          if (error2) {
            callback(error2, result)
            return
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results)
            return
          }
        })
        state.index++
      }
      return terminator.bind(state, callback)
    }
  }
})

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    init_process()
    init_buffer()
    var iterate = require_iterate()
    var initState = require_state()
    var terminator = require_terminator()
    module2.exports = serialOrdered
    module2.exports.ascending = ascending
    module2.exports.descending = descending
    function serialOrdered(list2, iterator, sortMethod, callback) {
      var state = initState(list2, sortMethod)
      iterate(list2, iterator, state, function iteratorHandler(error2, result) {
        if (error2) {
          callback(error2, result)
          return
        }
        state.index++
        if (state.index < (state["keyedList"] || list2).length) {
          iterate(list2, iterator, state, iteratorHandler)
          return
        }
        callback(null, state.results)
      })
      return terminator.bind(state, callback)
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0
    }
    function descending(a, b) {
      return -1 * ascending(a, b)
    }
  }
})

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    init_process()
    init_buffer()
    var serialOrdered = require_serialOrdered()
    module2.exports = serial
    function serial(list2, iterator, callback) {
      return serialOrdered(list2, iterator, null, callback)
    }
  }
})

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    }
  }
})

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = function (dst, src) {
      Object.keys(src).forEach(function (prop) {
        dst[prop] = dst[prop] || src[prop]
      })
      return dst
    }
  }
})

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module2) {
    init_process()
    init_buffer()
    var CombinedStream = require_combined_stream()
    var util2 = require_util()
    var path = require_path()
    var http = require_http()
    var https = require_https()
    var parseUrl = require_url().parse
    var fs = require_fs()
    var Stream2 = require_stream().Stream
    var mime = require_mime_types()
    var asynckit = require_asynckit()
    var populate = require_populate()
    module2.exports = FormData2
    util2.inherits(FormData2, CombinedStream)
    function FormData2(options2) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options2)
      }
      this._overheadLength = 0
      this._valueLength = 0
      this._valuesToMeasure = []
      CombinedStream.call(this)
      options2 = options2 || {}
      for (var option in options2) {
        this[option] = options2[option]
      }
    }
    FormData2.LINE_BREAK = "\r\n"
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream"
    FormData2.prototype.append = function (field, value, options2) {
      options2 = options2 || {}
      if (typeof options2 == "string") {
        options2 = { filename: options2 }
      }
      var append = CombinedStream.prototype.append.bind(this)
      if (typeof value == "number") {
        value = "" + value
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."))
        return
      }
      var header = this._multiPartHeader(field, value, options2)
      var footer = this._multiPartFooter()
      append(header)
      append(value)
      append(footer)
      this._trackLength(header, value, options2)
    }
    FormData2.prototype._trackLength = function (header, value, options2) {
      var valueLength = 0
      if (options2.knownLength != null) {
        valueLength += +options2.knownLength
      } else if (Buffer2.isBuffer(value)) {
        valueLength = value.length
      } else if (typeof value === "string") {
        valueLength = Buffer2.byteLength(value)
      }
      this._valueLength += valueLength
      this._overheadLength += Buffer2.byteLength(header) + FormData2.LINE_BREAK.length
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream2)) {
        return
      }
      if (!options2.knownLength) {
        this._valuesToMeasure.push(value)
      }
    }
    FormData2.prototype._lengthRetriever = function (value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0))
        } else {
          fs.stat(value.path, function (err2, stat) {
            var fileSize
            if (err2) {
              callback(err2)
              return
            }
            fileSize = stat.size - (value.start ? value.start : 0)
            callback(null, fileSize)
          })
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"])
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function (response) {
          value.pause()
          callback(null, +response.headers["content-length"])
        })
        value.resume()
      } else {
        callback("Unknown stream")
      }
    }
    FormData2.prototype._multiPartHeader = function (field, value, options2) {
      if (typeof options2.header == "string") {
        return options2.header
      }
      var contentDisposition = this._getContentDisposition(value, options2)
      var contentType = this._getContentType(value, options2)
      var contents = ""
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      }
      if (typeof options2.header == "object") {
        populate(headers, options2.header)
      }
      var header
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue
        header = headers[prop]
        if (header == null) {
          continue
        }
        if (!Array.isArray(header)) {
          header = [header]
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK
    }
    FormData2.prototype._getContentDisposition = function (value, options2) {
      var filename, contentDisposition
      if (typeof options2.filepath === "string") {
        filename = path.normalize(options2.filepath).replace(/\\/g, "/")
      } else if (options2.filename || value.name || value.path) {
        filename = path.basename(options2.filename || value.name || value.path)
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "")
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"'
      }
      return contentDisposition
    }
    FormData2.prototype._getContentType = function (value, options2) {
      var contentType = options2.contentType
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name)
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path)
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"]
      }
      if (!contentType && (options2.filepath || options2.filename)) {
        contentType = mime.lookup(options2.filepath || options2.filename)
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE
      }
      return contentType
    }
    FormData2.prototype._multiPartFooter = function () {
      return function (next) {
        var footer = FormData2.LINE_BREAK
        var lastPart = this._streams.length === 0
        if (lastPart) {
          footer += this._lastBoundary()
        }
        next(footer)
      }.bind(this)
    }
    FormData2.prototype._lastBoundary = function () {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK
    }
    FormData2.prototype.getHeaders = function (userHeaders) {
      var header
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      }
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header]
        }
      }
      return formHeaders
    }
    FormData2.prototype.setBoundary = function (boundary) {
      this._boundary = boundary
    }
    FormData2.prototype.getBoundary = function () {
      if (!this._boundary) {
        this._generateBoundary()
      }
      return this._boundary
    }
    FormData2.prototype.getBuffer = function () {
      var dataBuffer = new Buffer2.alloc(0)
      var boundary = this.getBoundary()
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer2.isBuffer(this._streams[i])) {
            dataBuffer = Buffer2.concat([dataBuffer, this._streams[i]])
          } else {
            dataBuffer = Buffer2.concat([dataBuffer, Buffer2.from(this._streams[i])])
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer2.concat([dataBuffer, Buffer2.from(FormData2.LINE_BREAK)])
          }
        }
      }
      return Buffer2.concat([dataBuffer, Buffer2.from(this._lastBoundary())])
    }
    FormData2.prototype._generateBoundary = function () {
      var boundary = "--------------------------"
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16)
      }
      this._boundary = boundary
    }
    FormData2.prototype.getLengthSync = function () {
      var knownLength = this._overheadLength + this._valueLength
      if (this._streams.length) {
        knownLength += this._lastBoundary().length
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."))
      }
      return knownLength
    }
    FormData2.prototype.hasKnownLength = function () {
      var hasKnownLength = true
      if (this._valuesToMeasure.length) {
        hasKnownLength = false
      }
      return hasKnownLength
    }
    FormData2.prototype.getLength = function (cb) {
      var knownLength = this._overheadLength + this._valueLength
      if (this._streams.length) {
        knownLength += this._lastBoundary().length
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength))
        return
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err2, values) {
        if (err2) {
          cb(err2)
          return
        }
        values.forEach(function (length) {
          knownLength += length
        })
        cb(null, knownLength)
      })
    }
    FormData2.prototype.submit = function (params, cb) {
      var request3, options2, defaults2 = { method: "post" }
      if (typeof params == "string") {
        params = parseUrl(params)
        options2 = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2)
      } else {
        options2 = populate(params, defaults2)
        if (!options2.port) {
          options2.port = options2.protocol == "https:" ? 443 : 80
        }
      }
      options2.headers = this.getHeaders(params.headers)
      if (options2.protocol == "https:") {
        request3 = https.request(options2)
      } else {
        request3 = http.request(options2)
      }
      this.getLength(function (err2, length) {
        if (err2 && err2 !== "Unknown stream") {
          this._error(err2)
          return
        }
        if (length) {
          request3.setHeader("Content-Length", length)
        }
        this.pipe(request3)
        if (cb) {
          var onResponse
          var callback = function (error2, responce) {
            request3.removeListener("error", callback)
            request3.removeListener("response", onResponse)
            return cb.call(this, error2, responce)
          }
          onResponse = callback.bind(this, null)
          request3.on("error", callback)
          request3.on("response", onResponse)
        }
      }.bind(this))
      return request3
    }
    FormData2.prototype._error = function (err2) {
      if (!this.error) {
        this.error = err2
        this.pause()
        this.emit("error", err2)
      }
    }
    FormData2.prototype.toString = function () {
      return "[object FormData]"
    }
  }
})

// node_modules/openai/dist/configuration.js
var require_configuration = __commonJS({
  "node_modules/openai/dist/configuration.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.Configuration = void 0
    var packageJson = require_package()
    var Configuration4 = class {
      constructor(param = {}) {
        this.apiKey = param.apiKey
        this.organization = param.organization
        this.username = param.username
        this.password = param.password
        this.accessToken = param.accessToken
        this.basePath = param.basePath
        this.baseOptions = param.baseOptions
        this.formDataCtor = param.formDataCtor
        if (!this.baseOptions) {
          this.baseOptions = {}
        }
        this.baseOptions.headers = Object.assign({ "User-Agent": `OpenAI/NodeJS/${packageJson.version}`, "Authorization": `Bearer ${this.apiKey}` }, this.baseOptions.headers)
        if (this.organization) {
          this.baseOptions.headers["OpenAI-Organization"] = this.organization
        }
        if (!this.formDataCtor) {
          this.formDataCtor = require_form_data()
        }
      }
      /**
       * Check if the given MIME is a JSON MIME.
       * JSON MIME examples:
       *   application/json
       *   application/json; charset=UTF8
       *   APPLICATION/JSON
       *   application/vnd.company+json
       * @param mime - MIME (Multipurpose Internet Mail Extensions)
       * @return True if the given MIME is JSON, false otherwise.
       */
      isJsonMime(mime) {
        const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i")
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json")
      }
    }
    exports.Configuration = Configuration4
  }
})

// node_modules/openai/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/openai/dist/index.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k
      Object.defineProperty(o, k2, {
        enumerable: true, get: function () {
          return m[k]
        }
      })
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k
      o[k2] = m[k]
    })
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p)
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    __exportStar(require_api(), exports)
    __exportStar(require_configuration(), exports)
  }
})

// node_modules/langchain/dist/util/event-source-parse.js
async function getBytes(stream, onChunk) {
  const reader = stream.getReader()
  let result
  while (!(result = await reader.read()).done) {
    onChunk(result.value)
  }
}
function getLines(onLine) {
  let buffer
  let position
  let fieldLength
  let discardTrailingNewline = false
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr
      position = 0
      fieldLength = -1
    } else {
      buffer = concat3(buffer, arr)
    }
    const bufLength = buffer.length
    let lineStart = 0
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10) {
          lineStart = ++position
        }
        discardTrailingNewline = false
      }
      let lineEnd = -1
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58:
            if (fieldLength === -1) {
              fieldLength = position - lineStart
            }
            break
          case 13:
            discardTrailingNewline = true
          case 10:
            lineEnd = position
            break
        }
      }
      if (lineEnd === -1) {
        break
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)
      lineStart = position
      fieldLength = -1
    }
    if (lineStart === bufLength) {
      buffer = void 0
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart)
      position -= lineStart
    }
  }
}
function getMessages(onMessage, onId, onRetry) {
  let message = newMessage()
  const decoder = new TextDecoder()
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage == null ? void 0 : onMessage(message)
      message = newMessage()
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength))
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)
      const value = decoder.decode(line.subarray(valueOffset))
      switch (field) {
        case "data":
          message.data = message.data ? message.data + "\n" + value : value
          break
        case "event":
          message.event = value
          break
        case "id":
          onId == null ? void 0 : onId(message.id = value)
          break
        case "retry": {
          const retry = parseInt(value, 10)
          if (!Number.isNaN(retry)) {
            onRetry == null ? void 0 : onRetry(message.retry = retry)
          }
          break
        }
      }
    }
  }
}
function concat3(a, b) {
  const res = new Uint8Array(a.length + b.length)
  res.set(a)
  res.set(b, a.length)
  return res
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  }
}
var EventStreamContentType
var init_event_source_parse = __esm({
  "node_modules/langchain/dist/util/event-source-parse.js"() {
    init_process()
    init_buffer()
    EventStreamContentType = "text/event-stream"
  }
})

// node_modules/langchain/dist/util/axios-fetch-adapter.js
function tryJsonStringify(data) {
  try {
    return JSON.stringify(data)
  } catch (e) {
    return data
  }
}
function settle(resolve2, reject, response) {
  const { validateStatus } = response.config
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve2(response)
  } else {
    reject(createError(`Request failed with status code ${response.status} and body ${typeof response.data === "string" ? response.data : tryJsonStringify(response.data)}`, response.config, null, response.request, response))
  }
}
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL
}
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url
  }
  var serializedParams
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params)
  } else if (isURLSearchParams(params)) {
    serializedParams = params.toString()
  } else {
    var parts = []
    forEach2(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return
      }
      if (isArray4(val)) {
        key = `${key}[]`
      } else {
        val = [val]
      }
      forEach2(val, function parseValue(v) {
        if (isDate2(v)) {
          v = v.toISOString()
        } else if (isObject2(v)) {
          v = JSON.stringify(v)
        }
        parts.push(`${encode2(key)}=${encode2(v)}`)
      })
    })
    serializedParams = parts.join("&")
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#")
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex)
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams
  }
  return url
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL)
  }
  return requestedURL
}
function isUndefined2(val) {
  return typeof val === "undefined"
}
function isObject2(val) {
  return val !== null && typeof val === "object"
}
function isDate2(val) {
  return toString.call(val) === "[object Date]"
}
function isURLSearchParams(val) {
  return toString.call(val) === "[object URLSearchParams]"
}
function isArray4(val) {
  return Array.isArray(val)
}
function forEach2(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return
  }
  if (typeof obj !== "object") {
    obj = [obj]
  }
  if (isArray4(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj)
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj)
      }
    }
  }
}
function isFormData(val) {
  return toString.call(val) === "[object FormData]"
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && // eslint-disable-next-line no-undef
    (navigator.product === "ReactNative" || // eslint-disable-next-line no-undef
      navigator.product === "NativeScript" || // eslint-disable-next-line no-undef
      navigator.product === "NS")) {
    return false
  }
  return typeof window !== "undefined" && typeof document !== "undefined"
}
async function fetchAdapter(config4) {
  const request3 = createRequest(config4)
  const data = await getResponse(request3, config4)
  return new Promise((resolve2, reject) => {
    if (data instanceof Error) {
      reject(data)
    } else {
      Object.prototype.toString.call(config4.settle) === "[object Function]" ? config4.settle(resolve2, reject, data) : settle(resolve2, reject, data)
    }
  })
}
async function getResponse(request3, config4) {
  let stageOne
  try {
    stageOne = await fetch(request3)
  } catch (e) {
    if (e && e.name === "AbortError") {
      return createError("Request aborted", config4, "ECONNABORTED", request3)
    }
    if (e && e.name === "TimeoutError") {
      return createError("Request timeout", config4, "ECONNABORTED", request3)
    }
    return createError("Network Error", config4, "ERR_NETWORK", request3)
  }
  const headers = {}
  stageOne.headers.forEach((value, key) => {
    headers[key] = value
  })
  const response = {
    ok: stageOne.ok,
    status: stageOne.status,
    statusText: stageOne.statusText,
    headers,
    config: config4,
    request: request3
  }
  if (stageOne.status >= 200 && stageOne.status !== 204) {
    if (config4.responseType === "stream") {
      const contentType = stageOne.headers.get("content-type")
      if (!(contentType == null ? void 0 : contentType.startsWith(EventStreamContentType))) {
        if (stageOne.status >= 400) {
          if (contentType == null ? void 0 : contentType.startsWith("application/json")) {
            response.data = await stageOne.json()
            return response
          } else {
            response.data = await stageOne.text()
            return response
          }
        }
        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`)
      }
      await getBytes(stageOne.body, getLines(getMessages(config4.onmessage)))
    } else {
      switch (config4.responseType) {
        case "arraybuffer":
          response.data = await stageOne.arrayBuffer()
          break
        case "blob":
          response.data = await stageOne.blob()
          break
        case "json":
          response.data = await stageOne.json()
          break
        case "formData":
          response.data = await stageOne.formData()
          break
        default:
          response.data = await stageOne.text()
          break
      }
    }
  }
  return response
}
function createRequest(config4) {
  const headers = new Headers(config4.headers)
  if (config4.auth) {
    const username = config4.auth.username || ""
    const password = config4.auth.password ? decodeURI(encodeURIComponent(config4.auth.password)) : ""
    headers.set("Authorization", `Basic ${btoa(`${username}:${password}`)}`)
  }
  const method = config4.method.toUpperCase()
  const options2 = {
    headers,
    method
  }
  if (method !== "GET" && method !== "HEAD") {
    options2.body = config4.data
    if (isFormData(options2.body) && isStandardBrowserEnv()) {
      headers.delete("Content-Type")
    }
  }
  if (config4.mode) {
    options2.mode = config4.mode
  }
  if (config4.cache) {
    options2.cache = config4.cache
  }
  if (config4.integrity) {
    options2.integrity = config4.integrity
  }
  if (config4.redirect) {
    options2.redirect = config4.redirect
  }
  if (config4.referrer) {
    options2.referrer = config4.referrer
  }
  if (config4.timeout && config4.timeout > 0) {
    options2.signal = AbortSignal.timeout(config4.timeout)
  }
  if (config4.signal) {
    options2.signal = config4.signal
  }
  if (!isUndefined2(config4.withCredentials)) {
    options2.credentials = config4.withCredentials ? "include" : "omit"
  }
  if (config4.responseType === "stream") {
    options2.headers.set("Accept", EventStreamContentType)
  }
  const fullPath = buildFullPath(config4.baseURL, config4.url)
  const url = buildURL(fullPath, config4.params, config4.paramsSerializer)
  return new Request(url, options2)
}
function createError(message, config4, code, request3, response) {
  if (import_axios.default.AxiosError && typeof import_axios.default.AxiosError === "function") {
    return new import_axios.default.AxiosError(message, import_axios.default.AxiosError[code], config4, request3, response)
  }
  const error2 = new Error(message)
  return enhanceError(error2, config4, code, request3, response)
}
function enhanceError(error2, config4, code, request3, response) {
  error2.config = config4
  if (code) {
    error2.code = code
  }
  error2.request = request3
  error2.response = response
  error2.isAxiosError = true
  error2.toJSON = function toJSON4() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    }
  }
  return error2
}
var import_axios
var init_axios_fetch_adapter = __esm({
  "node_modules/langchain/dist/util/axios-fetch-adapter.js"() {
    init_process()
    init_buffer()
    import_axios = __toESM(require_axios2(), 1)
    init_event_source_parse()
  }
})

// node_modules/langchain/dist/chat_models/openai.js
var openai_exports = {}
__export(openai_exports, {
  ChatOpenAI: () => ChatOpenAI
})
function messageTypeToOpenAIRole(type2) {
  switch (type2) {
    case "system":
      return "system"
    case "ai":
      return "assistant"
    case "human":
      return "user"
    default:
      throw new Error(`Unknown message type: ${type2}`)
  }
}
function openAIResponseToChatMessage(role, text) {
  switch (role) {
    case "user":
      return new HumanChatMessage(text)
    case "assistant":
      return new AIChatMessage(text)
    case "system":
      return new SystemChatMessage(text)
    default:
      return new ChatMessage(text, role != null ? role : "unknown")
  }
}
var import_openai, ChatOpenAI
var init_openai = __esm({
  "node_modules/langchain/dist/chat_models/openai.js"() {
    init_process()
    init_buffer()
    import_openai = __toESM(require_dist2(), 1)
    init_axios_fetch_adapter()
    init_base3()
    init_schema()
    init_count_tokens()
    ChatOpenAI = class extends BaseChatModel {
      constructor(fields, configuration) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j
        super(fields != null ? fields : {})
        Object.defineProperty(this, "temperature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 1
        })
        Object.defineProperty(this, "topP", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 1
        })
        Object.defineProperty(this, "frequencyPenalty", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        })
        Object.defineProperty(this, "presencePenalty", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        })
        Object.defineProperty(this, "n", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 1
        })
        Object.defineProperty(this, "logitBias", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "modelName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "gpt-3.5-turbo"
        })
        Object.defineProperty(this, "modelKwargs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "stop", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "timeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "streaming", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        Object.defineProperty(this, "maxTokens", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "clientConfig", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        const apiKey = (_b = fields == null ? void 0 : fields.openAIApiKey) != null ? _b : typeof process !== "undefined" ? (
          // eslint-disable-next-line no-process-env
          (_a = process.env) == null ? void 0 : _a.OPENAI_API_KEY
        ) : void 0
        if (!apiKey) {
          throw new Error("OpenAI API key not found")
        }
        this.modelName = (_c = fields == null ? void 0 : fields.modelName) != null ? _c : this.modelName
        this.modelKwargs = (_d = fields == null ? void 0 : fields.modelKwargs) != null ? _d : {}
        this.timeout = fields == null ? void 0 : fields.timeout
        this.temperature = (_e = fields == null ? void 0 : fields.temperature) != null ? _e : this.temperature
        this.topP = (_f = fields == null ? void 0 : fields.topP) != null ? _f : this.topP
        this.frequencyPenalty = (_g = fields == null ? void 0 : fields.frequencyPenalty) != null ? _g : this.frequencyPenalty
        this.presencePenalty = (_h = fields == null ? void 0 : fields.presencePenalty) != null ? _h : this.presencePenalty
        this.maxTokens = fields == null ? void 0 : fields.maxTokens
        this.n = (_i = fields == null ? void 0 : fields.n) != null ? _i : this.n
        this.logitBias = fields == null ? void 0 : fields.logitBias
        this.stop = fields == null ? void 0 : fields.stop
        this.streaming = (_j = fields == null ? void 0 : fields.streaming) != null ? _j : false
        if (this.streaming && this.n > 1) {
          throw new Error("Cannot stream results when n > 1")
        }
        this.clientConfig = {
          apiKey,
          ...configuration
        }
      }
      /**
       * Get the parameters used to invoke the model
       */
      invocationParams() {
        return {
          model: this.modelName,
          temperature: this.temperature,
          top_p: this.topP,
          frequency_penalty: this.frequencyPenalty,
          presence_penalty: this.presencePenalty,
          max_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
          n: this.n,
          logit_bias: this.logitBias,
          stop: this.stop,
          stream: this.streaming,
          ...this.modelKwargs
        }
      }
      /** @ignore */
      _identifyingParams() {
        return {
          model_name: this.modelName,
          ...this.invocationParams(),
          ...this.clientConfig
        }
      }
      /**
       * Get the identifying parameters for the model
       */
      identifyingParams() {
        return this._identifyingParams()
      }
      /** @ignore */
      async _generate(messages2, stopOrOptions, runManager) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i
        const stop = Array.isArray(stopOrOptions) ? stopOrOptions : stopOrOptions == null ? void 0 : stopOrOptions.stop
        const options2 = Array.isArray(stopOrOptions) ? {} : (_a = stopOrOptions == null ? void 0 : stopOrOptions.options) != null ? _a : {}
        const tokenUsage = {}
        if (this.stop && stop) {
          throw new Error("Stop found in input and default params")
        }
        const params = this.invocationParams()
        params.stop = stop != null ? stop : params.stop
        const messagesMapped = messages2.map((message) => ({
          role: messageTypeToOpenAIRole(message._getType()),
          content: message.text,
          name: message.name
        }))
        const data = params.stream ? await new Promise((resolve2, reject) => {
          let response
          let rejected = false
          this.completionWithRetry({
            ...params,
            messages: messagesMapped
          }, {
            ...options2,
            responseType: "stream",
            onmessage: (event) => {
              var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j
              if (((_b2 = (_a2 = event.data) == null ? void 0 : _a2.trim) == null ? void 0 : _b2.call(_a2)) === "[DONE]") {
                resolve2(response)
              } else {
                const message = JSON.parse(event.data)
                if (!response) {
                  response = {
                    id: message.id,
                    object: message.object,
                    created: message.created,
                    model: message.model,
                    choices: []
                  }
                }
                const part = message.choices[0]
                if (part != null) {
                  let choice = response.choices.find((c) => c.index === part.index)
                  if (!choice) {
                    choice = {
                      index: part.index,
                      finish_reason: (_c2 = part.finish_reason) != null ? _c2 : void 0
                    }
                    response.choices.push(choice)
                  }
                  if (!choice.message) {
                    choice.message = {
                      role: (_d2 = part.delta) == null ? void 0 : _d2.role,
                      content: (_f2 = (_e2 = part.delta) == null ? void 0 : _e2.content) != null ? _f2 : ""
                    }
                  }
                  choice.message.content += (_h2 = (_g2 = part.delta) == null ? void 0 : _g2.content) != null ? _h2 : ""
                  void (runManager == null ? void 0 : runManager.handleLLMNewToken((_j = (_i2 = part.delta) == null ? void 0 : _i2.content) != null ? _j : ""))
                }
              }
            }
          }).catch((error2) => {
            if (!rejected) {
              rejected = true
              reject(error2)
            }
          })
        }) : await this.completionWithRetry({
          ...params,
          messages: messagesMapped
        }, options2)
        const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens } = (_b = data.usage) != null ? _b : {}
        if (completionTokens) {
          tokenUsage.completionTokens = ((_c = tokenUsage.completionTokens) != null ? _c : 0) + completionTokens
        }
        if (promptTokens) {
          tokenUsage.promptTokens = ((_d = tokenUsage.promptTokens) != null ? _d : 0) + promptTokens
        }
        if (totalTokens) {
          tokenUsage.totalTokens = ((_e = tokenUsage.totalTokens) != null ? _e : 0) + totalTokens
        }
        const generations = []
        for (const part of data.choices) {
          const role = (_g = (_f = part.message) == null ? void 0 : _f.role) != null ? _g : void 0
          const text = (_i = (_h = part.message) == null ? void 0 : _h.content) != null ? _i : ""
          generations.push({
            text,
            message: openAIResponseToChatMessage(role, text)
          })
        }
        return {
          generations,
          llmOutput: { tokenUsage }
        }
      }
      async getNumTokensFromMessages(messages2) {
        let totalCount = 0
        let tokensPerMessage = 0
        let tokensPerName = 0
        if (getModelNameForTiktoken(this.modelName) === "gpt-3.5-turbo") {
          tokensPerMessage = 4
          tokensPerName = -1
        } else if (getModelNameForTiktoken(this.modelName).startsWith("gpt-4")) {
          tokensPerMessage = 3
          tokensPerName = 1
        }
        const countPerMessage = await Promise.all(messages2.map(async (message) => {
          const textCount = await this.getNumTokens(message.text)
          const count = textCount + tokensPerMessage + (message.name ? tokensPerName : 0)
          totalCount += count
          return count
        }))
        return { totalCount, countPerMessage }
      }
      /** @ignore */
      async completionWithRetry(request3, options2) {
        if (!this.client) {
          const clientConfig = new import_openai.Configuration({
            ...this.clientConfig,
            baseOptions: {
              timeout: this.timeout,
              adapter: fetchAdapter,
              ...this.clientConfig.baseOptions
            }
          })
          this.client = new import_openai.OpenAIApi(clientConfig)
        }
        return this.caller.call(this.client.createChatCompletion.bind(this.client), request3, options2).then((res) => res.data)
      }
      _llmType() {
        return "openai"
      }
      /** @ignore */
      _combineLLMOutput(...llmOutputs) {
        return llmOutputs.reduce((acc, llmOutput) => {
          var _a, _b, _c
          if (llmOutput && llmOutput.tokenUsage) {
            acc.tokenUsage.completionTokens += (_a = llmOutput.tokenUsage.completionTokens) != null ? _a : 0
            acc.tokenUsage.promptTokens += (_b = llmOutput.tokenUsage.promptTokens) != null ? _b : 0
            acc.tokenUsage.totalTokens += (_c = llmOutput.tokenUsage.totalTokens) != null ? _c : 0
          }
          return acc
        }, {
          tokenUsage: {
            completionTokens: 0,
            promptTokens: 0,
            totalTokens: 0
          }
        })
      }
    }
  }
})

// node_modules/langchain/dist/base_language/index.js
var getVerbosity, BaseLangChain, BaseLanguageModel
var init_base_language = __esm({
  "node_modules/langchain/dist/base_language/index.js"() {
    init_process()
    init_buffer()
    init_async_caller()
    init_count_tokens()
    getVerbosity = () => false
    BaseLangChain = class {
      constructor(params) {
        var _a
        Object.defineProperty(this, "verbose", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "callbacks", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.verbose = (_a = params.verbose) != null ? _a : getVerbosity()
        this.callbacks = params.callbacks
      }
    }
    BaseLanguageModel = class extends BaseLangChain {
      constructor(params) {
        var _a
        super({
          verbose: params.verbose,
          callbacks: (_a = params.callbacks) != null ? _a : params.callbackManager
        })
        Object.defineProperty(this, "caller", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "_encoding", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "_registry", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.caller = new AsyncCaller(params != null ? params : {})
      }
      async getNumTokens(text) {
        let numTokens = Math.ceil(text.length / 4)
        try {
          if (!this._encoding) {
            const { encoding_for_model } = await importTiktoken()
            if (encoding_for_model) {
              this._encoding = encoding_for_model("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2")
              this._registry = new FinalizationRegistry((t) => t.free())
              this._registry.register(this, this._encoding)
            }
          }
          if (this._encoding) {
            numTokens = this._encoding.encode(text).length
          }
        } catch (error2) {
          console.warn("Failed to calculate number of tokens with tiktoken, falling back to approximate count", error2)
        }
        return numTokens
      }
      /**
       * Get the identifying parameters of the LLM.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _identifyingParams() {
        return {}
      }
      /**
       * Return a json-like object representing this LLM.
       */
      serialize() {
        return {
          ...this._identifyingParams(),
          _type: this._llmType(),
          _model: this._modelType()
        }
      }
      /**
       * Load an LLM from a json-like object describing it.
       */
      static async deserialize(data) {
        const { _type, _model, ...rest } = data
        if (_model && _model !== "base_chat_model") {
          throw new Error(`Cannot load LLM with model ${_model}`)
        }
        const Cls = {
          openai: (await Promise.resolve().then(() => (init_openai(), openai_exports))).ChatOpenAI
        }[_type]
        if (Cls === void 0) {
          throw new Error(`Cannot load  LLM with type ${_type}`)
        }
        return new Cls(rest)
      }
    }
  }
})

// node_modules/langchain/dist/memory/base.js
function getBufferString(messages2, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = []
  for (const m of messages2) {
    let role
    if (m._getType() === "human") {
      role = humanPrefix
    } else if (m._getType() === "ai") {
      role = aiPrefix
    } else if (m._getType() === "system") {
      role = "System"
    } else if (m._getType() === "generic") {
      role = m.role
    } else {
      throw new Error(`Got unsupported message type: ${m}`)
    }
    string_messages.push(`${role}: ${m.text}`)
  }
  return string_messages.join("\n")
}
var BaseMemory, getInputValue
var init_base = __esm({
  "node_modules/langchain/dist/memory/base.js"() {
    init_process()
    init_buffer()
    BaseMemory = class {
    }
    getInputValue = (inputValues, inputKey) => {
      if (inputKey !== void 0) {
        return inputValues[inputKey]
      }
      const keys2 = Object.keys(inputValues)
      if (keys2.length === 1) {
        return inputValues[keys2[0]]
      }
      throw new Error(`input values have multiple keys, memory only supported when one key currently: ${keys2}`)
    }
  }
})

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto.randomFillSync(rnds8Pool)
    poolPtr = 0
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16)
}
var rnds8Pool, poolPtr
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    init_process()
    init_buffer()
    rnds8Pool = new Uint8Array(256)
    poolPtr = rnds8Pool.length
  }
})

// node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase()
}
var byteToHex
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_process()
    init_buffer()
    byteToHex = []
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1))
    }
  }
})

// node-modules-polyfills:crypto
var crypto_default
var init_crypto = __esm({
  "node-modules-polyfills:crypto"() {
    init_process()
    init_buffer()
    crypto_default = {}
  }
})

// node_modules/uuid/dist/esm-node/native.js
var native_default
var init_native = __esm({
  "node_modules/uuid/dist/esm-node/native.js"() {
    init_process()
    init_buffer()
    init_crypto()
    native_default = {
      randomUUID: crypto_default.randomUUID
    }
  }
})

// node_modules/uuid/dist/esm-node/v4.js
function v4(options2, buf, offset) {
  if (native_default.randomUUID && !buf && !options2) {
    return native_default.randomUUID()
  }
  options2 = options2 || {}
  const rnds = options2.random || (options2.rng || rng)()
  rnds[6] = rnds[6] & 15 | 64
  rnds[8] = rnds[8] & 63 | 128
  if (buf) {
    offset = offset || 0
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i]
    }
    return buf
  }
  return unsafeStringify(rnds)
}
var v4_default
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_process()
    init_buffer()
    init_native()
    init_rng()
    init_stringify()
    v4_default = v4
  }
})

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_process()
    init_buffer()
    init_v4()
  }
})

// node_modules/langchain/dist/callbacks/base.js
var BaseCallbackHandlerMethodsClass, BaseCallbackHandler
var init_base2 = __esm({
  "node_modules/langchain/dist/callbacks/base.js"() {
    init_process()
    init_buffer()
    init_esm_node()
    BaseCallbackHandlerMethodsClass = class {
    }
    BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
      constructor(input) {
        var _a, _b, _c
        super()
        Object.defineProperty(this, "ignoreLLM", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        Object.defineProperty(this, "ignoreChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        Object.defineProperty(this, "ignoreAgent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        if (input) {
          this.ignoreLLM = (_a = input.ignoreLLM) != null ? _a : this.ignoreLLM
          this.ignoreChain = (_b = input.ignoreChain) != null ? _b : this.ignoreChain
          this.ignoreAgent = (_c = input.ignoreAgent) != null ? _c : this.ignoreAgent
        }
      }
      copy() {
        return new this.constructor(this)
      }
      static fromMethods(methods) {
        class Handler extends BaseCallbackHandler {
          constructor() {
            super()
            Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: v4_default()
            })
            Object.assign(this, methods)
          }
        }
        return new Handler()
      }
    }
  }
})

// node_modules/langchain/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/langchain/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var ANSI_BACKGROUND_OFFSET = 10
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`
    function assembleStyles() {
      const codes2 = /* @__PURE__ */ new Map()
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      }
      styles2.color.gray = styles2.color.blackBright
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright
      styles2.color.grey = styles2.color.blackBright
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }
          group[styleName] = styles2[styleName]
          codes2.set(style[0], style[1])
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        })
      }
      Object.defineProperty(styles2, "codes", {
        value: codes2,
        enumerable: false
      })
      styles2.color.close = "\x1B[39m"
      styles2.bgColor.close = "\x1B[49m"
      styles2.color.ansi256 = wrapAnsi256()
      styles2.color.ansi16m = wrapAnsi16m()
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET)
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET)
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16
              }
              if (red > 248) {
                return 231
              }
              return Math.round((red - 8) / 247 * 24) + 232
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5)
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?:[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16))
            if (!matches) {
              return [0, 0, 0]
            }
            let colorString = matches[0]
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("")
            }
            const integer = Number.parseInt(colorString, 16)
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ]
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      })
      return styles2
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    })
  }
})

// node_modules/langchain/dist/callbacks/handlers/tracers.js
var BaseTracer, LangChainTracer
var init_tracers = __esm({
  "node_modules/langchain/dist/callbacks/handlers/tracers.js"() {
    init_process()
    init_buffer()
    init_base2()
    BaseTracer = class extends BaseCallbackHandler {
      constructor() {
        super()
        Object.defineProperty(this, "session", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "runMap", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        })
      }
      copy() {
        return this
      }
      async newSession(sessionName) {
        const sessionCreate = {
          start_time: Date.now(),
          name: sessionName
        }
        const session = await this.persistSession(sessionCreate)
        this.session = session
        return session
      }
      _addChildRun(parentRun, childRun) {
        if (childRun.type === "llm") {
          parentRun.child_llm_runs.push(childRun)
        } else if (childRun.type === "chain") {
          parentRun.child_chain_runs.push(childRun)
        } else if (childRun.type === "tool") {
          parentRun.child_tool_runs.push(childRun)
        } else {
          throw new Error("Invalid run type")
        }
      }
      _startTrace(run) {
        if (run.parent_uuid) {
          const parentRun = this.runMap.get(run.parent_uuid)
          if (parentRun) {
            if (!(parentRun.type === "tool" || parentRun.type === "chain")) {
              throw new Error("Caller run can only be a tool or chain")
            } else {
              this._addChildRun(parentRun, run)
            }
          } else {
            throw new Error(`Caller run ${run.parent_uuid} not found`)
          }
        }
        this.runMap.set(run.uuid, run)
      }
      async _endTrace(run) {
        if (!run.parent_uuid) {
          await this.persistRun(run)
        } else {
          const parentRun = this.runMap.get(run.parent_uuid)
          if (parentRun === void 0) {
            throw new Error(`Parent run ${run.parent_uuid} not found`)
          }
          parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order)
        }
        this.runMap.delete(run.uuid)
      }
      _getExecutionOrder(parentRunId) {
        if (parentRunId === void 0) {
          return 1
        }
        const parentRun = this.runMap.get(parentRunId)
        if (parentRun === void 0) {
          throw new Error(`Parent run ${parentRunId} not found`)
        }
        return parentRun.child_execution_order + 1
      }
      async handleLLMStart(llm, prompts, runId, parentRunId) {
        var _a
        if (this.session === void 0) {
          this.session = await this.loadDefaultSession()
        }
        const execution_order = this._getExecutionOrder(parentRunId)
        const run = {
          uuid: runId,
          parent_uuid: parentRunId,
          start_time: Date.now(),
          end_time: 0,
          serialized: llm,
          prompts,
          session_id: this.session.id,
          execution_order,
          child_execution_order: execution_order,
          type: "llm"
        }
        this._startTrace(run)
        await ((_a = this.onLLMStart) == null ? void 0 : _a.call(this, run))
      }
      async handleLLMEnd(output, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "llm") {
          throw new Error("No LLM run to end.")
        }
        const llmRun = run
        llmRun.end_time = Date.now()
        llmRun.response = output
        await ((_a = this.onLLMEnd) == null ? void 0 : _a.call(this, llmRun))
        await this._endTrace(llmRun)
      }
      async handleLLMError(error2, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "llm") {
          throw new Error("No LLM run to end.")
        }
        const llmRun = run
        llmRun.end_time = Date.now()
        llmRun.error = error2.message
        await ((_a = this.onLLMError) == null ? void 0 : _a.call(this, llmRun))
        await this._endTrace(llmRun)
      }
      async handleChainStart(chain, inputs, runId, parentRunId) {
        var _a
        if (this.session === void 0) {
          this.session = await this.loadDefaultSession()
        }
        const execution_order = this._getExecutionOrder(parentRunId)
        const run = {
          uuid: runId,
          parent_uuid: parentRunId,
          start_time: Date.now(),
          end_time: 0,
          serialized: chain,
          inputs,
          session_id: this.session.id,
          execution_order,
          child_execution_order: execution_order,
          type: "chain",
          child_llm_runs: [],
          child_chain_runs: [],
          child_tool_runs: []
        }
        this._startTrace(run)
        await ((_a = this.onChainStart) == null ? void 0 : _a.call(this, run))
      }
      async handleChainEnd(outputs, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "chain") {
          throw new Error("No chain run to end.")
        }
        const chainRun = run
        chainRun.end_time = Date.now()
        chainRun.outputs = outputs
        await ((_a = this.onChainEnd) == null ? void 0 : _a.call(this, chainRun))
        await this._endTrace(chainRun)
      }
      async handleChainError(error2, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "chain") {
          throw new Error("No chain run to end.")
        }
        const chainRun = run
        chainRun.end_time = Date.now()
        chainRun.error = error2.message
        await ((_a = this.onChainError) == null ? void 0 : _a.call(this, chainRun))
        await this._endTrace(chainRun)
      }
      async handleToolStart(tool, input, runId, parentRunId) {
        var _a
        if (this.session === void 0) {
          this.session = await this.loadDefaultSession()
        }
        const execution_order = this._getExecutionOrder(parentRunId)
        const run = {
          uuid: runId,
          parent_uuid: parentRunId,
          start_time: Date.now(),
          end_time: 0,
          serialized: tool,
          tool_input: input,
          session_id: this.session.id,
          execution_order,
          child_execution_order: execution_order,
          type: "tool",
          action: JSON.stringify(tool),
          child_llm_runs: [],
          child_chain_runs: [],
          child_tool_runs: []
        }
        this._startTrace(run)
        await ((_a = this.onToolStart) == null ? void 0 : _a.call(this, run))
      }
      async handleToolEnd(output, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "tool") {
          throw new Error("No tool run to end")
        }
        const toolRun = run
        toolRun.end_time = Date.now()
        toolRun.output = output
        await ((_a = this.onToolEnd) == null ? void 0 : _a.call(this, toolRun))
        await this._endTrace(toolRun)
      }
      async handleToolError(error2, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "tool") {
          throw new Error("No tool run to end")
        }
        const toolRun = run
        toolRun.end_time = Date.now()
        toolRun.error = error2.message
        await ((_a = this.onToolError) == null ? void 0 : _a.call(this, toolRun))
        await this._endTrace(toolRun)
      }
      async handleAgentAction(action, runId) {
        var _a
        const run = this.runMap.get(runId)
        if (!run || (run == null ? void 0 : run.type) !== "chain") {
          return
        }
        const agentRun = run
        agentRun.actions = agentRun.actions || []
        agentRun.actions.push(action)
        await ((_a = this.onAgentAction) == null ? void 0 : _a.call(this, run))
      }
    }
    LangChainTracer = class extends BaseTracer {
      constructor() {
        var _a, _b, _c
        super()
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "langchain_tracer"
        })
        Object.defineProperty(this, "endpoint", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (typeof process !== "undefined" ? (
            // eslint-disable-next-line no-process-env
            (_a = process.env) == null ? void 0 : _a.LANGCHAIN_ENDPOINT
          ) : void 0) || "http://localhost:8000"
        })
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: {
            "Content-Type": "application/json"
          }
        })
        if (typeof process !== "undefined" && ((_b = process.env) == null ? void 0 : _b.LANGCHAIN_API_KEY)) {
          this.headers["x-api-key"] = (_c = process.env) == null ? void 0 : _c.LANGCHAIN_API_KEY
        }
      }
      async persistRun(run) {
        let endpoint
        if (run.type === "llm") {
          endpoint = `${this.endpoint}/llm-runs`
        } else if (run.type === "chain") {
          endpoint = `${this.endpoint}/chain-runs`
        } else {
          endpoint = `${this.endpoint}/tool-runs`
        }
        const response = await fetch(endpoint, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(run)
        })
        if (!response.ok) {
          console.error(`Failed to persist run: ${response.status} ${response.statusText}`)
        }
      }
      async persistSession(sessionCreate) {
        const endpoint = `${this.endpoint}/sessions`
        const response = await fetch(endpoint, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(sessionCreate)
        })
        if (!response.ok) {
          console.error(`Failed to persist session: ${response.status} ${response.statusText}, using default session.`)
          return {
            id: 1,
            ...sessionCreate
          }
        }
        return {
          id: (await response.json()).id,
          ...sessionCreate
        }
      }
      async loadSession(sessionName) {
        const endpoint = `${this.endpoint}/sessions?name=${sessionName}`
        return this._handleSessionResponse(endpoint)
      }
      async loadDefaultSession() {
        const endpoint = `${this.endpoint}/sessions?name=default`
        return this._handleSessionResponse(endpoint)
      }
      async _handleSessionResponse(endpoint) {
        const response = await fetch(endpoint, {
          method: "GET",
          headers: this.headers
        })
        let tracerSession
        if (!response.ok) {
          console.error(`Failed to load session: ${response.status} ${response.statusText}`)
          tracerSession = {
            id: 1,
            start_time: Date.now()
          }
          this.session = tracerSession
          return tracerSession
        }
        const resp = await response.json()
        if (resp.length === 0) {
          tracerSession = {
            id: 1,
            start_time: Date.now()
          }
          this.session = tracerSession
          return tracerSession
        }
        [tracerSession] = resp
        this.session = tracerSession
        return tracerSession
      }
    }
  }
})

// node_modules/langchain/dist/callbacks/handlers/console.js
function wrap(style, text) {
  return `${style.open}${text}${style.close}`
}
function tryJsonStringify2(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2)
  } catch (err2) {
    return fallback
  }
}
function elapsed(run) {
  const elapsed2 = run.end_time - run.start_time
  if (elapsed2 < 1e3) {
    return `${elapsed2}ms`
  }
  return `${(elapsed2 / 1e3).toFixed(2)}s`
}
var import_ansi_styles, color, ConsoleCallbackHandler
var init_console = __esm({
  "node_modules/langchain/dist/callbacks/handlers/console.js"() {
    init_process()
    init_buffer()
    import_ansi_styles = __toESM(require_ansi_styles(), 1)
    init_tracers();
    ({ color } = import_ansi_styles.default)
    ConsoleCallbackHandler = class extends BaseTracer {
      // boilerplate to work with the base tracer class
      constructor() {
        super()
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "console_callback_handler"
        })
        Object.defineProperty(this, "i", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        })
      }
      persistSession(session) {
        return Promise.resolve({ ...session, id: this.i++ })
      }
      persistRun(_run) {
        return Promise.resolve()
      }
      loadDefaultSession() {
        return this.newSession()
      }
      loadSession(sessionName) {
        return this.newSession(sessionName)
      }
      // utility methods
      getParents(run) {
        const parents = []
        let currentRun = run
        while (currentRun.parent_uuid) {
          const parent = this.runMap.get(currentRun.parent_uuid)
          if (parent) {
            parents.push(parent)
            currentRun = parent
          } else {
            break
          }
        }
        return parents
      }
      getBreadcrumbs(run) {
        const parents = this.getParents(run).reverse()
        const string = [...parents, run].map((parent, i, arr) => {
          var _a
          const name = `${parent.execution_order}:${parent.type}:${(_a = parent.serialized) == null ? void 0 : _a.name}`
          return i === arr.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name
        }).join(" > ")
        return wrap(color.grey, string)
      }
      // logging methods
      onChainStart(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify2(run.inputs, "[inputs]")}`)
      }
      onChainEnd(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify2(run.outputs, "[outputs]")}`)
      }
      onChainError(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify2(run.error, "[error]")}`)
      }
      onLLMStart(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify2({ prompts: run.prompts.map((p) => p.trim()) }, "[inputs]")}`)
      }
      onLLMEnd(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify2(run.response, "[response]")}`)
      }
      onLLMError(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify2(run.error, "[error]")}`)
      }
      onToolStart(run) {
        var _a
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${(_a = run.tool_input) == null ? void 0 : _a.trim()}"`)
      }
      onToolEnd(run) {
        var _a
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${(_a = run.output) == null ? void 0 : _a.trim()}"`)
      }
      onToolError(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify2(run.error, "[error]")}`)
      }
      onAgentAction(run) {
        const crumbs = this.getBreadcrumbs(run)
        console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify2(run.actions[run.actions.length - 1], "[action]")}`)
      }
    }
  }
})

// node_modules/langchain/dist/callbacks/handlers/initialize.js
async function getTracingCallbackHandler(session) {
  const tracer = new LangChainTracer()
  if (session) {
    await tracer.loadSession(session)
  } else {
    await tracer.loadDefaultSession()
  }
  return tracer
}
var init_initialize = __esm({
  "node_modules/langchain/dist/callbacks/handlers/initialize.js"() {
    init_process()
    init_buffer()
    init_tracers()
  }
})

// node_modules/langchain/dist/callbacks/manager.js
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler
  }
  return BaseCallbackHandler.fromMethods(handler)
}
var BaseCallbackManager, BaseRunManager, CallbackManagerForLLMRun, CallbackManagerForChainRun, CallbackManagerForToolRun, CallbackManager
var init_manager = __esm({
  "node_modules/langchain/dist/callbacks/manager.js"() {
    init_process()
    init_buffer()
    init_esm_node()
    init_base2()
    init_console()
    init_initialize()
    BaseCallbackManager = class {
      setHandler(handler) {
        return this.setHandlers([handler])
      }
    }
    BaseRunManager = class {
      constructor(runId, handlers, inheritableHandlers, _parentRunId) {
        Object.defineProperty(this, "runId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: runId
        })
        Object.defineProperty(this, "handlers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: handlers
        })
        Object.defineProperty(this, "inheritableHandlers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: inheritableHandlers
        })
        Object.defineProperty(this, "_parentRunId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: _parentRunId
        })
      }
      async handleText(text) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          try {
            await ((_a = handler.handleText) == null ? void 0 : _a.call(handler, text, this.runId, this._parentRunId))
          } catch (err2) {
            console.error(`Error in handler ${handler.constructor.name}, handleText: ${err2}`)
          }
        }))
      }
    }
    CallbackManagerForLLMRun = class extends BaseRunManager {
      async handleLLMNewToken(token) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreLLM) {
            try {
              await ((_a = handler.handleLLMNewToken) == null ? void 0 : _a.call(handler, token, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err2}`)
            }
          }
        }))
      }
      async handleLLMError(err2) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreLLM) {
            try {
              await ((_a = handler.handleLLMError) == null ? void 0 : _a.call(handler, err2, this.runId, this._parentRunId))
            } catch (err3) {
              console.error(`Error in handler ${handler.constructor.name}, handleLLMError: ${err3}`)
            }
          }
        }))
      }
      async handleLLMEnd(output) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreLLM) {
            try {
              await ((_a = handler.handleLLMEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err2}`)
            }
          }
        }))
      }
    }
    CallbackManagerForChainRun = class extends BaseRunManager {
      getChild() {
        const manager = new CallbackManager(this.runId)
        manager.setHandlers(this.inheritableHandlers)
        return manager
      }
      async handleChainError(err2) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreChain) {
            try {
              await ((_a = handler.handleChainError) == null ? void 0 : _a.call(handler, err2, this.runId, this._parentRunId))
            } catch (err3) {
              console.error(`Error in handler ${handler.constructor.name}, handleChainError: ${err3}`)
            }
          }
        }))
      }
      async handleChainEnd(output) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreChain) {
            try {
              await ((_a = handler.handleChainEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err2}`)
            }
          }
        }))
      }
      async handleAgentAction(action) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreAgent) {
            try {
              await ((_a = handler.handleAgentAction) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err2}`)
            }
          }
        }))
      }
      async handleAgentEnd(action) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreAgent) {
            try {
              await ((_a = handler.handleAgentEnd) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err2}`)
            }
          }
        }))
      }
    }
    CallbackManagerForToolRun = class extends BaseRunManager {
      getChild() {
        const manager = new CallbackManager(this.runId)
        manager.setHandlers(this.inheritableHandlers)
        return manager
      }
      async handleToolError(err2) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreAgent) {
            try {
              await ((_a = handler.handleToolError) == null ? void 0 : _a.call(handler, err2, this.runId, this._parentRunId))
            } catch (err3) {
              console.error(`Error in handler ${handler.constructor.name}, handleToolError: ${err3}`)
            }
          }
        }))
      }
      async handleToolEnd(output) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreAgent) {
            try {
              await ((_a = handler.handleToolEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err2}`)
            }
          }
        }))
      }
    }
    CallbackManager = class extends BaseCallbackManager {
      constructor(parentRunId) {
        super()
        Object.defineProperty(this, "handlers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inheritableHandlers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "callback_manager"
        })
        Object.defineProperty(this, "_parentRunId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.handlers = []
        this.inheritableHandlers = []
        this._parentRunId = parentRunId
      }
      async handleLLMStart(llm, prompts, runId = v4_default()) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreLLM) {
            try {
              await ((_a = handler.handleLLMStart) == null ? void 0 : _a.call(handler, llm, prompts, runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err2}`)
            }
          }
        }))
        return new CallbackManagerForLLMRun(runId, this.handlers, this.inheritableHandlers, this._parentRunId)
      }
      async handleChainStart(chain, inputs, runId = v4_default()) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreChain) {
            try {
              await ((_a = handler.handleChainStart) == null ? void 0 : _a.call(handler, chain, inputs, runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleChainStart: ${err2}`)
            }
          }
        }))
        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this._parentRunId)
      }
      async handleToolStart(tool, input, runId = v4_default()) {
        await Promise.all(this.handlers.map(async (handler) => {
          var _a
          if (!handler.ignoreAgent) {
            try {
              await ((_a = handler.handleToolStart) == null ? void 0 : _a.call(handler, tool, input, runId, this._parentRunId))
            } catch (err2) {
              console.error(`Error in handler ${handler.constructor.name}, handleToolStart: ${err2}`)
            }
          }
        }))
        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this._parentRunId)
      }
      addHandler(handler, inherit = true) {
        this.handlers.push(handler)
        if (inherit) {
          this.inheritableHandlers.push(handler)
        }
      }
      removeHandler(handler) {
        this.handlers = this.handlers.filter((_handler) => _handler !== handler)
        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler)
      }
      setHandlers(handlers, inherit = true) {
        this.handlers = []
        this.inheritableHandlers = []
        for (const handler of handlers) {
          this.addHandler(handler, inherit)
        }
      }
      copy(additionalHandlers = [], inherit = true) {
        const manager = new CallbackManager(this._parentRunId)
        for (const handler of this.handlers) {
          const inheritable = this.inheritableHandlers.includes(handler)
          const copied = handler.copy()
          manager.addHandler(copied, inheritable)
        }
        for (const handler of additionalHandlers) {
          if (
            // Prevent multiple copies of console_callback_handler
            manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)
          ) {
            continue
          }
          manager.addHandler(handler.copy(), inherit)
        }
        return manager
      }
      static fromHandlers(handlers) {
        class Handler extends BaseCallbackHandler {
          constructor() {
            super()
            Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: v4_default()
            })
            Object.assign(this, handlers)
          }
        }
        const manager = new this()
        manager.addHandler(new Handler())
        return manager
      }
      static async configure(inheritableHandlers, localHandlers, options2) {
        var _a, _b, _c
        let callbackManager
        if (inheritableHandlers || localHandlers) {
          if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
            callbackManager = new CallbackManager()
            callbackManager.setHandlers((_a = inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) != null ? _a : [], true)
          } else {
            callbackManager = inheritableHandlers
          }
          callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false)
        }
        const tracingEnabled = typeof process !== "undefined" ? (
          // eslint-disable-next-line no-process-env
          ((_b = process.env) == null ? void 0 : _b.LANGCHAIN_TRACING) !== void 0
        ) : false
        if ((options2 == null ? void 0 : options2.verbose) || tracingEnabled) {
          if (!callbackManager) {
            callbackManager = new CallbackManager()
          }
          if ((options2 == null ? void 0 : options2.verbose) && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
            const consoleHandler = new ConsoleCallbackHandler()
            callbackManager.addHandler(consoleHandler, true)
          }
          if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
            const session = typeof process !== "undefined" ? (
              // eslint-disable-next-line no-process-env
              (_c = process.env) == null ? void 0 : _c.LANGCHAIN_SESSION
            ) : void 0
            callbackManager.addHandler(await getTracingCallbackHandler(session), true)
          }
        }
        return callbackManager
      }
    }
  }
})

// node_modules/langchain/dist/chat_models/base.js
var BaseChatModel
var init_base3 = __esm({
  "node_modules/langchain/dist/chat_models/base.js"() {
    init_process()
    init_buffer()
    init_schema()
    init_base_language()
    init_base()
    init_manager()
    BaseChatModel = class extends BaseLanguageModel {
      constructor(fields) {
        super(fields)
      }
      async generate(messages2, stop, callbacks) {
        var _a
        const generations = []
        const llmOutputs = []
        const messageStrings = messages2.map((messageList) => getBufferString(messageList))
        const callbackManager_ = await CallbackManager.configure(callbacks, this.callbacks, { verbose: this.verbose })
        const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart({ name: this._llmType() }, messageStrings))
        try {
          const results = await Promise.all(messages2.map((messageList) => this._generate(messageList, stop, runManager)))
          for (const result of results) {
            if (result.llmOutput) {
              llmOutputs.push(result.llmOutput)
            }
            generations.push(result.generations)
          }
        } catch (err2) {
          await (runManager == null ? void 0 : runManager.handleLLMError(err2))
          throw err2
        }
        const output = {
          generations,
          llmOutput: llmOutputs.length ? (_a = this._combineLLMOutput) == null ? void 0 : _a.call(this, ...llmOutputs) : void 0
        }
        await (runManager == null ? void 0 : runManager.handleLLMEnd(output))
        Object.defineProperty(output, RUN_KEY, {
          value: runManager ? { runId: runManager == null ? void 0 : runManager.runId } : void 0,
          configurable: true
        })
        return output
      }
      _modelType() {
        return "base_chat_model"
      }
      async generatePrompt(promptValues, stop, callbacks) {
        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages())
        return this.generate(promptMessages, stop, callbacks)
      }
      async call(messages2, stop, callbacks) {
        const result = await this.generate([messages2], stop, callbacks)
        const generations = result.generations
        return generations[0][0].message
      }
      async callPrompt(promptValue, stop, callbacks) {
        const promptMessages = promptValue.toChatMessages()
        return this.call(promptMessages, stop, callbacks)
      }
    }
  }
})

// node_modules/@fortaine/fetch-event-source/lib/cjs/parse.cjs
var require_parse = __commonJS({
  "node_modules/@fortaine/fetch-event-source/lib/cjs/parse.cjs"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.getMessages = exports.getLines = exports.getBytes = void 0
    async function getBytes2(stream, onChunk) {
      const reader = stream.getReader()
      let result
      while (!(result = await reader.read()).done) {
        onChunk(result.value)
      }
    }
    exports.getBytes = getBytes2
    function getLines2(onLine) {
      let buffer
      let position
      let fieldLength
      let discardTrailingNewline = false
      return function onChunk(arr) {
        if (buffer === void 0) {
          buffer = arr
          position = 0
          fieldLength = -1
        } else {
          buffer = concat4(buffer, arr)
        }
        const bufLength = buffer.length
        let lineStart = 0
        while (position < bufLength) {
          if (discardTrailingNewline) {
            if (buffer[position] === 10) {
              lineStart = ++position
            }
            discardTrailingNewline = false
          }
          let lineEnd = -1
          for (; position < bufLength && lineEnd === -1; ++position) {
            switch (buffer[position]) {
              case 58:
                if (fieldLength === -1) {
                  fieldLength = position - lineStart
                }
                break
              case 13:
                discardTrailingNewline = true
              case 10:
                lineEnd = position
                break
            }
          }
          if (lineEnd === -1) {
            break
          }
          onLine(buffer.subarray(lineStart, lineEnd), fieldLength)
          lineStart = position
          fieldLength = -1
        }
        if (lineStart === bufLength) {
          buffer = void 0
        } else if (lineStart !== 0) {
          buffer = buffer.subarray(lineStart)
          position -= lineStart
        }
      }
    }
    exports.getLines = getLines2
    function getMessages2(onMessage, onId, onRetry) {
      let message = newMessage2()
      const decoder = new TextDecoder()
      return function onLine(line, fieldLength) {
        if (line.length === 0) {
          onMessage === null || onMessage === void 0 ? void 0 : onMessage(message)
          message = newMessage2()
        } else if (fieldLength > 0) {
          const field = decoder.decode(line.subarray(0, fieldLength))
          const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)
          const value = decoder.decode(line.subarray(valueOffset))
          switch (field) {
            case "data":
              message.data = message.data ? message.data + "\n" + value : value
              break
            case "event":
              message.event = value
              break
            case "id":
              onId === null || onId === void 0 ? void 0 : onId(message.id = value)
              break
            case "retry":
              const retry = parseInt(value, 10)
              if (!isNaN(retry)) {
                onRetry === null || onRetry === void 0 ? void 0 : onRetry(message.retry = retry)
              }
              break
          }
        }
      }
    }
    exports.getMessages = getMessages2
    function concat4(a, b) {
      const res = new Uint8Array(a.length + b.length)
      res.set(a)
      res.set(b, a.length)
      return res
    }
    function newMessage2() {
      return {
        data: "",
        event: "",
        id: "",
        retry: void 0
      }
    }
  }
})

// node_modules/@fortaine/fetch-event-source/lib/cjs/fetch.cjs
var require_fetch = __commonJS({
  "node_modules/@fortaine/fetch-event-source/lib/cjs/fetch.cjs"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __rest = exports && exports.__rest || function (s, e) {
      var t = {}
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p]
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]]
        }
      return t
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.fetchEventSource = exports.EventStreamContentType = void 0
    var parse_js_1 = require_parse()
    exports.EventStreamContentType = "text/event-stream"
    var DefaultRetryInterval = 1e3
    var LastEventId = "last-event-id"
    function fetchEventSource(input, _a) {
      var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"])
      return new Promise((resolve2, reject) => {
        const headers = Object.assign({}, inputHeaders)
        if (!headers.accept) {
          headers.accept = exports.EventStreamContentType
        }
        let curRequestController
        function onVisibilityChange() {
          curRequestController.abort()
          if (!document.hidden) {
            create()
          }
        }
        if (typeof document !== "undefined" && !openWhenHidden) {
          document.addEventListener("visibilitychange", onVisibilityChange)
        }
        let retryInterval = DefaultRetryInterval
        let retryTimer = 0
        function dispose() {
          if (typeof document !== "undefined" && !openWhenHidden) {
            document.removeEventListener("visibilitychange", onVisibilityChange)
          }
          clearTimeout(retryTimer)
          curRequestController.abort()
        }
        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener("abort", () => {
          dispose()
          resolve2()
        })
        const fetchFn = inputFetch !== null && inputFetch !== void 0 ? inputFetch : fetch
        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen
        async function create() {
          var _a2
          curRequestController = new AbortController()
          try {
            const response = await fetchFn(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }))
            await onopen(response)
            await (0, parse_js_1.getBytes)(response.body, (0, parse_js_1.getLines)((0, parse_js_1.getMessages)(onmessage, (id) => {
              if (id) {
                headers[LastEventId] = id
              } else {
                delete headers[LastEventId]
              }
            }, (retry) => {
              retryInterval = retry
            })))
            onclose === null || onclose === void 0 ? void 0 : onclose()
            dispose()
            resolve2()
          } catch (err2) {
            if (!curRequestController.signal.aborted) {
              try {
                const interval = (_a2 = onerror === null || onerror === void 0 ? void 0 : onerror(err2)) !== null && _a2 !== void 0 ? _a2 : retryInterval
                clearTimeout(retryTimer)
                retryTimer = setTimeout(create, interval)
              } catch (innerErr) {
                dispose()
                reject(innerErr)
              }
            }
          }
        }
        create()
      })
    }
    exports.fetchEventSource = fetchEventSource
    function defaultOnOpen(response) {
      const contentType = response.headers.get("content-type")
      if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(exports.EventStreamContentType))) {
        throw new Error(`Expected content-type to be ${exports.EventStreamContentType}, Actual: ${contentType}`)
      }
    }
  }
})

// node_modules/@fortaine/fetch-event-source/lib/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/@fortaine/fetch-event-source/lib/cjs/index.cjs"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.EventStreamContentType = exports.fetchEventSource = void 0
    var fetch_js_1 = require_fetch()
    Object.defineProperty(exports, "fetchEventSource", {
      enumerable: true, get: function () {
        return fetch_js_1.fetchEventSource
      }
    })
    Object.defineProperty(exports, "EventStreamContentType", {
      enumerable: true, get: function () {
        return fetch_js_1.EventStreamContentType
      }
    })
  }
})

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var conversions = {}
    module2.exports = conversions
    function sign(x) {
      return x < 0 ? -1 : 1
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x)
      } else {
        return Math.round(x)
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength)
      const upperBound = Math.pow(2, bitLength) - 1
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength)
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1)
      return function (V, opts) {
        if (!opts)
          opts = {}
        let x = +V
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number")
          }
          x = sign(x) * Math.floor(Math.abs(x))
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range")
          }
          return x
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x)
          if (x < lowerBound)
            x = lowerBound
          if (x > upperBound)
            x = upperBound
          return x
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0
        }
        x = sign(x) * Math.floor(Math.abs(x))
        x = x % moduloVal
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal
          } else if (x === -0) {
            return 0
          }
        }
        return x
      }
    }
    conversions["void"] = function () {
      return void 0
    }
    conversions["boolean"] = function (val) {
      return !!val
    }
    conversions["byte"] = createNumberConversion(8, { unsigned: false })
    conversions["octet"] = createNumberConversion(8, { unsigned: true })
    conversions["short"] = createNumberConversion(16, { unsigned: false })
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true })
    conversions["long"] = createNumberConversion(32, { unsigned: false })
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true })
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 })
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 })
    conversions["double"] = function (V) {
      const x = +V
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value")
      }
      return x
    }
    conversions["unrestricted double"] = function (V) {
      const x = +V
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN")
      }
      return x
    }
    conversions["float"] = conversions["double"]
    conversions["unrestricted float"] = conversions["unrestricted double"]
    conversions["DOMString"] = function (V, opts) {
      if (!opts)
        opts = {}
      if (opts.treatNullAsEmptyString && V === null) {
        return ""
      }
      return String(V)
    }
    conversions["ByteString"] = function (V, opts) {
      const x = String(V)
      let c = void 0
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring")
        }
      }
      return x
    }
    conversions["USVString"] = function (V) {
      const S = String(V)
      const n = S.length
      const U = []
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i)
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c))
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533))
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533))
          } else {
            const d = S.charCodeAt(i + 1)
            if (56320 <= d && d <= 57343) {
              const a = c & 1023
              const b = d & 1023
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b))
              ++i
            } else {
              U.push(String.fromCodePoint(65533))
            }
          }
        }
      }
      return U.join("")
    }
    conversions["Date"] = function (V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object")
      }
      if (isNaN(V)) {
        return void 0
      }
      return V
    }
    conversions["RegExp"] = function (V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V)
      }
      return V
    }
  }
})

// node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    module2.exports.mixin = function mixin(target, source) {
      const keys2 = Object.getOwnPropertyNames(source)
      for (let i = 0; i < keys2.length; ++i) {
        Object.defineProperty(target, keys2[i], Object.getOwnPropertyDescriptor(source, keys2[i]))
      }
    }
    module2.exports.wrapperSymbol = Symbol("wrapper")
    module2.exports.implSymbol = Symbol("impl")
    module2.exports.wrapperForImpl = function (impl) {
      return impl[module2.exports.wrapperSymbol]
    }
    module2.exports.implForWrapper = function (wrapper) {
      return wrapper[module2.exports.implSymbol]
    }
  }
})

// node-modules-polyfills-commonjs:punycode
var require_punycode = __commonJS({
  "node-modules-polyfills-commonjs:punycode"(exports, module2) {
    init_process()
    init_buffer()
    var polyfill = (init_punycode(), __toCommonJS(punycode_exports))
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k]
      }
    } else if (polyfill) {
      module2.exports = polyfill
    }
  }
})

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]]
  }
})

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var punycode = require_punycode()
    var mappingTable = require_mappingTable()
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    }
    function normalize2(str) {
      return str.split("\0").map(function (s) {
        return s.normalize("NFC")
      }).join("\0")
    }
    function findStatus(val) {
      var start = 0
      var end = mappingTable.length - 1
      while (start <= end) {
        var mid = Math.floor((start + end) / 2)
        var target = mappingTable[mid]
        if (target[0][0] <= val && target[0][1] >= val) {
          return target
        } else if (target[0][0] > val) {
          end = mid - 1
        } else {
          start = mid + 1
        }
      }
      return null
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false
      var processed = ""
      var len = countSymbols(domain_name)
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i)
        var status2 = findStatus(codePoint)
        switch (status2[1]) {
          case "disallowed":
            hasError = true
            processed += String.fromCodePoint(codePoint)
            break
          case "ignored":
            break
          case "mapped":
            processed += String.fromCodePoint.apply(String, status2[2])
            break
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status2[2])
            } else {
              processed += String.fromCodePoint(codePoint)
            }
            break
          case "valid":
            processed += String.fromCodePoint(codePoint)
            break
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true
              processed += String.fromCodePoint(codePoint)
            } else {
              processed += String.fromCodePoint.apply(String, status2[2])
            }
            break
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true
            }
            processed += String.fromCodePoint(codePoint)
            break
        }
      }
      return {
        string: processed,
        error: hasError
      }
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label)
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL
      }
      var error2 = false
      if (normalize2(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error2 = true
      }
      var len = countSymbols(label)
      for (var i = 0; i < len; ++i) {
        var status2 = findStatus(label.codePointAt(i))
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status2[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status2[1] !== "valid" && status2[1] !== "deviation") {
          error2 = true
          break
        }
      }
      return {
        label,
        error: error2
      }
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option)
      result.string = normalize2(result.string)
      var labels = result.string.split(".")
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i])
          labels[i] = validation.label
          result.error = result.error || validation.error
        } catch (e) {
          result.error = true
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      }
    }
    module2.exports.toASCII = function (domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option)
      var labels = result.string.split(".")
      labels = labels.map(function (l) {
        try {
          return punycode.toASCII(l)
        } catch (e) {
          result.error = true
          return l
        }
      })
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length
        if (total.length > 253 || total.length === 0) {
          result.error = true
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true
            break
          }
        }
      }
      if (result.error)
        return null
      return labels.join(".")
    }
    module2.exports.toUnicode = function (domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL)
      return {
        domain: result.string,
        error: result.error
      }
    }
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS
  }
})

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var punycode = require_punycode()
    var tr46 = require_tr46()
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    }
    var failure = Symbol("failure")
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length
    }
    function at(input, idx) {
      const c = input[idx]
      return isNaN(c) ? void 0 : String.fromCodePoint(c)
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c)
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e"
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase()
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e"
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124)
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|")
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":"
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme)
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme]
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase()
      if (hex.length === 1) {
        hex = "0" + hex
      }
      return "%" + hex
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer2(c)
      let str = ""
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i])
      }
      return str
    }
    function utf8PercentDecode(str) {
      const input = new Buffer2(str)
      const output = []
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i])
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16))
          i += 2
        } else {
          output.push(input[i])
        }
      }
      return new Buffer2(output).toString()
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125])
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c)
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124])
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c)
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c)
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr)
      }
      return cStr
    }
    function parseIPv4Number(input) {
      let R = 10
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2)
        R = 16
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1)
        R = 8
      }
      if (input === "") {
        return 0
      }
      const regex2 = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/
      if (regex2.test(input)) {
        return failure
      }
      return parseInt(input, R)
    }
    function parseIPv4(input) {
      const parts = input.split(".")
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop()
        }
      }
      if (parts.length > 4) {
        return input
      }
      const numbers = []
      for (const part of parts) {
        if (part === "") {
          return input
        }
        const n = parseIPv4Number(part)
        if (n === failure) {
          return input
        }
        numbers.push(n)
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure
      }
      let ipv4 = numbers.pop()
      let counter = 0
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter)
        ++counter
      }
      return ipv4
    }
    function serializeIPv4(address) {
      let output = ""
      let n = address
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output
        if (i !== 4) {
          output = "." + output
        }
        n = Math.floor(n / 256)
      }
      return output
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0]
      let pieceIndex = 0
      let compress = null
      let pointer = 0
      input = punycode.ucs2.decode(input)
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure
        }
        pointer += 2
        ++pieceIndex
        compress = pieceIndex
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure
          }
          ++pointer
          ++pieceIndex
          compress = pieceIndex
          continue
        }
        let value = 0
        let length = 0
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16)
          ++pointer
          ++length
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure
          }
          pointer -= length
          if (pieceIndex > 6) {
            return failure
          }
          let numbersSeen = 0
          while (input[pointer] !== void 0) {
            let ipv4Piece = null
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer
              } else {
                return failure
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer))
              if (ipv4Piece === null) {
                ipv4Piece = number
              } else if (ipv4Piece === 0) {
                return failure
              } else {
                ipv4Piece = ipv4Piece * 10 + number
              }
              if (ipv4Piece > 255) {
                return failure
              }
              ++pointer
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece
            ++numbersSeen
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex
            }
          }
          if (numbersSeen !== 4) {
            return failure
          }
          break
        } else if (input[pointer] === 58) {
          ++pointer
          if (input[pointer] === void 0) {
            return failure
          }
        } else if (input[pointer] !== void 0) {
          return failure
        }
        address[pieceIndex] = value
        ++pieceIndex
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress
        pieceIndex = 7
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1]
          address[compress + swaps - 1] = address[pieceIndex]
          address[pieceIndex] = temp
          --pieceIndex
          --swaps
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure
      }
      return address
    }
    function serializeIPv6(address) {
      let output = ""
      const seqResult = findLongestZeroSequence(address)
      const compress = seqResult.idx
      let ignore0 = false
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue
        } else if (ignore0) {
          ignore0 = false
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":"
          output += separator
          ignore0 = true
          continue
        }
        output += address[pieceIndex].toString(16)
        if (pieceIndex !== 7) {
          output += ":"
        }
      }
      return output
    }
    function parseHost2(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure
        }
        return parseIPv6(input.substring(1, input.length - 1))
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input)
      }
      const domain3 = utf8PercentDecode(input)
      const asciiDomain = tr46.toASCII(domain3, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false)
      if (asciiDomain === null) {
        return failure
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure
      }
      const ipv4Host = parseIPv4(asciiDomain)
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host
      }
      return asciiDomain
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure
      }
      let output = ""
      const decoded = punycode.ucs2.decode(input)
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode)
      }
      return output
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null
      let maxLen = 1
      let currStart = null
      let currLen = 0
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart
            maxLen = currLen
          }
          currStart = null
          currLen = 0
        } else {
          if (currStart === null) {
            currStart = i
          }
          ++currLen
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart
        maxLen = currLen
      }
      return {
        idx: maxIdx,
        len: maxLen
      }
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host)
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]"
      }
      return host
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "")
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "")
    }
    function shortenPath(url) {
      const path = url.path
      if (path.length === 0) {
        return
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return
      }
      path.pop()
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== ""
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file"
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string)
    }
    function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
      this.pointer = 0
      this.input = input
      this.base = base2 || null
      this.encodingOverride = encodingOverride || "utf-8"
      this.stateOverride = stateOverride
      this.url = url
      this.failure = false
      this.parseError = false
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        }
        const res2 = trimControlChars(this.input)
        if (res2 !== this.input) {
          this.parseError = true
        }
        this.input = res2
      }
      const res = trimTabAndNewline(this.input)
      if (res !== this.input) {
        this.parseError = true
      }
      this.input = res
      this.state = stateOverride || "scheme start"
      this.buffer = ""
      this.atFlag = false
      this.arrFlag = false
      this.passwordTokenSeenFlag = false
      this.input = punycode.ucs2.decode(this.input)
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer]
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c)
        const ret = this["parse " + this.state](c, cStr)
        if (!ret) {
          break
        } else if (ret === failure) {
          this.failure = true
          break
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase()
        this.state = "scheme"
      } else if (!this.stateOverride) {
        this.state = "no scheme"
        --this.pointer
      } else {
        this.parseError = true
        return failure
      }
      return true
    }
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase()
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false
          }
        }
        this.url.scheme = this.buffer
        this.buffer = ""
        if (this.stateOverride) {
          return false
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true
          }
          this.state = "file"
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority"
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes"
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority"
          ++this.pointer
        } else {
          this.url.cannotBeABaseURL = true
          this.url.path.push("")
          this.state = "cannot-be-a-base-URL path"
        }
      } else if (!this.stateOverride) {
        this.buffer = ""
        this.state = "no scheme"
        this.pointer = -1
      } else {
        this.parseError = true
        return failure
      }
      return true
    }
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme
        this.url.path = this.base.path.slice()
        this.url.query = this.base.query
        this.url.fragment = ""
        this.url.cannotBeABaseURL = true
        this.state = "fragment"
      } else if (this.base.scheme === "file") {
        this.state = "file"
        --this.pointer
      } else {
        this.state = "relative"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes"
        ++this.pointer
      } else {
        this.parseError = true
        this.state = "relative"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority"
      } else {
        this.state = "path"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme
      if (isNaN(c)) {
        this.url.username = this.base.username
        this.url.password = this.base.password
        this.url.host = this.base.host
        this.url.port = this.base.port
        this.url.path = this.base.path.slice()
        this.url.query = this.base.query
      } else if (c === 47) {
        this.state = "relative slash"
      } else if (c === 63) {
        this.url.username = this.base.username
        this.url.password = this.base.password
        this.url.host = this.base.host
        this.url.port = this.base.port
        this.url.path = this.base.path.slice()
        this.url.query = ""
        this.state = "query"
      } else if (c === 35) {
        this.url.username = this.base.username
        this.url.password = this.base.password
        this.url.host = this.base.host
        this.url.port = this.base.port
        this.url.path = this.base.path.slice()
        this.url.query = this.base.query
        this.url.fragment = ""
        this.state = "fragment"
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true
        this.state = "relative slash"
      } else {
        this.url.username = this.base.username
        this.url.password = this.base.password
        this.url.host = this.base.host
        this.url.port = this.base.port
        this.url.path = this.base.path.slice(0, this.base.path.length - 1)
        this.state = "path"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true
        }
        this.state = "special authority ignore slashes"
      } else if (c === 47) {
        this.state = "authority"
      } else {
        this.url.username = this.base.username
        this.url.password = this.base.password
        this.url.host = this.base.host
        this.url.port = this.base.port
        this.state = "path"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes"
        ++this.pointer
      } else {
        this.parseError = true
        this.state = "special authority ignore slashes"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority"
        --this.pointer
      } else {
        this.parseError = true
      }
      return true
    }
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer
        }
        this.atFlag = true
        const len = countSymbols(this.buffer)
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer)
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true
            continue
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode)
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints
          } else {
            this.url.username += encodedCodePoints
          }
        }
        this.buffer = ""
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true
          return failure
        }
        this.pointer -= countSymbols(this.buffer) + 1
        this.buffer = ""
        this.state = "host"
      } else {
        this.buffer += cStr
      }
      return true
    }
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer
        this.state = "file host"
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true
          return failure
        }
        const host = parseHost2(this.buffer, isSpecial(this.url))
        if (host === failure) {
          return failure
        }
        this.url.host = host
        this.buffer = ""
        this.state = "port"
        if (this.stateOverride === "hostname") {
          return false
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true
          return failure
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true
          return false
        }
        const host = parseHost2(this.buffer, isSpecial(this.url))
        if (host === failure) {
          return failure
        }
        this.url.host = host
        this.buffer = ""
        this.state = "path start"
        if (this.stateOverride) {
          return false
        }
      } else {
        if (c === 91) {
          this.arrFlag = true
        } else if (c === 93) {
          this.arrFlag = false
        }
        this.buffer += cStr
      }
      return true
    }
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer)
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true
            return failure
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port
          this.buffer = ""
        }
        if (this.stateOverride) {
          return false
        }
        this.state = "path start"
        --this.pointer
      } else {
        this.parseError = true
        return failure
      }
      return true
    }
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35])
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file"
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true
        }
        this.state = "file slash"
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host
          this.url.path = this.base.path.slice()
          this.url.query = this.base.query
        } else if (c === 63) {
          this.url.host = this.base.host
          this.url.path = this.base.path.slice()
          this.url.query = ""
          this.state = "query"
        } else if (c === 35) {
          this.url.host = this.base.host
          this.url.path = this.base.path.slice()
          this.url.query = this.base.query
          this.url.fragment = ""
          this.state = "fragment"
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host
            this.url.path = this.base.path.slice()
            shortenPath(this.url)
          } else {
            this.parseError = true
          }
          this.state = "path"
          --this.pointer
        }
      } else {
        this.state = "path"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true
        }
        this.state = "file host"
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0])
          } else {
            this.url.host = this.base.host
          }
        }
        this.state = "path"
        --this.pointer
      }
      return true
    }
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true
          this.state = "path"
        } else if (this.buffer === "") {
          this.url.host = ""
          if (this.stateOverride) {
            return false
          }
          this.state = "path start"
        } else {
          let host = parseHost2(this.buffer, isSpecial(this.url))
          if (host === failure) {
            return failure
          }
          if (host === "localhost") {
            host = ""
          }
          this.url.host = host
          if (this.stateOverride) {
            return false
          }
          this.buffer = ""
          this.state = "path start"
        }
      } else {
        this.buffer += cStr
      }
      return true
    }
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true
        }
        this.state = "path"
        if (c !== 47 && c !== 92) {
          --this.pointer
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = ""
        this.state = "query"
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = ""
        this.state = "fragment"
      } else if (c !== void 0) {
        this.state = "path"
        if (c !== 47) {
          --this.pointer
        }
      }
      return true
    }
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url)
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("")
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("")
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true
              this.url.host = ""
            }
            this.buffer = this.buffer[0] + ":"
          }
          this.url.path.push(this.buffer)
        }
        this.buffer = ""
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true
            this.url.path.shift()
          }
        }
        if (c === 63) {
          this.url.query = ""
          this.state = "query"
        }
        if (c === 35) {
          this.url.fragment = ""
          this.state = "fragment"
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode)
      }
      return true
    }
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = ""
        this.state = "query"
      } else if (c === 35) {
        this.url.fragment = ""
        this.state = "fragment"
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode)
        }
      }
      return true
    }
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8"
        }
        const buffer = new Buffer2(this.buffer)
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i])
          } else {
            this.url.query += String.fromCodePoint(buffer[i])
          }
        }
        this.buffer = ""
        if (c === 35) {
          this.url.fragment = ""
          this.state = "fragment"
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true
        }
        this.buffer += cStr
      }
      return true
    }
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode)
      }
      return true
    }
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":"
      if (url.host !== null) {
        output += "//"
        if (url.username !== "" || url.password !== "") {
          output += url.username
          if (url.password !== "") {
            output += ":" + url.password
          }
          output += "@"
        }
        output += serializeHost(url.host)
        if (url.port !== null) {
          output += ":" + url.port
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//"
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0]
      } else {
        for (const string of url.path) {
          output += "/" + string
        }
      }
      if (url.query !== null) {
        output += "?" + url.query
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment
      }
      return output
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://"
      result += serializeHost(tuple.host)
      if (tuple.port !== null) {
        result += ":" + tuple.port
      }
      return result
    }
    module2.exports.serializeURL = serializeURL
    module2.exports.serializeURLOrigin = function (url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]))
          } catch (e) {
            return "null"
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          })
        case "file":
          return "file://"
        default:
          return "null"
      }
    }
    module2.exports.basicURLParse = function (input, options2) {
      if (options2 === void 0) {
        options2 = {}
      }
      const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride)
      if (usm.failure) {
        return "failure"
      }
      return usm.url
    }
    module2.exports.setTheUsername = function (url, username) {
      url.username = ""
      const decoded = punycode.ucs2.decode(username)
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode)
      }
    }
    module2.exports.setThePassword = function (url, password) {
      url.password = ""
      const decoded = punycode.ucs2.decode(password)
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode)
      }
    }
    module2.exports.serializeHost = serializeHost
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort
    module2.exports.serializeInteger = function (integer) {
      return String(integer)
    }
    module2.exports.parseURL = function (input, options2) {
      if (options2 === void 0) {
        options2 = {}
      }
      return module2.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride })
    }
  }
})

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var usm = require_url_state_machine()
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0]
        const base2 = constructorArgs[1]
        let parsedBase = null
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2)
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL")
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase })
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL")
        }
        this._url = parsedURL
      }
      get href() {
        return usm.serializeURL(this._url)
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v)
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL")
        }
        this._url = parsedURL
      }
      get origin() {
        return usm.serializeURLOrigin(this._url)
      }
      get protocol() {
        return this._url.scheme + ":"
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" })
      }
      get username() {
        return this._url.username
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return
        }
        usm.setTheUsername(this._url, v)
      }
      get password() {
        return this._url.password
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return
        }
        usm.setThePassword(this._url, v)
      }
      get host() {
        const url = this._url
        if (url.host === null) {
          return ""
        }
        if (url.port === null) {
          return usm.serializeHost(url.host)
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port)
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" })
      }
      get hostname() {
        if (this._url.host === null) {
          return ""
        }
        return usm.serializeHost(this._url.host)
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" })
      }
      get port() {
        if (this._url.port === null) {
          return ""
        }
        return usm.serializeInteger(this._url.port)
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return
        }
        if (v === "") {
          this._url.port = null
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" })
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0]
        }
        if (this._url.path.length === 0) {
          return ""
        }
        return "/" + this._url.path.join("/")
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return
        }
        this._url.path = []
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" })
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return ""
        }
        return "?" + this._url.query
      }
      set search(v) {
        const url = this._url
        if (v === "") {
          url.query = null
          return
        }
        const input = v[0] === "?" ? v.substring(1) : v
        url.query = ""
        usm.basicURLParse(input, { url, stateOverride: "query" })
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return ""
        }
        return "#" + this._url.fragment
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null
          return
        }
        const input = v[0] === "#" ? v.substring(1) : v
        this._url.fragment = ""
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" })
      }
      toJSON() {
        return this.href
      }
    }
  }
})

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var conversions = require_lib()
    var utils = require_utils2()
    var Impl = require_URL_impl()
    var impl = utils.implSymbol
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.")
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.")
      }
      const args = []
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i]
      }
      args[0] = conversions["USVString"](args[0])
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1])
      }
      module2.exports.setup(this, args)
    }
    URL2.prototype.toJSON = function toJSON4() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation")
      }
      const args = []
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i]
      }
      return this[impl].toJSON.apply(this[impl], args)
    }
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].href = V
      },
      enumerable: true,
      configurable: true
    })
    URL2.prototype.toString = function () {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation")
      }
      return this.href
    }
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].protocol = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].username = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].password = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].host = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].hostname = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].port = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].pathname = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].search = V
      },
      enumerable: true,
      configurable: true
    })
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash
      },
      set(V) {
        V = conversions["USVString"](V)
        this[impl].hash = V
      },
      enumerable: true,
      configurable: true
    })
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype)
        this.setup(obj, constructorArgs, privateData)
        return obj
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {}
        privateData.wrapper = obj
        obj[impl] = new Impl.implementation(constructorArgs, privateData)
        obj[impl][utils.wrapperSymbol] = obj
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    }
  }
})

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    exports.URL = require_URL().interface
    exports.serializeURL = require_url_state_machine().serializeURL
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin
    exports.basicURLParse = require_url_state_machine().basicURLParse
    exports.setTheUsername = require_url_state_machine().setTheUsername
    exports.setThePassword = require_url_state_machine().setThePassword
    exports.serializeHost = require_url_state_machine().serializeHost
    exports.serializeInteger = require_url_state_machine().serializeInteger
    exports.parseURL = require_url_state_machine().parseURL
  }
})

// node_modules/cross-fetch/node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/cross-fetch/node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex
    }
    var Stream2 = _interopDefault(require_stream())
    var http = _interopDefault(require_http())
    var Url2 = _interopDefault(require_url())
    var whatwgUrl = _interopDefault(require_public_api())
    var https = _interopDefault(require_https())
    var zlib = _interopDefault(require_zlib())
    var Readable2 = Stream2.Readable
    var BUFFER = Symbol("buffer")
    var TYPE3 = Symbol("type")
    var Blob = class {
      constructor() {
        this[TYPE3] = ""
        const blobParts = arguments[0]
        const options2 = arguments[1]
        const buffers = []
        let size = 0
        if (blobParts) {
          const a = blobParts
          const length = Number(a.length)
          for (let i = 0; i < length; i++) {
            const element = a[i]
            let buffer
            if (element instanceof Buffer2) {
              buffer = element
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer2.from(element.buffer, element.byteOffset, element.byteLength)
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer2.from(element)
            } else if (element instanceof Blob) {
              buffer = element[BUFFER]
            } else {
              buffer = Buffer2.from(typeof element === "string" ? element : String(element))
            }
            size += buffer.length
            buffers.push(buffer)
          }
        }
        this[BUFFER] = Buffer2.concat(buffers)
        let type2 = options2 && options2.type !== void 0 && String(options2.type).toLowerCase()
        if (type2 && !/[^\u0020-\u007E]/.test(type2)) {
          this[TYPE3] = type2
        }
      }
      get size() {
        return this[BUFFER].length
      }
      get type() {
        return this[TYPE3]
      }
      text() {
        return Promise.resolve(this[BUFFER].toString())
      }
      arrayBuffer() {
        const buf = this[BUFFER]
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
        return Promise.resolve(ab)
      }
      stream() {
        const readable = new Readable2()
        readable._read = function () {
        }
        readable.push(this[BUFFER])
        readable.push(null)
        return readable
      }
      toString() {
        return "[object Blob]"
      }
      slice() {
        const size = this.size
        const start = arguments[0]
        const end = arguments[1]
        let relativeStart, relativeEnd
        if (start === void 0) {
          relativeStart = 0
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0)
        } else {
          relativeStart = Math.min(start, size)
        }
        if (end === void 0) {
          relativeEnd = size
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0)
        } else {
          relativeEnd = Math.min(end, size)
        }
        const span = Math.max(relativeEnd - relativeStart, 0)
        const buffer = this[BUFFER]
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span)
        const blob = new Blob([], { type: arguments[2] })
        blob[BUFFER] = slicedBuffer
        return blob
      }
    }
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    })
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    })
    function FetchError(message, type2, systemError) {
      Error.call(this, message)
      this.message = message
      this.type = type2
      if (systemError) {
        this.code = this.errno = systemError.code
      }
      Error.captureStackTrace(this, this.constructor)
    }
    FetchError.prototype = Object.create(Error.prototype)
    FetchError.prototype.constructor = FetchError
    FetchError.prototype.name = "FetchError"
    var convert
    try {
      convert = require("encoding").convert
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals")
    var PassThrough2 = Stream2.PassThrough
    function Body(body) {
      var _this = this
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size
      let size = _ref$size === void 0 ? 0 : _ref$size
      var _ref$timeout = _ref.timeout
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout
      if (body == null) {
        body = null
      } else if (isURLSearchParams2(body)) {
        body = Buffer2.from(body.toString())
      } else if (isBlob(body))
        ;
      else if (Buffer2.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer2.from(body)
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer2.from(body.buffer, body.byteOffset, body.byteLength)
      } else if (body instanceof Stream2)
        ;
      else {
        body = Buffer2.from(String(body))
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      }
      this.size = size
      this.timeout = timeout
      if (body instanceof Stream2) {
        body.on("error", function (err2) {
          const error2 = err2.name === "AbortError" ? err2 : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err2.message}`, "system", err2)
          _this[INTERNALS].error = error2
        })
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function (buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
        })
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || ""
        return consumeBody.call(this).then(function (buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          )
        })
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this
        return consumeBody.call(this).then(function (buffer) {
          try {
            return JSON.parse(buffer.toString())
          } catch (err2) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err2.message}`, "invalid-json"))
          }
        })
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function (buffer) {
          return buffer.toString()
        })
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this)
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this
        return consumeBody.call(this).then(function (buffer) {
          return convertBody(buffer, _this3.headers)
        })
      }
    }
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    })
    Body.mixIn = function (proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name)
          Object.defineProperty(proto, name, desc)
        }
      }
    }
    function consumeBody() {
      var _this4 = this
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`))
      }
      this[INTERNALS].disturbed = true
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error)
      }
      let body = this.body
      if (body === null) {
        return Body.Promise.resolve(Buffer2.alloc(0))
      }
      if (isBlob(body)) {
        body = body.stream()
      }
      if (Buffer2.isBuffer(body)) {
        return Body.Promise.resolve(body)
      }
      if (!(body instanceof Stream2)) {
        return Body.Promise.resolve(Buffer2.alloc(0))
      }
      let accum = []
      let accumBytes = 0
      let abort = false
      return new Body.Promise(function (resolve2, reject) {
        let resTimeout
        if (_this4.timeout) {
          resTimeout = setTimeout(function () {
            abort = true
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"))
          }, _this4.timeout)
        }
        body.on("error", function (err2) {
          if (err2.name === "AbortError") {
            abort = true
            reject(err2)
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err2.message}`, "system", err2))
          }
        })
        body.on("data", function (chunk) {
          if (abort || chunk === null) {
            return
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"))
            return
          }
          accumBytes += chunk.length
          accum.push(chunk)
        })
        body.on("end", function () {
          if (abort) {
            return
          }
          clearTimeout(resTimeout)
          try {
            resolve2(Buffer2.concat(accum, accumBytes))
          } catch (err2) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err2.message}`, "system", err2))
          }
        })
      })
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function")
      }
      const ct = headers.get("content-type")
      let charset = "utf-8"
      let res, str
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct)
      }
      str = buffer.slice(0, 1024).toString()
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str)
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str)
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str)
          if (res) {
            res.pop()
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop())
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str)
      }
      if (res) {
        charset = res.pop()
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030"
        }
      }
      return convert(buffer, "UTF-8", charset).toString()
    }
    function isURLSearchParams2(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function"
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag])
    }
    function clone(instance) {
      let p1, p2
      let body = instance.body
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used")
      }
      if (body instanceof Stream2 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2()
        p2 = new PassThrough2()
        body.pipe(p1)
        body.pipe(p2)
        instance[INTERNALS].body = p1
        body = p2
      }
      return body
    }
    function extractContentType(body) {
      if (body === null) {
        return null
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8"
      } else if (isURLSearchParams2(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8"
      } else if (isBlob(body)) {
        return body.type || null
      } else if (Buffer2.isBuffer(body)) {
        return null
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null
      } else if (ArrayBuffer.isView(body)) {
        return null
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`
      } else if (body instanceof Stream2) {
        return null
      } else {
        return "text/plain;charset=UTF-8"
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body
      if (body === null) {
        return 0
      } else if (isBlob(body)) {
        return body.size
      } else if (Buffer2.isBuffer(body)) {
        return body.length
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
          body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync()
        }
        return null
      } else {
        return null
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body
      if (body === null) {
        dest.end()
      } else if (isBlob(body)) {
        body.stream().pipe(dest)
      } else if (Buffer2.isBuffer(body)) {
        dest.write(body)
        dest.end()
      } else {
        body.pipe(dest)
      }
    }
    Body.Promise = _globalThis.Promise
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/
    function validateName(name) {
      name = `${name}`
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`)
      }
    }
    function validateValue(value) {
      value = `${value}`
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`)
      }
    }
    function find(map3, name) {
      name = name.toLowerCase()
      for (const key in map3) {
        if (key.toLowerCase() === name) {
          return key
        }
      }
      return void 0
    }
    var MAP = Symbol("map")
    var Headers2 = class {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0
        this[MAP] = /* @__PURE__ */ Object.create(null)
        if (init3 instanceof Headers2) {
          const rawHeaders = init3.raw()
          const headerNames = Object.keys(rawHeaders)
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value)
            }
          }
          return
        }
        if (init3 == null)
          ;
        else if (typeof init3 === "object") {
          const method = init3[Symbol.iterator]
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable")
            }
            const pairs = []
            for (const pair of init3) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable")
              }
              pairs.push(Array.from(pair))
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple")
              }
              this.append(pair[0], pair[1])
            }
          } else {
            for (const key of Object.keys(init3)) {
              const value = init3[key]
              this.append(key, value)
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object")
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`
        validateName(name)
        const key = find(this[MAP], name)
        if (key === void 0) {
          return null
        }
        return this[MAP][key].join(", ")
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0
        let pairs = getHeaders(this)
        let i = 0
        while (i < pairs.length) {
          var _pairs$i = pairs[i]
          const name = _pairs$i[0], value = _pairs$i[1]
          callback.call(thisArg, value, name, this)
          pairs = getHeaders(this)
          i++
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`
        value = `${value}`
        validateName(name)
        validateValue(value)
        const key = find(this[MAP], name)
        this[MAP][key !== void 0 ? key : name] = [value]
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`
        value = `${value}`
        validateName(name)
        validateValue(value)
        const key = find(this[MAP], name)
        if (key !== void 0) {
          this[MAP][key].push(value)
        } else {
          this[MAP][name] = [value]
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`
        validateName(name)
        return find(this[MAP], name) !== void 0
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`
        validateName(name)
        const key = find(this[MAP], name)
        if (key !== void 0) {
          delete this[MAP][key]
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP]
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key")
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value")
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value")
      }
    }
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator]
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    })
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value"
      const keys2 = Object.keys(headers[MAP]).sort()
      return keys2.map(kind === "key" ? function (k) {
        return k.toLowerCase()
      } : kind === "value" ? function (k) {
        return headers[MAP][k].join(", ")
      } : function (k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")]
      })
    }
    var INTERNAL = Symbol("internal")
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype)
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      }
      return iterator
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator")
        }
        var _INTERNAL = this[INTERNAL]
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index
        const values = getHeaders(target, kind)
        const len = values.length
        if (index >= len) {
          return {
            value: void 0,
            done: true
          }
        }
        this[INTERNAL].index = index + 1
        return {
          value: values[index],
          done: false
        }
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())))
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    })
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP])
      const hostHeaderKey = find(headers[MAP], "Host")
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0]
      }
      return obj
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2()
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val]
            } else {
              headers[MAP][name].push(val)
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]]
        }
      }
      return headers
    }
    var INTERNALS$1 = Symbol("Response internals")
    var STATUS_CODES3 = http.STATUS_CODES
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
        Body.call(this, body, opts)
        const status2 = opts.status || 200
        const headers = new Headers2(opts.headers)
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body)
          if (contentType) {
            headers.append("Content-Type", contentType)
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status: status2,
          statusText: opts.statusText || STATUS_CODES3[status2],
          headers,
          counter: opts.counter
        }
      }
      get url() {
        return this[INTERNALS$1].url || ""
      }
      get status() {
        return this[INTERNALS$1].status
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0
      }
      get statusText() {
        return this[INTERNALS$1].statusText
      }
      get headers() {
        return this[INTERNALS$1].headers
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        })
      }
    }
    Body.mixIn(Response.prototype)
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    })
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    })
    var INTERNALS$2 = Symbol("Request internals")
    var URL2 = Url2.URL || whatwgUrl.URL
    var parse_url = Url2.parse
    var format_url = Url2.format
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString()
      }
      return parse_url(urlStr)
    }
    var streamDestructionSupported = "destroy" in Stream2.Readable.prototype
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object"
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal)
      return !!(proto && proto.constructor.name === "AbortSignal")
    }
    var Request2 = class {
      constructor(input) {
        let init3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
        let parsedURL
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href)
          } else {
            parsedURL = parseURL(`${input}`)
          }
          input = {}
        } else {
          parsedURL = parseURL(input.url)
        }
        let method = init3.method || input.method || "GET"
        method = method.toUpperCase()
        if ((init3.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body")
        }
        let inputBody = init3.body != null ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null
        Body.call(this, inputBody, {
          timeout: init3.timeout || input.timeout || 0,
          size: init3.size || input.size || 0
        })
        const headers = new Headers2(init3.headers || input.headers || {})
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody)
          if (contentType) {
            headers.append("Content-Type", contentType)
          }
        }
        let signal = isRequest(input) ? input.signal : null
        if ("signal" in init3)
          signal = init3.signal
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal")
        }
        this[INTERNALS$2] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        }
        this.follow = init3.follow !== void 0 ? init3.follow : input.follow !== void 0 ? input.follow : 20
        this.compress = init3.compress !== void 0 ? init3.compress : input.compress !== void 0 ? input.compress : true
        this.counter = init3.counter || input.counter || 0
        this.agent = init3.agent || input.agent
      }
      get method() {
        return this[INTERNALS$2].method
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL)
      }
      get headers() {
        return this[INTERNALS$2].headers
      }
      get redirect() {
        return this[INTERNALS$2].redirect
      }
      get signal() {
        return this[INTERNALS$2].signal
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new Request2(this)
      }
    }
    Body.mixIn(Request2.prototype)
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    })
    function getNodeRequestOptions(request3) {
      const parsedURL = request3[INTERNALS$2].parsedURL
      const headers = new Headers2(request3[INTERNALS$2].headers)
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*")
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported")
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported")
      }
      if (request3.signal && request3.body instanceof Stream2.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8")
      }
      let contentLengthValue = null
      if (request3.body == null && /^(POST|PUT)$/i.test(request3.method)) {
        contentLengthValue = "0"
      }
      if (request3.body != null) {
        const totalBytes = getTotalBytes(request3)
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes)
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue)
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)")
      }
      if (request3.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate")
      }
      let agent = request3.agent
      if (typeof agent === "function") {
        agent = agent(parsedURL)
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close")
      }
      return Object.assign({}, parsedURL, {
        method: request3.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      })
    }
    function AbortError(message) {
      Error.call(this, message)
      this.type = "aborted"
      this.message = message
      Error.captureStackTrace(this, this.constructor)
    }
    AbortError.prototype = Object.create(Error.prototype)
    AbortError.prototype.constructor = AbortError
    AbortError.prototype.name = "AbortError"
    var URL$1 = Url2.URL || whatwgUrl.URL
    var PassThrough$1 = Stream2.PassThrough
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname
      const dest = new URL$1(destination).hostname
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest)
    }
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative")
      }
      Body.Promise = fetch2.Promise
      return new fetch2.Promise(function (resolve2, reject) {
        const request3 = new Request2(url, opts)
        const options2 = getNodeRequestOptions(request3)
        const send = (options2.protocol === "https:" ? https : http).request
        const signal = request3.signal
        let response = null
        const abort = function abort2() {
          let error2 = new AbortError("The user aborted a request.")
          reject(error2)
          if (request3.body && request3.body instanceof Stream2.Readable) {
            request3.body.destroy(error2)
          }
          if (!response || !response.body)
            return
          response.body.emit("error", error2)
        }
        if (signal && signal.aborted) {
          abort()
          return
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort()
          finalize()
        }
        const req = send(options2)
        let reqTimeout
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize)
        }
        function finalize() {
          req.abort()
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize)
          clearTimeout(reqTimeout)
        }
        if (request3.timeout) {
          req.once("socket", function (socket) {
            reqTimeout = setTimeout(function () {
              reject(new FetchError(`network timeout at: ${request3.url}`, "request-timeout"))
              finalize()
            }, request3.timeout)
          })
        }
        req.on("error", function (err2) {
          reject(new FetchError(`request to ${request3.url} failed, reason: ${err2.message}`, "system", err2))
          finalize()
        })
        req.on("response", function (res) {
          clearTimeout(reqTimeout)
          const headers = createHeadersLenient(res.headers)
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location")
            let locationURL = null
            try {
              locationURL = location === null ? null : new URL$1(location, request3.url).toString()
            } catch (err2) {
              if (request3.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"))
                finalize()
                return
              }
            }
            switch (request3.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request3.url}`, "no-redirect"))
                finalize()
                return
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL)
                  } catch (err2) {
                    reject(err2)
                  }
                }
                break
              case "follow":
                if (locationURL === null) {
                  break
                }
                if (request3.counter >= request3.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request3.url}`, "max-redirect"))
                  finalize()
                  return
                }
                const requestOpts = {
                  headers: new Headers2(request3.headers),
                  follow: request3.follow,
                  counter: request3.counter + 1,
                  agent: request3.agent,
                  compress: request3.compress,
                  method: request3.method,
                  body: request3.body,
                  signal: request3.signal,
                  timeout: request3.timeout,
                  size: request3.size
                }
                if (!isDomainOrSubdomain(request3.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name)
                  }
                }
                if (res.statusCode !== 303 && request3.body && getTotalBytes(request3) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"))
                  finalize()
                  return
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request3.method === "POST") {
                  requestOpts.method = "GET"
                  requestOpts.body = void 0
                  requestOpts.headers.delete("content-length")
                }
                resolve2(fetch2(new Request2(locationURL, requestOpts)))
                finalize()
                return
            }
          }
          res.once("end", function () {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize)
          })
          let body = res.pipe(new PassThrough$1())
          const response_options = {
            url: request3.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request3.size,
            timeout: request3.timeout,
            counter: request3.counter
          }
          const codings = headers.get("Content-Encoding")
          if (!request3.compress || request3.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options)
            resolve2(response)
            return
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          }
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions))
            response = new Response(body, response_options)
            resolve2(response)
            return
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1())
            raw.once("data", function (chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate())
              } else {
                body = body.pipe(zlib.createInflateRaw())
              }
              response = new Response(body, response_options)
              resolve2(response)
            })
            return
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress())
            response = new Response(body, response_options)
            resolve2(response)
            return
          }
          response = new Response(body, response_options)
          resolve2(response)
        })
        writeToStream(req, request3)
      })
    }
    fetch2.isRedirect = function (code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308
    }
    fetch2.Promise = _globalThis.Promise
    module2.exports = exports = fetch2
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.default = exports
    exports.Headers = Headers2
    exports.Request = Request2
    exports.Response = Response
    exports.FetchError = FetchError
  }
})

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module2) {
    init_process()
    init_buffer()
    var nodeFetch = require_lib2()
    var realFetch = nodeFetch.default || nodeFetch
    var fetch2 = function (url, options2) {
      if (/^\/\//.test(url)) {
        url = "https:" + url
      }
      return realFetch.call(this, url, options2)
    }
    fetch2.ponyfill = true
    module2.exports = exports = fetch2
    exports.fetch = fetch2
    exports.Headers = nodeFetch.Headers
    exports.Request = nodeFetch.Request
    exports.Response = nodeFetch.Response
    exports.default = fetch2
  }
})

// node_modules/@anthropic-ai/sdk/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@anthropic-ai/sdk/build/src/index.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __awaiter = exports && exports.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve2) {
          resolve2(value)
        })
      }
      return new (P || (P = Promise))(function (resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value))
          } catch (e) {
            reject(e)
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value))
          } catch (e) {
            reject(e)
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next())
      })
    }
    var __importDefault = exports && exports.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : { "default": mod }
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.Client = exports.AI_PROMPT = exports.HUMAN_PROMPT = void 0
    var fetch_event_source_1 = require_cjs()
    var cross_fetch_1 = __importDefault(require_node_ponyfill())
    exports.HUMAN_PROMPT = "\n\nHuman:"
    exports.AI_PROMPT = "\n\nAssistant:"
    var CLIENT_ID = "anthropic-typescript/0.4.3"
    var DEFAULT_API_URL = "https://api.anthropic.com"
    var Event;
    (function (Event2) {
      Event2["Ping"] = "ping"
    })(Event || (Event = {}))
    var DONE_MESSAGE = "[DONE]"
    var Client = class {
      constructor(apiKey, options2) {
        var _a
        this.apiKey = apiKey
        this.apiUrl = (_a = options2 === null || options2 === void 0 ? void 0 : options2.apiUrl) !== null && _a !== void 0 ? _a : DEFAULT_API_URL
      }
      complete(params, options2) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield (0, cross_fetch_1.default)(`${this.apiUrl}/v1/complete`, {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              Client: CLIENT_ID,
              "X-API-Key": this.apiKey
            },
            body: JSON.stringify(Object.assign(Object.assign({}, params), { stream: false })),
            signal: options2 === null || options2 === void 0 ? void 0 : options2.signal
          })
          if (!response.ok) {
            const error2 = new Error(`Sampling error: ${response.status} ${response.statusText}`)
            console.error(error2)
            throw error2
          }
          const completion = yield response.json()
          return completion
        })
      }
      completeStream(params, { onOpen, onUpdate, signal }) {
        const abortController = new AbortController()
        return new Promise((resolve2, reject) => {
          signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", (event) => {
            abortController.abort(event)
            reject({
              name: "AbortError",
              message: "Caller aborted completeStream"
            })
          });
          (0, fetch_event_source_1.fetchEventSource)(`${this.apiUrl}/v1/complete`, {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              Client: CLIENT_ID,
              "X-API-Key": this.apiKey
            },
            body: JSON.stringify(Object.assign(Object.assign({}, params), { stream: true })),
            signal: abortController.signal,
            onopen: (response) => __awaiter(this, void 0, void 0, function* () {
              if (!response.ok) {
                abortController.abort()
                return reject(Error(`Failed to open sampling stream, HTTP status code ${response.status}: ${response.statusText}`))
              }
              if (onOpen) {
                yield Promise.resolve(onOpen(response))
              }
            }),
            onmessage: (ev) => {
              if (ev.event === Event.Ping) {
                return
              }
              if (ev.data === DONE_MESSAGE) {
                console.error("Unexpected done message before stop_reason has been issued")
                return
              }
              const completion = JSON.parse(ev.data)
              if (onUpdate) {
                Promise.resolve(onUpdate(completion)).catch((error2) => {
                  abortController.abort()
                  reject(error2)
                })
              }
              if (completion.stop_reason !== null) {
                abortController.abort()
                return resolve2(completion)
              }
            },
            onerror: (error2) => {
              console.error("Sampling error:", error2)
              abortController.abort()
              return reject(error2)
            }
          })
        })
      }
    }
    exports.Client = Client
  }
})

// node_modules/langchain/dist/util/set.js
function intersection(setA, setB) {
  const _intersection = /* @__PURE__ */ new Set()
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem)
    }
  }
  return _intersection
}
function union(setA, setB) {
  const _union = new Set(setA)
  for (const elem of setB) {
    _union.add(elem)
  }
  return _union
}
function difference(setA, setB) {
  const _difference = new Set(setA)
  for (const elem of setB) {
    _difference.delete(elem)
  }
  return _difference
}
var init_set = __esm({
  "node_modules/langchain/dist/util/set.js"() {
    init_process()
    init_buffer()
  }
})

// node_modules/langchain/dist/chains/sequential_chain.js
var sequential_chain_exports = {}
__export(sequential_chain_exports, {
  SequentialChain: () => SequentialChain,
  SimpleSequentialChain: () => SimpleSequentialChain
})
function formatSet(input) {
  return Array.from(input).map((i) => `"${i}"`).join(", ")
}
var SequentialChain, SimpleSequentialChain
var init_sequential_chain = __esm({
  "node_modules/langchain/dist/chains/sequential_chain.js"() {
    init_process()
    init_buffer()
    init_base5()
    init_set()
    SequentialChain = class extends BaseChain {
      get inputKeys() {
        return this.inputVariables
      }
      get outputKeys() {
        return this.outputVariables
      }
      constructor(fields) {
        var _a, _b
        super(fields)
        Object.defineProperty(this, "chains", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inputVariables", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "outputVariables", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "returnAll", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.chains = fields.chains
        this.inputVariables = fields.inputVariables
        this.outputVariables = (_a = fields.outputVariables) != null ? _a : []
        if (this.outputVariables.length > 0 && fields.returnAll) {
          throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.")
        }
        this.returnAll = (_b = fields.returnAll) != null ? _b : false
        this._validateChains()
      }
      /** @ignore */
      _validateChains() {
        var _a, _b
        if (this.chains.length === 0) {
          throw new Error("Sequential chain must have at least one chain.")
        }
        const memoryKeys = (_b = (_a = this.memory) == null ? void 0 : _a.memoryKeys) != null ? _b : []
        const inputKeysSet = new Set(this.inputKeys)
        const memoryKeysSet = new Set(memoryKeys)
        const keysIntersection = intersection(inputKeysSet, memoryKeysSet)
        if (keysIntersection.size > 0) {
          throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`)
        }
        const availableKeys = union(inputKeysSet, memoryKeysSet)
        for (const chain of this.chains) {
          const missingKeys = difference(new Set(chain.inputKeys), availableKeys)
          if (missingKeys.size > 0) {
            throw new Error(`Missing variables for chain "${chain._chainType()}": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`)
          }
          const outputKeysSet = new Set(chain.outputKeys)
          const overlappinOutputKeys = intersection(availableKeys, outputKeysSet)
          if (overlappinOutputKeys.size > 0) {
            throw new Error(`The following output variables for chain "${chain._chainType()}" are overlapping: ${formatSet(overlappinOutputKeys)}. This can lead to unexpected behaviour.`)
          }
          for (const outputKey of outputKeysSet) {
            availableKeys.add(outputKey)
          }
        }
        if (this.outputVariables.length === 0) {
          if (this.returnAll) {
            const outputKeys = difference(availableKeys, inputKeysSet)
            this.outputVariables = Array.from(outputKeys)
          } else {
            this.outputVariables = this.chains[this.chains.length - 1].outputKeys
          }
        } else {
          const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys))
          if (missingKeys.size > 0) {
            throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`)
          }
        }
      }
      /** @ignore */
      async _call(values, runManager) {
        let input = values
        const allChainValues = {}
        for (const chain of this.chains) {
          input = await chain.call(input, runManager == null ? void 0 : runManager.getChild())
          for (const key of Object.keys(input)) {
            allChainValues[key] = input[key]
          }
        }
        const output = {}
        for (const key of this.outputVariables) {
          output[key] = allChainValues[key]
        }
        return output
      }
      _chainType() {
        return "sequential_chain"
      }
      static async deserialize(data) {
        const chains = []
        const inputVariables = data.input_variables
        const outputVariables = data.output_variables
        const serializedChains = data.chains
        for (const serializedChain of serializedChains) {
          const deserializedChain = await BaseChain.deserialize(serializedChain)
          chains.push(deserializedChain)
        }
        return new SequentialChain({ chains, inputVariables, outputVariables })
      }
      serialize() {
        const chains = []
        for (const chain of this.chains) {
          chains.push(chain.serialize())
        }
        return {
          _type: this._chainType(),
          input_variables: this.inputVariables,
          output_variables: this.outputVariables,
          chains
        }
      }
    }
    SimpleSequentialChain = class extends BaseChain {
      get inputKeys() {
        return [this.inputKey]
      }
      get outputKeys() {
        return [this.outputKey]
      }
      constructor(fields) {
        var _a, _b
        super(fields.memory, fields.verbose, (_a = fields.callbacks) != null ? _a : fields.callbackManager)
        Object.defineProperty(this, "chains", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "input"
        })
        Object.defineProperty(this, "outputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "output"
        })
        Object.defineProperty(this, "trimOutputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.chains = fields.chains
        this.trimOutputs = (_b = fields.trimOutputs) != null ? _b : false
        this._validateChains()
      }
      /** @ignore */
      _validateChains() {
        for (const chain of this.chains) {
          if (chain.inputKeys.length !== 1) {
            throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`)
          }
          if (chain.outputKeys.length !== 1) {
            throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`)
          }
        }
      }
      /** @ignore */
      async _call(values, runManager) {
        let input = values[this.inputKey]
        for (const chain of this.chains) {
          input = await chain.run(input, runManager == null ? void 0 : runManager.getChild())
          if (this.trimOutputs) {
            input = input.trim()
          }
          await (runManager == null ? void 0 : runManager.handleText(input))
        }
        return { [this.outputKey]: input }
      }
      _chainType() {
        return "simple_sequential_chain"
      }
      static async deserialize(data) {
        const chains = []
        const serializedChains = data.chains
        for (const serializedChain of serializedChains) {
          const deserializedChain = await BaseChain.deserialize(serializedChain)
          chains.push(deserializedChain)
        }
        return new SimpleSequentialChain({ chains })
      }
      serialize() {
        const chains = []
        for (const chain of this.chains) {
          chains.push(chain.serialize())
        }
        return {
          _type: this._chainType(),
          chains
        }
      }
    }
  }
})

// node_modules/langchain/dist/prompts/template.js
var parseFString, interpolateFString, DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, renderTemplate, parseTemplate, checkValidTemplate
var init_template = __esm({
  "node_modules/langchain/dist/prompts/template.js"() {
    init_process()
    init_buffer()
    parseFString = (template2) => {
      const chars = template2.split("")
      const nodes = []
      const nextBracket = (bracket, start) => {
        for (let i2 = start; i2 < chars.length; i2 += 1) {
          if (bracket.includes(chars[i2])) {
            return i2
          }
        }
        return -1
      }
      let i = 0
      while (i < chars.length) {
        if (chars[i] === "{" && i + 1 < chars.length && chars[i + 1] === "{") {
          nodes.push({ type: "literal", text: "{" })
          i += 2
        } else if (chars[i] === "}" && i + 1 < chars.length && chars[i + 1] === "}") {
          nodes.push({ type: "literal", text: "}" })
          i += 2
        } else if (chars[i] === "{") {
          const j = nextBracket("}", i)
          if (j < 0) {
            throw new Error("Unclosed '{' in template.")
          }
          nodes.push({
            type: "variable",
            name: chars.slice(i + 1, j).join("")
          })
          i = j + 1
        } else if (chars[i] === "}") {
          throw new Error("Single '}' in template.")
        } else {
          const next = nextBracket("{}", i)
          const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join("")
          nodes.push({ type: "literal", text })
          i = next < 0 ? chars.length : next
        }
      }
      return nodes
    }
    interpolateFString = (template2, values) => parseFString(template2).reduce((res, node) => {
      if (node.type === "variable") {
        if (node.name in values) {
          return res + values[node.name]
        }
        throw new Error(`Missing value for input ${node.name}`)
      }
      return res + node.text
    }, "")
    DEFAULT_FORMATTER_MAPPING = {
      "f-string": interpolateFString,
      jinja2: (_, __) => ""
    }
    DEFAULT_PARSER_MAPPING = {
      "f-string": parseFString,
      jinja2: (_) => []
    }
    renderTemplate = (template2, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template2, inputValues)
    parseTemplate = (template2, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template2)
    checkValidTemplate = (template2, templateFormat, inputVariables) => {
      if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {
        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING)
        throw new Error(`Invalid template format. Got \`${templateFormat}\`;
                         should be one of ${validFormats}`)
      }
      try {
        const dummyInputs = inputVariables.reduce((acc, v) => {
          acc[v] = "foo"
          return acc
        }, {})
        renderTemplate(template2, templateFormat, dummyInputs)
      } catch (e) {
        throw new Error("Invalid prompt schema.")
      }
    }
  }
})

// node_modules/langchain/dist/prompts/few_shot.js
var few_shot_exports = {}
__export(few_shot_exports, {
  FewShotPromptTemplate: () => FewShotPromptTemplate
})
var FewShotPromptTemplate
var init_few_shot = __esm({
  "node_modules/langchain/dist/prompts/few_shot.js"() {
    init_process()
    init_buffer()
    init_base4()
    init_template()
    init_prompt()
    FewShotPromptTemplate = class extends BaseStringPromptTemplate {
      constructor(input) {
        super(input)
        Object.defineProperty(this, "examples", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "exampleSelector", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "examplePrompt", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "suffix", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ""
        })
        Object.defineProperty(this, "exampleSeparator", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "\n\n"
        })
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ""
        })
        Object.defineProperty(this, "templateFormat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "f-string"
        })
        Object.defineProperty(this, "validateTemplate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: true
        })
        Object.assign(this, input)
        if (this.examples !== void 0 && this.exampleSelector !== void 0) {
          throw new Error("Only one of 'examples' and 'example_selector' should be provided")
        }
        if (this.examples === void 0 && this.exampleSelector === void 0) {
          throw new Error("One of 'examples' and 'example_selector' should be provided")
        }
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables
          if (this.partialVariables) {
            totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables))
          }
          checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables)
        }
      }
      _getPromptType() {
        return "few_shot"
      }
      async getExamples(inputVariables) {
        if (this.examples !== void 0) {
          return this.examples
        }
        if (this.exampleSelector !== void 0) {
          return this.exampleSelector.selectExamples(inputVariables)
        }
        throw new Error("One of 'examples' and 'example_selector' should be provided")
      }
      async partial(values) {
        var _a
        const promptDict = { ...this }
        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values))
        promptDict.partialVariables = {
          ...(_a = this.partialVariables) != null ? _a : {},
          ...values
        }
        return new FewShotPromptTemplate(promptDict)
      }
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values)
        const examples = await this.getExamples(allValues)
        const exampleStrings = await Promise.all(examples.map((example) => this.examplePrompt.format(example)))
        const template2 = [this.prefix, ...exampleStrings, this.suffix].join(this.exampleSeparator)
        return renderTemplate(template2, this.templateFormat, allValues)
      }
      serialize() {
        if (this.exampleSelector || !this.examples) {
          throw new Error("Serializing an example selector is not currently supported")
        }
        if (this.outputParser !== void 0) {
          throw new Error("Serializing an output parser is not currently supported")
        }
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          example_prompt: this.examplePrompt.serialize(),
          example_separator: this.exampleSeparator,
          suffix: this.suffix,
          prefix: this.prefix,
          template_format: this.templateFormat,
          examples: this.examples
        }
      }
      static async deserialize(data) {
        const { example_prompt } = data
        if (!example_prompt) {
          throw new Error("Missing example prompt")
        }
        const examplePrompt = await PromptTemplate.deserialize(example_prompt)
        let examples
        if (Array.isArray(data.examples)) {
          examples = data.examples
        } else {
          throw new Error("Invalid examples format. Only list or string are supported.")
        }
        return new FewShotPromptTemplate({
          inputVariables: data.input_variables,
          examplePrompt,
          examples,
          exampleSeparator: data.example_separator,
          prefix: data.prefix,
          suffix: data.suffix,
          templateFormat: data.template_format
        })
      }
    }
  }
})

// node_modules/langchain/dist/prompts/base.js
var StringPromptValue, BasePromptTemplate, BaseStringPromptTemplate
var init_base4 = __esm({
  "node_modules/langchain/dist/prompts/base.js"() {
    init_process()
    init_buffer()
    init_schema()
    StringPromptValue = class extends BasePromptValue {
      constructor(value) {
        super()
        Object.defineProperty(this, "value", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.value = value
      }
      toString() {
        return this.value
      }
      toChatMessages() {
        return [new HumanChatMessage(this.value)]
      }
    }
    BasePromptTemplate = class {
      constructor(input) {
        Object.defineProperty(this, "inputVariables", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "outputParser", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "partialVariables", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        const { inputVariables } = input
        if (inputVariables.includes("stop")) {
          throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.")
        }
        Object.assign(this, input)
      }
      async mergePartialAndUserVariables(userVariables) {
        var _a
        const partialVariables = (_a = this.partialVariables) != null ? _a : {}
        const partialValues = {}
        for (const [key, value] of Object.entries(partialVariables)) {
          if (typeof value === "string") {
            partialValues[key] = value
          } else {
            partialValues[key] = await value()
          }
        }
        const allKwargs = { ...partialValues, ...userVariables }
        return allKwargs
      }
      /**
       * Load a prompt template from a json-like object describing it.
       *
       * @remarks
       * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can
       * reference remote resources that we read asynchronously with a web
       * request.
       */
      static async deserialize(data) {
        switch (data._type) {
          case "prompt": {
            const { PromptTemplate: PromptTemplate4 } = await Promise.resolve().then(() => (init_prompt(), prompt_exports))
            return PromptTemplate4.deserialize(data)
          }
          case void 0: {
            const { PromptTemplate: PromptTemplate4 } = await Promise.resolve().then(() => (init_prompt(), prompt_exports))
            return PromptTemplate4.deserialize({ ...data, _type: "prompt" })
          }
          case "few_shot": {
            const { FewShotPromptTemplate: FewShotPromptTemplate2 } = await Promise.resolve().then(() => (init_few_shot(), few_shot_exports))
            return FewShotPromptTemplate2.deserialize(data)
          }
          default:
            throw new Error(`Invalid prompt type in config: ${data._type}`)
        }
      }
    }
    BaseStringPromptTemplate = class extends BasePromptTemplate {
      async formatPromptValue(values) {
        const formattedPrompt = await this.format(values)
        return new StringPromptValue(formattedPrompt)
      }
    }
  }
})

// node_modules/langchain/dist/prompts/prompt.js
var prompt_exports = {}
__export(prompt_exports, {
  PromptTemplate: () => PromptTemplate
})
var PromptTemplate
var init_prompt = __esm({
  "node_modules/langchain/dist/prompts/prompt.js"() {
    init_process()
    init_buffer()
    init_base4()
    init_template()
    PromptTemplate = class extends BaseStringPromptTemplate {
      constructor(input) {
        super(input)
        Object.defineProperty(this, "template", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "templateFormat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "f-string"
        })
        Object.defineProperty(this, "validateTemplate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: true
        })
        Object.assign(this, input)
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables
          if (this.partialVariables) {
            totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables))
          }
          checkValidTemplate(this.template, this.templateFormat, totalInputVariables)
        }
      }
      _getPromptType() {
        return "prompt"
      }
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values)
        return renderTemplate(this.template, this.templateFormat, allValues)
      }
      /**
       * Take examples in list format with prefix and suffix to create a prompt.
       *
       * Intendend to be used a a way to dynamically create a prompt from examples.
       *
       * @param examples - List of examples to use in the prompt.
       * @param suffix - String to go after the list of examples. Should generally set up the user's input.
       * @param inputVariables - A list of variable names the final prompt template will expect
       * @param exampleSeparator - The separator to use in between examples
       * @param prefix - String that should go before any examples. Generally includes examples.
       *
       * @returns The final prompt template generated.
       */
      static fromExamples(examples, suffix, inputVariables, exampleSeparator = "\n\n", prefix = "") {
        const template2 = [prefix, ...examples, suffix].join(exampleSeparator)
        return new PromptTemplate({
          inputVariables,
          template: template2
        })
      }
      /**
       * Load prompt template from a template f-string
       */
      static fromTemplate(template2, { templateFormat = "f-string", ...rest } = {}) {
        const names = /* @__PURE__ */ new Set()
        parseTemplate(template2, templateFormat).forEach((node) => {
          if (node.type === "variable") {
            names.add(node.name)
          }
        })
        return new PromptTemplate({
          inputVariables: [...names],
          templateFormat,
          template: template2,
          ...rest
        })
      }
      async partial(values) {
        var _a
        const promptDict = { ...this }
        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values))
        promptDict.partialVariables = {
          ...(_a = this.partialVariables) != null ? _a : {},
          ...values
        }
        return new PromptTemplate(promptDict)
      }
      serialize() {
        if (this.outputParser !== void 0) {
          throw new Error("Cannot serialize a prompt template with an output parser")
        }
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          template: this.template,
          template_format: this.templateFormat
        }
      }
      static async deserialize(data) {
        if (!data.template) {
          throw new Error("Prompt template must have a template")
        }
        const res = new PromptTemplate({
          inputVariables: data.input_variables,
          template: data.template,
          templateFormat: data.template_format
        })
        return res
      }
    }
  }
})

// node_modules/langchain/dist/chains/combine_docs_chain.js
var combine_docs_chain_exports = {}
__export(combine_docs_chain_exports, {
  MapReduceDocumentsChain: () => MapReduceDocumentsChain,
  RefineDocumentsChain: () => RefineDocumentsChain,
  StuffDocumentsChain: () => StuffDocumentsChain
})
var StuffDocumentsChain, MapReduceDocumentsChain, RefineDocumentsChain
var init_combine_docs_chain = __esm({
  "node_modules/langchain/dist/chains/combine_docs_chain.js"() {
    init_process()
    init_buffer()
    init_base5()
    init_llm_chain()
    init_prompt()
    StuffDocumentsChain = class extends BaseChain {
      get inputKeys() {
        return [this.inputKey, ...this.llmChain.inputKeys]
      }
      get outputKeys() {
        return this.llmChain.outputKeys
      }
      constructor(fields) {
        var _a, _b
        super(fields)
        Object.defineProperty(this, "llmChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "input_documents"
        })
        Object.defineProperty(this, "documentVariableName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "context"
        })
        this.llmChain = fields.llmChain
        this.documentVariableName = (_a = fields.documentVariableName) != null ? _a : this.documentVariableName
        this.inputKey = (_b = fields.inputKey) != null ? _b : this.inputKey
      }
      /** @ignore */
      async _call(values, runManager) {
        if (!(this.inputKey in values)) {
          throw new Error(`Document key ${this.inputKey} not found.`)
        }
        const { [this.inputKey]: docs, ...rest } = values
        const texts = docs.map(({ pageContent }) => pageContent)
        const text = texts.join("\n\n")
        const result = await this.llmChain.call({
          ...rest,
          [this.documentVariableName]: text
        }, runManager == null ? void 0 : runManager.getChild())
        return result
      }
      _chainType() {
        return "stuff_documents_chain"
      }
      static async deserialize(data) {
        if (!data.llm_chain) {
          throw new Error("Missing llm_chain")
        }
        return new StuffDocumentsChain({
          llmChain: await LLMChain.deserialize(data.llm_chain)
        })
      }
      serialize() {
        return {
          _type: this._chainType(),
          llm_chain: this.llmChain.serialize()
        }
      }
    }
    MapReduceDocumentsChain = class extends BaseChain {
      get inputKeys() {
        return [this.inputKey, ...this.combineDocumentChain.inputKeys]
      }
      get outputKeys() {
        return this.combineDocumentChain.outputKeys
      }
      constructor(fields) {
        var _a, _b, _c, _d, _e
        super(fields)
        Object.defineProperty(this, "llmChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "input_documents"
        })
        Object.defineProperty(this, "documentVariableName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "context"
        })
        Object.defineProperty(this, "maxTokens", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3e3
        })
        Object.defineProperty(this, "maxIterations", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 10
        })
        Object.defineProperty(this, "ensureMapStep", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        Object.defineProperty(this, "combineDocumentChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.llmChain = fields.llmChain
        this.combineDocumentChain = fields.combineDocumentChain
        this.documentVariableName = (_a = fields.documentVariableName) != null ? _a : this.documentVariableName
        this.ensureMapStep = (_b = fields.ensureMapStep) != null ? _b : this.ensureMapStep
        this.inputKey = (_c = fields.inputKey) != null ? _c : this.inputKey
        this.maxTokens = (_d = fields.maxTokens) != null ? _d : this.maxTokens
        this.maxIterations = (_e = fields.maxIterations) != null ? _e : this.maxIterations
      }
      /** @ignore */
      async _call(values, runManager) {
        if (!(this.inputKey in values)) {
          throw new Error(`Document key ${this.inputKey} not found.`)
        }
        const { [this.inputKey]: docs, ...rest } = values
        let currentDocs = docs
        for (let i = 0; i < this.maxIterations; i += 1) {
          const inputs = currentDocs.map((d) => ({
            [this.documentVariableName]: d.pageContent,
            ...rest
          }))
          const promises = inputs.map(async (i2) => {
            const prompt = await this.llmChain.prompt.format(i2)
            return this.llmChain.llm.getNumTokens(prompt)
          })
          const length = await Promise.all(promises).then((results2) => results2.reduce((a, b) => a + b, 0))
          const canSkipMapStep = i !== 0 || !this.ensureMapStep
          const withinTokenLimit = length < this.maxTokens
          if (canSkipMapStep && withinTokenLimit) {
            break
          }
          const results = await this.llmChain.apply(inputs, runManager ? [runManager.getChild()] : void 0)
          const { outputKey } = this.llmChain
          currentDocs = results.map((r) => ({
            pageContent: r[outputKey]
          }))
        }
        const newInputs = { input_documents: currentDocs, ...rest }
        const result = await this.combineDocumentChain.call(newInputs, runManager == null ? void 0 : runManager.getChild())
        return result
      }
      _chainType() {
        return "map_reduce_documents_chain"
      }
      static async deserialize(data) {
        if (!data.llm_chain) {
          throw new Error("Missing llm_chain")
        }
        if (!data.combine_document_chain) {
          throw new Error("Missing combine_document_chain")
        }
        return new MapReduceDocumentsChain({
          llmChain: await LLMChain.deserialize(data.llm_chain),
          combineDocumentChain: await BaseChain.deserialize(data.combine_document_chain)
        })
      }
      serialize() {
        return {
          _type: this._chainType(),
          llm_chain: this.llmChain.serialize(),
          combine_document_chain: this.combineDocumentChain.serialize()
        }
      }
    }
    RefineDocumentsChain = class extends BaseChain {
      get defaultDocumentPrompt() {
        return new PromptTemplate({
          inputVariables: ["page_content"],
          template: "{page_content}"
        })
      }
      get inputKeys() {
        return [this.inputKey, ...this.refineLLMChain.inputKeys]
      }
      get outputKeys() {
        return [this.outputKey]
      }
      constructor(fields) {
        var _a, _b, _c, _d, _e
        super(fields)
        Object.defineProperty(this, "llmChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "inputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "input_documents"
        })
        Object.defineProperty(this, "outputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "output_text"
        })
        Object.defineProperty(this, "documentVariableName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "context"
        })
        Object.defineProperty(this, "initialResponseName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "existing_answer"
        })
        Object.defineProperty(this, "refineLLMChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "documentPrompt", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: this.defaultDocumentPrompt
        })
        this.llmChain = fields.llmChain
        this.refineLLMChain = fields.refineLLMChain
        this.documentVariableName = (_a = fields.documentVariableName) != null ? _a : this.documentVariableName
        this.inputKey = (_b = fields.inputKey) != null ? _b : this.inputKey
        this.outputKey = (_c = fields.outputKey) != null ? _c : this.outputKey
        this.documentPrompt = (_d = fields.documentPrompt) != null ? _d : this.documentPrompt
        this.initialResponseName = (_e = fields.initialResponseName) != null ? _e : this.initialResponseName
      }
      /** @ignore */
      async _constructInitialInputs(doc, rest) {
        const baseInfo = {
          page_content: doc.pageContent,
          ...doc.metadata
        }
        const documentInfo = {}
        this.documentPrompt.inputVariables.forEach((value) => {
          documentInfo[value] = baseInfo[value]
        })
        const baseInputs = {
          [this.documentVariableName]: await this.documentPrompt.format({
            ...documentInfo
          })
        }
        const inputs = { ...baseInputs, ...rest }
        return inputs
      }
      /** @ignore */
      async _constructRefineInputs(doc, res) {
        const baseInfo = {
          page_content: doc.pageContent,
          ...doc.metadata
        }
        const documentInfo = {}
        this.documentPrompt.inputVariables.forEach((value) => {
          documentInfo[value] = baseInfo[value]
        })
        const baseInputs = {
          [this.documentVariableName]: await this.documentPrompt.format({
            ...documentInfo
          })
        }
        const inputs = { [this.initialResponseName]: res, ...baseInputs }
        return inputs
      }
      /** @ignore */
      async _call(values, runManager) {
        if (!(this.inputKey in values)) {
          throw new Error(`Document key ${this.inputKey} not found.`)
        }
        const { [this.inputKey]: docs, ...rest } = values
        const currentDocs = docs
        const initialInputs = await this._constructInitialInputs(currentDocs[0], rest)
        let res = await this.llmChain.predict({ ...initialInputs }, runManager == null ? void 0 : runManager.getChild())
        const refineSteps = [res]
        for (let i = 1; i < currentDocs.length; i += 1) {
          const refineInputs = await this._constructRefineInputs(currentDocs[i], res)
          const inputs = { ...refineInputs, ...rest }
          res = await this.refineLLMChain.predict({ ...inputs }, runManager == null ? void 0 : runManager.getChild())
          refineSteps.push(res)
        }
        return { [this.outputKey]: res }
      }
      _chainType() {
        return "refine_documents_chain"
      }
      static async deserialize(data) {
        const SerializedLLMChain = data.llm_chain
        if (!SerializedLLMChain) {
          throw new Error("Missing llm_chain")
        }
        const SerializedRefineDocumentChain = data.refine_llm_chain
        if (!SerializedRefineDocumentChain) {
          throw new Error("Missing refine_llm_chain")
        }
        return new RefineDocumentsChain({
          llmChain: await LLMChain.deserialize(SerializedLLMChain),
          refineLLMChain: await LLMChain.deserialize(SerializedRefineDocumentChain)
        })
      }
      serialize() {
        return {
          _type: this._chainType(),
          llm_chain: this.llmChain.serialize(),
          refine_llm_chain: this.refineLLMChain.serialize()
        }
      }
    }
  }
})

// node_modules/langchain/dist/prompts/chat.js
var BaseMessagePromptTemplate, ChatPromptValue, MessagesPlaceholder, BaseMessageStringPromptTemplate, BaseChatPromptTemplate, HumanMessagePromptTemplate, SystemMessagePromptTemplate, ChatPromptTemplate
var init_chat = __esm({
  "node_modules/langchain/dist/prompts/chat.js"() {
    init_process()
    init_buffer()
    init_schema()
    init_base4()
    init_prompt()
    BaseMessagePromptTemplate = class {
      serialize() {
        return {
          _type: this.constructor.name,
          ...JSON.parse(JSON.stringify(this))
        }
      }
    }
    ChatPromptValue = class extends BasePromptValue {
      constructor(messages2) {
        super()
        Object.defineProperty(this, "messages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.messages = messages2
      }
      toString() {
        return JSON.stringify(this.messages)
      }
      toChatMessages() {
        return this.messages
      }
    }
    MessagesPlaceholder = class extends BaseMessagePromptTemplate {
      constructor(variableName) {
        super()
        Object.defineProperty(this, "variableName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.variableName = variableName
      }
      get inputVariables() {
        return [this.variableName]
      }
      formatMessages(values) {
        return Promise.resolve(values[this.variableName])
      }
    }
    BaseMessageStringPromptTemplate = class extends BaseMessagePromptTemplate {
      constructor(prompt) {
        super()
        Object.defineProperty(this, "prompt", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.prompt = prompt
      }
      get inputVariables() {
        return this.prompt.inputVariables
      }
      async formatMessages(values) {
        return [await this.format(values)]
      }
    }
    BaseChatPromptTemplate = class extends BasePromptTemplate {
      constructor(input) {
        super(input)
      }
      async format(values) {
        return (await this.formatPromptValue(values)).toString()
      }
      async formatPromptValue(values) {
        const resultMessages = await this.formatMessages(values)
        return new ChatPromptValue(resultMessages)
      }
    }
    HumanMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
      async format(values) {
        return new HumanChatMessage(await this.prompt.format(values))
      }
      constructor(prompt) {
        super(prompt)
      }
      static fromTemplate(template2) {
        return new this(PromptTemplate.fromTemplate(template2))
      }
    }
    SystemMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
      async format(values) {
        return new SystemChatMessage(await this.prompt.format(values))
      }
      constructor(prompt) {
        super(prompt)
      }
      static fromTemplate(template2) {
        return new this(PromptTemplate.fromTemplate(template2))
      }
    }
    ChatPromptTemplate = class extends BaseChatPromptTemplate {
      constructor(input) {
        super(input)
        Object.defineProperty(this, "promptMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "validateTemplate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: true
        })
        Object.assign(this, input)
        if (this.validateTemplate) {
          const inputVariablesMessages = /* @__PURE__ */ new Set()
          for (const promptMessage of this.promptMessages) {
            for (const inputVariable of promptMessage.inputVariables) {
              inputVariablesMessages.add(inputVariable)
            }
          }
          const inputVariablesInstance = new Set(this.partialVariables ? this.inputVariables.concat(Object.keys(this.partialVariables)) : this.inputVariables)
          const difference2 = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)))
          if (difference2.size > 0) {
            throw new Error(`Input variables \`${[
              ...difference2
            ]}\` are not used in any of the prompt messages.`)
          }
          const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)))
          if (otherDifference.size > 0) {
            throw new Error(`Input variables \`${[
              ...otherDifference
            ]}\` are used in prompt messages but not in the prompt template.`)
          }
        }
      }
      _getPromptType() {
        return "chat"
      }
      async formatMessages(values) {
        const allValues = await this.mergePartialAndUserVariables(values)
        let resultMessages = []
        for (const promptMessage of this.promptMessages) {
          const inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {
            if (!(inputVariable in allValues)) {
              throw new Error(`Missing value for input variable \`${inputVariable}\``)
            }
            acc[inputVariable] = allValues[inputVariable]
            return acc
          }, {})
          const message = await promptMessage.formatMessages(inputValues)
          resultMessages = resultMessages.concat(message)
        }
        return resultMessages
      }
      serialize() {
        if (this.outputParser !== void 0) {
          throw new Error("ChatPromptTemplate cannot be serialized if outputParser is set")
        }
        return {
          input_variables: this.inputVariables,
          prompt_messages: this.promptMessages.map((m) => m.serialize())
        }
      }
      async partial(values) {
        var _a
        const promptDict = { ...this }
        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values))
        promptDict.partialVariables = {
          ...(_a = this.partialVariables) != null ? _a : {},
          ...values
        }
        return new ChatPromptTemplate(promptDict)
      }
      static fromPromptMessages(promptMessages) {
        const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(
          // eslint-disable-next-line no-instanceof/no-instanceof
          promptMessage instanceof ChatPromptTemplate ? promptMessage.promptMessages : [promptMessage]
        ), [])
        const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => (
          // eslint-disable-next-line no-instanceof/no-instanceof
          promptMessage instanceof ChatPromptTemplate ? Object.assign(acc, promptMessage.partialVariables) : acc
        ), /* @__PURE__ */ Object.create(null))
        const inputVariables = /* @__PURE__ */ new Set()
        for (const promptMessage of flattenedMessages) {
          for (const inputVariable of promptMessage.inputVariables) {
            if (inputVariable in flattenedPartialVariables) {
              continue
            }
            inputVariables.add(inputVariable)
          }
        }
        return new ChatPromptTemplate({
          inputVariables: [...inputVariables],
          promptMessages: flattenedMessages,
          partialVariables: flattenedPartialVariables
        })
      }
    }
  }
})

// node_modules/langchain/dist/chains/prompt_selector.js
function isChatModel(llm) {
  return llm._modelType() === "base_chat_model"
}
var BasePromptSelector, ConditionalPromptSelector
var init_prompt_selector = __esm({
  "node_modules/langchain/dist/chains/prompt_selector.js"() {
    init_process()
    init_buffer()
    BasePromptSelector = class {
    }
    ConditionalPromptSelector = class extends BasePromptSelector {
      constructor(default_prompt, conditionals = []) {
        super()
        Object.defineProperty(this, "defaultPrompt", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "conditionals", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.defaultPrompt = default_prompt
        this.conditionals = conditionals
      }
      getPrompt(llm) {
        for (const [condition, prompt] of this.conditionals) {
          if (condition(llm)) {
            return prompt
          }
        }
        return this.defaultPrompt
      }
    }
  }
})

// node_modules/langchain/dist/chains/question_answering/stuff_prompts.js
var DEFAULT_QA_PROMPT, system_template, messages, CHAT_PROMPT, QA_PROMPT_SELECTOR
var init_stuff_prompts = __esm({
  "node_modules/langchain/dist/chains/question_answering/stuff_prompts.js"() {
    init_process()
    init_buffer()
    init_prompt()
    init_chat()
    init_prompt_selector()
    DEFAULT_QA_PROMPT = /* @__PURE__ */ new PromptTemplate({
      template: "Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n\n{context}\n\nQuestion: {question}\nHelpful Answer:",
      inputVariables: ["context", "question"]
    })
    system_template = `Use the following pieces of context to answer the users question. 
If you don't know the answer, just say that you don't know, don't try to make up an answer.
----------------
{context}`
    messages = [
      /* @__PURE__ */ SystemMessagePromptTemplate.fromTemplate(system_template),
      /* @__PURE__ */ HumanMessagePromptTemplate.fromTemplate("{question}")
    ]
    CHAT_PROMPT = /* @__PURE__ */ ChatPromptTemplate.fromPromptMessages(messages)
    QA_PROMPT_SELECTOR = /* @__PURE__ */ new ConditionalPromptSelector(DEFAULT_QA_PROMPT, [[isChatModel, CHAT_PROMPT]])
  }
})

// node_modules/langchain/dist/chains/question_answering/map_reduce_prompts.js
var init_map_reduce_prompts = __esm({
  "node_modules/langchain/dist/chains/question_answering/map_reduce_prompts.js"() {
    init_process()
    init_buffer()
    init_prompt()
    init_chat()
    init_prompt_selector()
  }
})

// node_modules/langchain/dist/prompts/selectors/LengthBasedExampleSelector.js
var init_LengthBasedExampleSelector = __esm({
  "node_modules/langchain/dist/prompts/selectors/LengthBasedExampleSelector.js"() {
    init_process()
    init_buffer()
  }
})

// node_modules/langchain/dist/document.js
var Document
var init_document = __esm({
  "node_modules/langchain/dist/document.js"() {
    init_process()
    init_buffer()
    Document = class {
      constructor(fields) {
        var _a
        Object.defineProperty(this, "pageContent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "metadata", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.pageContent = fields.pageContent ? fields.pageContent.toString() : this.pageContent
        this.metadata = (_a = fields.metadata) != null ? _a : {}
      }
    }
  }
})

// node_modules/langchain/dist/prompts/selectors/SemanticSimilarityExampleSelector.js
var init_SemanticSimilarityExampleSelector = __esm({
  "node_modules/langchain/dist/prompts/selectors/SemanticSimilarityExampleSelector.js"() {
    init_process()
    init_buffer()
    init_document()
  }
})

// node_modules/langchain/dist/prompts/index.js
var init_prompts = __esm({
  "node_modules/langchain/dist/prompts/index.js"() {
    init_process()
    init_buffer()
    init_base4()
    init_prompt()
    init_LengthBasedExampleSelector()
    init_SemanticSimilarityExampleSelector()
    init_few_shot()
    init_chat()
    init_template()
  }
})

// node_modules/langchain/dist/chains/question_answering/refine_prompts.js
var init_refine_prompts = __esm({
  "node_modules/langchain/dist/chains/question_answering/refine_prompts.js"() {
    init_process()
    init_buffer()
    init_prompts()
    init_prompt_selector()
  }
})

// node_modules/langchain/dist/chains/question_answering/load.js
var loadQAStuffChain
var init_load = __esm({
  "node_modules/langchain/dist/chains/question_answering/load.js"() {
    init_process()
    init_buffer()
    init_llm_chain()
    init_combine_docs_chain()
    init_stuff_prompts()
    init_map_reduce_prompts()
    init_refine_prompts()
    loadQAStuffChain = (llm, params = {}) => {
      const { prompt = QA_PROMPT_SELECTOR.getPrompt(llm) } = params
      const llmChain = new LLMChain({ prompt, llm })
      const chain = new StuffDocumentsChain({ llmChain })
      return chain
    }
  }
})

// node_modules/langchain/dist/chains/vector_db_qa.js
var vector_db_qa_exports = {}
__export(vector_db_qa_exports, {
  VectorDBQAChain: () => VectorDBQAChain
})
var VectorDBQAChain
var init_vector_db_qa = __esm({
  "node_modules/langchain/dist/chains/vector_db_qa.js"() {
    init_process()
    init_buffer()
    init_base5()
    init_load()
    VectorDBQAChain = class extends BaseChain {
      get inputKeys() {
        return [this.inputKey]
      }
      get outputKeys() {
        return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : [])
      }
      constructor(fields) {
        var _a, _b, _c
        super(fields)
        Object.defineProperty(this, "k", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 4
        })
        Object.defineProperty(this, "inputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "query"
        })
        Object.defineProperty(this, "vectorstore", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "combineDocumentsChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "returnSourceDocuments", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        })
        this.vectorstore = fields.vectorstore
        this.combineDocumentsChain = fields.combineDocumentsChain
        this.inputKey = (_a = fields.inputKey) != null ? _a : this.inputKey
        this.k = (_b = fields.k) != null ? _b : this.k
        this.returnSourceDocuments = (_c = fields.returnSourceDocuments) != null ? _c : this.returnSourceDocuments
      }
      /** @ignore */
      async _call(values, runManager) {
        if (!(this.inputKey in values)) {
          throw new Error(`Question key ${this.inputKey} not found.`)
        }
        const question = values[this.inputKey]
        const docs = await this.vectorstore.similaritySearch(question, this.k)
        const inputs = { question, input_documents: docs }
        const result = await this.combineDocumentsChain.call(inputs, runManager == null ? void 0 : runManager.getChild())
        if (this.returnSourceDocuments) {
          return {
            ...result,
            sourceDocuments: docs
          }
        }
        return result
      }
      _chainType() {
        return "vector_db_qa"
      }
      static async deserialize(data, values) {
        if (!("vectorstore" in values)) {
          throw new Error(`Need to pass in a vectorstore to deserialize VectorDBQAChain`)
        }
        const { vectorstore } = values
        if (!data.combine_documents_chain) {
          throw new Error(`VectorDBQAChain must have combine_documents_chain in serialized data`)
        }
        return new VectorDBQAChain({
          combineDocumentsChain: await BaseChain.deserialize(data.combine_documents_chain),
          k: data.k,
          vectorstore
        })
      }
      serialize() {
        return {
          _type: this._chainType(),
          combine_documents_chain: this.combineDocumentsChain.serialize(),
          k: this.k
        }
      }
      static fromLLM(llm, vectorstore, options2) {
        const qaChain = loadQAStuffChain(llm)
        return new this({
          vectorstore,
          combineDocumentsChain: qaChain,
          ...options2
        })
      }
    }
  }
})

// node_modules/langchain/dist/chains/base.js
var BaseChain
var init_base5 = __esm({
  "node_modules/langchain/dist/chains/base.js"() {
    init_process()
    init_buffer()
    init_schema()
    init_manager()
    init_base_language()
    BaseChain = class extends BaseLangChain {
      constructor(fields, verbose, callbacks) {
        if (arguments.length === 1 && typeof fields === "object" && !("saveContext" in fields)) {
          const { memory, callbackManager, ...rest } = fields
          super({ ...rest, callbacks: callbackManager != null ? callbackManager : rest.callbacks })
          this.memory = memory
        } else {
          super({ verbose, callbacks })
          this.memory = fields
        }
      }
      /**
       * Return a json-like object representing this chain.
       */
      serialize() {
        throw new Error("Method not implemented.")
      }
      async run(input, callbacks) {
        const isKeylessInput = this.inputKeys.length <= 1
        if (!isKeylessInput) {
          throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `)
        }
        const values = this.inputKeys.length ? { [this.inputKeys[0]]: input } : {}
        const returnValues = await this.call(values, callbacks)
        const keys2 = Object.keys(returnValues)
        if (keys2.length === 1) {
          return returnValues[keys2[0]]
        }
        throw new Error("return values have multiple keys, `run` only supported when one key currently")
      }
      /**
       * Run the core logic of this chain and add to output if desired.
       *
       * Wraps _call and handles memory.
       */
      async call(values, callbacks) {
        const fullValues = { ...values }
        if (!(this.memory == null)) {
          const newValues = await this.memory.loadMemoryVariables(values)
          for (const [key, value] of Object.entries(newValues)) {
            fullValues[key] = value
          }
        }
        const callbackManager_ = await CallbackManager.configure(callbacks, this.callbacks, { verbose: this.verbose })
        const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart({ name: this._chainType() }, fullValues))
        let outputValues
        try {
          outputValues = await this._call(fullValues, runManager)
        } catch (e) {
          await (runManager == null ? void 0 : runManager.handleChainError(e))
          throw e
        }
        await (runManager == null ? void 0 : runManager.handleChainEnd(outputValues))
        if (!(this.memory == null)) {
          await this.memory.saveContext(values, outputValues)
        }
        Object.defineProperty(outputValues, RUN_KEY, {
          value: runManager ? { runId: runManager == null ? void 0 : runManager.runId } : void 0,
          configurable: true
        })
        return outputValues
      }
      /**
       * Call the chain on all inputs in the list
       */
      async apply(inputs, callbacks) {
        return Promise.all(inputs.map(async (i, idx) => this.call(i, callbacks == null ? void 0 : callbacks[idx])))
      }
      /**
       * Load a chain from a json-like object describing it.
       */
      static async deserialize(data, values = {}) {
        switch (data._type) {
          case "llm_chain": {
            const { LLMChain: LLMChain2 } = await Promise.resolve().then(() => (init_llm_chain(), llm_chain_exports))
            return LLMChain2.deserialize(data)
          }
          case "sequential_chain": {
            const { SequentialChain: SequentialChain2 } = await Promise.resolve().then(() => (init_sequential_chain(), sequential_chain_exports))
            return SequentialChain2.deserialize(data)
          }
          case "simple_sequential_chain": {
            const { SimpleSequentialChain: SimpleSequentialChain2 } = await Promise.resolve().then(() => (init_sequential_chain(), sequential_chain_exports))
            return SimpleSequentialChain2.deserialize(data)
          }
          case "stuff_documents_chain": {
            const { StuffDocumentsChain: StuffDocumentsChain2 } = await Promise.resolve().then(() => (init_combine_docs_chain(), combine_docs_chain_exports))
            return StuffDocumentsChain2.deserialize(data)
          }
          case "map_reduce_documents_chain": {
            const { MapReduceDocumentsChain: MapReduceDocumentsChain2 } = await Promise.resolve().then(() => (init_combine_docs_chain(), combine_docs_chain_exports))
            return MapReduceDocumentsChain2.deserialize(data)
          }
          case "refine_documents_chain": {
            const { RefineDocumentsChain: RefineDocumentsChain2 } = await Promise.resolve().then(() => (init_combine_docs_chain(), combine_docs_chain_exports))
            return RefineDocumentsChain2.deserialize(data)
          }
          case "vector_db_qa": {
            const { VectorDBQAChain: VectorDBQAChain2 } = await Promise.resolve().then(() => (init_vector_db_qa(), vector_db_qa_exports))
            return VectorDBQAChain2.deserialize(data, values)
          }
          default:
            throw new Error(`Invalid prompt type in config: ${data._type}`)
        }
      }
    }
  }
})

// node_modules/langchain/dist/chains/llm_chain.js
var llm_chain_exports = {}
__export(llm_chain_exports, {
  LLMChain: () => LLMChain
})
var LLMChain
var init_llm_chain = __esm({
  "node_modules/langchain/dist/chains/llm_chain.js"() {
    init_process()
    init_buffer()
    init_base5()
    init_base4()
    init_base_language()
    LLMChain = class extends BaseChain {
      get inputKeys() {
        return this.prompt.inputVariables
      }
      get outputKeys() {
        return [this.outputKey]
      }
      constructor(fields) {
        var _a, _b
        super(fields)
        Object.defineProperty(this, "prompt", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "llm", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "outputKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "text"
        })
        Object.defineProperty(this, "outputParser", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.prompt = fields.prompt
        this.llm = fields.llm
        this.outputKey = (_a = fields.outputKey) != null ? _a : this.outputKey
        this.outputParser = (_b = fields.outputParser) != null ? _b : this.outputParser
        if (this.prompt.outputParser) {
          if (this.outputParser) {
            throw new Error("Cannot set both outputParser and prompt.outputParser")
          }
          this.outputParser = this.prompt.outputParser
        }
      }
      /** @ignore */
      async _getFinalOutput(generations, promptValue, runManager) {
        const completion = generations[0].text
        let finalCompletion
        if (this.outputParser) {
          finalCompletion = await this.outputParser.parseWithPrompt(completion, promptValue, runManager == null ? void 0 : runManager.getChild())
        } else {
          finalCompletion = completion
        }
        return finalCompletion
      }
      /** @ignore */
      async _call(values, runManager) {
        let stop
        if ("stop" in values && Array.isArray(values.stop)) {
          stop = values.stop
        }
        const promptValue = await this.prompt.formatPromptValue(values)
        const { generations } = await this.llm.generatePrompt([promptValue], stop, runManager == null ? void 0 : runManager.getChild())
        return {
          [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager)
        }
      }
      /**
       * Format prompt with values and pass to LLM
       *
       * @param values - keys to pass to prompt template
       * @param callbackManager - CallbackManager to use
       * @returns Completion from LLM.
       *
       * @example
       * ```ts
       * llm.predict({ adjective: "funny" })
       * ```
       */
      async predict(values, callbackManager) {
        const output = await this.call(values, callbackManager)
        return output[this.outputKey]
      }
      _chainType() {
        return "llm_chain"
      }
      static async deserialize(data) {
        const { llm, prompt } = data
        if (!llm) {
          throw new Error("LLMChain must have llm")
        }
        if (!prompt) {
          throw new Error("LLMChain must have prompt")
        }
        return new LLMChain({
          llm: await BaseLanguageModel.deserialize(llm),
          prompt: await BasePromptTemplate.deserialize(prompt)
        })
      }
      serialize() {
        return {
          _type: this._chainType(),
          llm: this.llm.serialize(),
          prompt: this.prompt.serialize()
        }
      }
    }
  }
})

// node_modules/langchain/dist/agents/helpers.js
var deserializeHelper
var init_helpers = __esm({
  "node_modules/langchain/dist/agents/helpers.js"() {
    init_process()
    init_buffer()
    init_llm_chain()
    deserializeHelper = async (llm, tools, data, fromLLMAndTools, fromConstructor) => {
      if (data.load_from_llm_and_tools) {
        if (!llm) {
          throw new Error("Loading from llm and tools, llm must be provided.")
        }
        if (!tools) {
          throw new Error("Loading from llm and tools, tools must be provided.")
        }
        return fromLLMAndTools(llm, tools, data)
      }
      if (!data.llm_chain) {
        throw new Error("Loading from constructor, llm_chain must be provided.")
      }
      const llmChain = await LLMChain.deserialize(data.llm_chain)
      return fromConstructor({ ...data, llmChain })
    }
  }
})

// node_modules/langchain/dist/schema/output_parser.js
var BaseOutputParser
var init_output_parser = __esm({
  "node_modules/langchain/dist/schema/output_parser.js"() {
    init_process()
    init_buffer()
    BaseOutputParser = class {
      async parseWithPrompt(text, _prompt, callbacks) {
        return this.parse(text, callbacks)
      }
      /**
       * Return the string type key uniquely identifying this class of parser
       */
      _type() {
        throw new Error("_type not implemented")
      }
    }
  }
})

// node_modules/langchain/dist/agents/types.js
var AgentActionOutputParser
var init_types = __esm({
  "node_modules/langchain/dist/agents/types.js"() {
    init_process()
    init_buffer()
    init_output_parser()
    AgentActionOutputParser = class extends BaseOutputParser {
    }
  }
})

// node_modules/langchain/dist/agents/mrkl/prompt.js
var PREFIX, FORMAT_INSTRUCTIONS, SUFFIX
var init_prompt2 = __esm({
  "node_modules/langchain/dist/agents/mrkl/prompt.js"() {
    init_process()
    init_buffer()
    PREFIX = `Answer the following questions as best you can. You have access to the following tools:`
    FORMAT_INSTRUCTIONS = `Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`
    SUFFIX = `Begin!

Question: {input}
Thought:{agent_scratchpad}`
  }
})

// node_modules/langchain/dist/agents/mrkl/outputParser.js
var FINAL_ANSWER_ACTION, ZeroShotAgentOutputParser
var init_outputParser = __esm({
  "node_modules/langchain/dist/agents/mrkl/outputParser.js"() {
    init_process()
    init_buffer()
    init_types()
    init_prompt2()
    FINAL_ANSWER_ACTION = "Final Answer:"
    ZeroShotAgentOutputParser = class extends AgentActionOutputParser {
      constructor(fields) {
        super()
        Object.defineProperty(this, "finishToolName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.finishToolName = (fields == null ? void 0 : fields.finishToolName) || FINAL_ANSWER_ACTION
      }
      async parse(text) {
        var _a
        if (text.includes(this.finishToolName)) {
          const parts = text.split(this.finishToolName)
          const output = parts[parts.length - 1].trim()
          return {
            returnValues: { output },
            log: text
          }
        }
        const match = /Action: ([\s\S]*)\nAction Input: ([\s\S]*)/.exec(text)
        if (!match) {
          throw new Error(`Could not parse LLM output: ${text}`)
        }
        return {
          tool: match[1].trim(),
          toolInput: (_a = match[2].trim().replace(/^"+|"+$/g, "")) != null ? _a : "",
          log: text
        }
      }
      getFormatInstructions() {
        return FORMAT_INSTRUCTIONS
      }
    }
  }
})

// node_modules/langchain/dist/agents/mrkl/index.js
var mrkl_exports = {}
__export(mrkl_exports, {
  ZeroShotAgent: () => ZeroShotAgent
})
var ZeroShotAgent
var init_mrkl = __esm({
  "node_modules/langchain/dist/agents/mrkl/index.js"() {
    init_process()
    init_buffer()
    init_llm_chain()
    init_prompt()
    init_template()
    init_agent()
    init_helpers()
    init_outputParser()
    init_prompt2()
    ZeroShotAgent = class extends Agent3 {
      constructor(input) {
        var _a
        const outputParser = (_a = input == null ? void 0 : input.outputParser) != null ? _a : ZeroShotAgent.getDefaultOutputParser()
        super({ ...input, outputParser })
      }
      _agentType() {
        return "zero-shot-react-description"
      }
      observationPrefix() {
        return "Observation: "
      }
      llmPrefix() {
        return "Thought:"
      }
      static getDefaultOutputParser(fields) {
        return new ZeroShotAgentOutputParser(fields)
      }
      static validateTools(tools) {
        const invalidTool = tools.find((tool) => !tool.description)
        if (invalidTool) {
          const msg = `Got a tool ${invalidTool.name} without a description. This agent requires descriptions for all tools.`
          throw new Error(msg)
        }
      }
      /**
       * Create prompt in the style of the zero shot agent.
       *
       * @param tools - List of tools the agent will have access to, used to format the prompt.
       * @param args - Arguments to create the prompt with.
       * @param args.suffix - String to put after the list of tools.
       * @param args.prefix - String to put before the list of tools.
       * @param args.inputVariables - List of input variables the final prompt will expect.
       */
      static createPrompt(tools, args) {
        const { prefix = PREFIX, suffix = SUFFIX, inputVariables = ["input", "agent_scratchpad"] } = args != null ? args : {}
        const toolStrings = tools.map((tool) => `${tool.name}: ${tool.description}`).join("\n")
        const toolNames = tools.map((tool) => tool.name)
        const formatInstructions = renderTemplate(FORMAT_INSTRUCTIONS, "f-string", {
          tool_names: toolNames
        })
        const template2 = [prefix, toolStrings, formatInstructions, suffix].join("\n\n")
        return new PromptTemplate({
          template: template2,
          inputVariables
        })
      }
      static fromLLMAndTools(llm, tools, args) {
        var _a, _b
        ZeroShotAgent.validateTools(tools)
        const prompt = ZeroShotAgent.createPrompt(tools, args)
        const outputParser = (_a = args == null ? void 0 : args.outputParser) != null ? _a : ZeroShotAgent.getDefaultOutputParser()
        const chain = new LLMChain({
          prompt,
          llm,
          callbacks: (_b = args == null ? void 0 : args.callbacks) != null ? _b : args == null ? void 0 : args.callbackManager
        })
        return new ZeroShotAgent({
          llmChain: chain,
          allowedTools: tools.map((t) => t.name),
          outputParser
        })
      }
      static async deserialize(data) {
        const { llm, tools, ...rest } = data
        return deserializeHelper(llm, tools, rest, (llm2, tools2, args) => ZeroShotAgent.fromLLMAndTools(llm2, tools2, {
          prefix: args.prefix,
          suffix: args.suffix,
          inputVariables: args.input_variables
        }), (args) => new ZeroShotAgent(args))
      }
    }
  }
})

// node_modules/langchain/dist/agents/agent.js
var ParseError, BaseAgent, BaseSingleActionAgent, Agent3
var init_agent = __esm({
  "node_modules/langchain/dist/agents/agent.js"() {
    init_process()
    init_buffer()
    ParseError = class extends Error {
      constructor(msg, output) {
        super(msg)
        Object.defineProperty(this, "output", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.output = output
      }
    }
    BaseAgent = class {
      get returnValues() {
        return ["output"]
      }
      get allowedTools() {
        return void 0
      }
      /**
       * Return the string type key uniquely identifying this class of agent.
       */
      _agentType() {
        throw new Error("Not implemented")
      }
      /**
       * Return response when agent has been stopped due to max iterations
       */
      returnStoppedResponse(earlyStoppingMethod, _steps, _inputs, _callbackManager) {
        if (earlyStoppingMethod === "force") {
          return Promise.resolve({
            returnValues: { output: "Agent stopped due to max iterations." },
            log: ""
          })
        }
        throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`)
      }
      /**
       * Prepare the agent for output, if needed
       */
      async prepareForOutput(_returnValues, _steps) {
        return {}
      }
    }
    BaseSingleActionAgent = class extends BaseAgent {
      _agentActionType() {
        return "single"
      }
    }
    Agent3 = class extends BaseSingleActionAgent {
      get allowedTools() {
        return this._allowedTools
      }
      get inputKeys() {
        return this.llmChain.inputKeys.filter((k) => k !== "agent_scratchpad")
      }
      constructor(input) {
        super()
        Object.defineProperty(this, "llmChain", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "outputParser", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        Object.defineProperty(this, "_allowedTools", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        })
        this.llmChain = input.llmChain
        this._allowedTools = input.allowedTools
        this.outputParser = input.outputParser
      }
      /**
       * Get the default output parser for this agent.
       */
      static getDefaultOutputParser(_fields) {
        throw new Error("Not implemented")
      }
      /**
       * Create a prompt for this class
       *
       * @param _tools - List of tools the agent will have access to, used to format the prompt.
       * @param _fields - Additional fields used to format the prompt.
       *
       * @returns A PromptTemplate assembled from the given tools and fields.
       * */
      static createPrompt(_tools, _fields) {
        throw new Error("Not implemented")
      }
      /** Construct an agent from an LLM and a list of tools */
      static fromLLMAndTools(_llm, _tools, _args) {
        throw new Error("Not implemented")
      }
      /**
       * Validate that appropriate tools are passed in
       */
      static validateTools(_tools) {
      }
      _stop() {
        return [`
${this.observationPrefix()}`]
      }
      /**
       * Name of tool to use to terminate the chain.
       */
      finishToolName() {
        return "Final Answer"
      }
      /**
       * Construct a scratchpad to let the agent continue its thought process
       */
      async constructScratchPad(steps) {
        return steps.reduce((thoughts, { action, observation }) => thoughts + [
          action.log,
          `${this.observationPrefix()}${observation}`,
          this.llmPrefix()
        ].join("\n"), "")
      }
      async _plan(steps, inputs, suffix, callbackManager) {
        const thoughts = await this.constructScratchPad(steps)
        const newInputs = {
          ...inputs,
          agent_scratchpad: suffix ? `${thoughts}${suffix}` : thoughts
        }
        if (this._stop().length !== 0) {
          newInputs.stop = this._stop()
        }
        const output = await this.llmChain.predict(newInputs, callbackManager)
        return this.outputParser.parse(output, callbackManager)
      }
      /**
       * Decide what to do given some input.
       *
       * @param steps - Steps the LLM has taken so far, along with observations from each.
       * @param inputs - User inputs.
       * @param callbackManager - Callback manager to use for this call.
       *
       * @returns Action specifying what tool to use.
       */
      plan(steps, inputs, callbackManager) {
        return this._plan(steps, inputs, void 0, callbackManager)
      }
      /**
       * Return response when agent has been stopped due to max iterations
       */
      async returnStoppedResponse(earlyStoppingMethod, steps, inputs, callbackManager) {
        if (earlyStoppingMethod === "force") {
          return {
            returnValues: { output: "Agent stopped due to max iterations." },
            log: ""
          }
        }
        if (earlyStoppingMethod === "generate") {
          try {
            const action = await this._plan(steps, inputs, "\n\nI now need to return a final answer based on the previous steps:", callbackManager)
            if ("returnValues" in action) {
              return action
            }
            return { returnValues: { output: action.log }, log: action.log }
          } catch (err2) {
            if (!(err2 instanceof ParseError)) {
              throw err2
            }
            return { returnValues: { output: err2.output }, log: err2.output }
          }
        }
        throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`)
      }
      /**
       * Load an agent from a json-like object describing it.
       */
      static async deserialize(data) {
        switch (data._type) {
          case "zero-shot-react-description": {
            const { ZeroShotAgent: ZeroShotAgent2 } = await Promise.resolve().then(() => (init_mrkl(), mrkl_exports))
            return ZeroShotAgent2.deserialize(data)
          }
          default:
            throw new Error("Unknown agent type")
        }
      }
    }
  }
})

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports) {
    init_process()
    init_buffer()
    var hasExcape = /~/
    var escapeMatcher = /~[01]/g
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/"
        case "~0":
          return "~"
      }
      throw new Error("Invalid tilde escape: " + m)
    }
    function untilde(str) {
      if (!hasExcape.test(str))
        return str
      return str.replace(escapeMatcher, escapeReplacer)
    }
    function setter(obj, pointer, value) {
      var part
      var hasNextPart
      for (var p = 1, len = pointer.length; p < len;) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__")
          return obj
        part = untilde(pointer[p++])
        hasNextPart = len > p
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-")
              obj[part] = []
            else
              obj[part] = {}
          }
        }
        if (!hasNextPart)
          break
        obj = obj[part]
      }
      var oldValue = obj[part]
      if (value === void 0)
        delete obj[part]
      else
        obj[part] = value
      return oldValue
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/")
        if (pointer[0] === "")
          return pointer
        throw new Error("Invalid JSON pointer.")
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.")
          }
        }
        return pointer
      }
      throw new Error("Invalid JSON pointer.")
    }
    function get3(obj, pointer) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.")
      pointer = compilePointer(pointer)
      var len = pointer.length
      if (len === 1)
        return obj
      for (var p = 1; p < len;) {
        obj = obj[untilde(pointer[p++])]
        if (len === p)
          return obj
        if (typeof obj !== "object" || obj === null)
          return void 0
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.")
      pointer = compilePointer(pointer)
      if (pointer.length === 0)
        throw new Error("Invalid JSON pointer for set.")
      return setter(obj, pointer, value)
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer)
      return {
        get: function (object) {
          return get3(object, compiled)
        },
        set: function (object, value) {
          return set(object, compiled, value)
        }
      }
    }
    exports.get = get3
    exports.set = set
    exports.compile = compile
  }
})

// node_modules/langchain/dist/util/chunk.js
var init_chunk = __esm({
  "node_modules/langchain/dist/util/chunk.js"() {
    init_process()
    init_buffer()
  }
})

// node_modules/object-hash/crypto.js
var crypto_exports = {}
__export(crypto_exports, {
  crypto: () => crypto2
})
var Hash, crypto2
var init_crypto2 = __esm({
  "node_modules/object-hash/crypto.js"() {
    init_process()
    init_buffer()
    Hash = class {
      constructor(algorithm) {
        __publicField(this, "cryptoHash")
        __publicField(this, "data")
        this.cryptoHash = Components.classes["@mozilla.org/security/hash;1"].createInstance(
          Components.interfaces.nsICryptoHash
        )
        this.cryptoHash.init(this.getHashType(algorithm))
        this.data = ""
      }
      getHashType(algorithm) {
        switch (algorithm) {
          case "md5":
            return this.cryptoHash.MD5
          case "sha1":
            return this.cryptoHash.SHA1
          case "sha256":
            return this.cryptoHash.SHA256
          case "sha384":
            return this.cryptoHash.SHA384
          case "sha512":
            return this.cryptoHash.SHA512
          default:
            throw new Error(`Unsupported hash algorithm: ${algorithm}`)
        }
      }
      update(data) {
        this.data += data
      }
      digest(encoding) {
        const inputStream = Components.classes["@mozilla.org/io/string-input-stream;1"].createInstance(
          Components.interfaces.nsIStringInputStream
        )
        inputStream.setData(this.data, this.data.length)
        const result = this.cryptoHash.finish(encoding === "hex")
        return result
      }
    }
    crypto2 = {
      createHash: function (algorithm) {
        return new Hash(algorithm)
      }
    }
  }
})

// node_modules/object-hash/index.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/index.js"(exports, module2) {
    "use strict"
    init_process()
    init_buffer()
    var { crypto: crypto4 } = (init_crypto2(), __toCommonJS(crypto_exports))
    exports = module2.exports = objectHash
    function objectHash(object, options2) {
      options2 = applyDefaults(object, options2)
      return hash2(object, options2)
    }
    exports.sha1 = function (object) {
      return objectHash(object)
    }
    exports.keys = function (object) {
      return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" })
    }
    exports.MD5 = function (object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex" })
    }
    exports.keysMD5 = function (object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true })
    }
    var hashes = crypto4.getHashes ? crypto4.getHashes().slice() : ["sha1", "md5"]
    hashes.push("passthrough")
    var encodings = ["buffer", "hex", "binary", "base64"]
    function applyDefaults(object, sourceOptions) {
      sourceOptions = sourceOptions || {}
      var options2 = {}
      options2.algorithm = sourceOptions.algorithm || "sha1"
      options2.encoding = sourceOptions.encoding || "hex"
      options2.excludeValues = sourceOptions.excludeValues ? true : false
      options2.algorithm = options2.algorithm.toLowerCase()
      options2.encoding = options2.encoding.toLowerCase()
      options2.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true
      options2.respectType = sourceOptions.respectType === false ? false : true
      options2.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true
      options2.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true
      options2.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true
      options2.unorderedSets = sourceOptions.unorderedSets === false ? false : true
      options2.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true
      options2.replacer = sourceOptions.replacer || void 0
      options2.excludeKeys = sourceOptions.excludeKeys || void 0
      if (typeof object === "undefined") {
        throw new Error("Object argument required.")
      }
      for (var i = 0; i < hashes.length; ++i) {
        if (hashes[i].toLowerCase() === options2.algorithm.toLowerCase()) {
          options2.algorithm = hashes[i]
        }
      }
      if (hashes.indexOf(options2.algorithm) === -1) {
        throw new Error('Algorithm "' + options2.algorithm + '"  not supported. supported values: ' + hashes.join(", "))
      }
      if (encodings.indexOf(options2.encoding) === -1 && options2.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options2.encoding + '"  not supported. supported values: ' + encodings.join(", "))
      }
      return options2
    }
    function isNativeFunction(f) {
      if (typeof f !== "function") {
        return false
      }
      var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i
      return exp.exec(Function.prototype.toString.call(f)) != null
    }
    function hash2(object, options2) {
      var hashingStream
      if (options2.algorithm !== "passthrough") {
        hashingStream = crypto4.createHash(options2.algorithm)
      } else {
        hashingStream = new PassThrough2()
      }
      if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update
        hashingStream.end = hashingStream.update
      }
      var hasher = typeHasher(options2, hashingStream)
      hasher.dispatch(object)
      if (!hashingStream.update) {
        hashingStream.end("")
      }
      if (hashingStream.digest) {
        return hashingStream.digest(options2.encoding === "buffer" ? void 0 : options2.encoding)
      }
      var buf = hashingStream.read()
      if (options2.encoding === "buffer") {
        return buf
      }
      return buf.toString(options2.encoding)
    }
    exports.writeToStream = function (object, options2, stream) {
      if (typeof stream === "undefined") {
        stream = options2
        options2 = {}
      }
      options2 = applyDefaults(object, options2)
      return typeHasher(options2, stream).dispatch(object)
    }
    function typeHasher(options2, writeTo, context) {
      context = context || []
      var write4 = function (str) {
        if (writeTo.update) {
          return writeTo.update(str, "utf8")
        } else {
          return writeTo.write(str, "utf8")
        }
      }
      return {
        dispatch: function (value) {
          if (options2.replacer) {
            value = options2.replacer(value)
          }
          var type2 = typeof value
          if (value === null) {
            type2 = "null"
          }
          return this["_" + type2](value)
        },
        _object: function (object) {
          var pattern = /\[object (.*)\]/i
          var objString = Object.prototype.toString.call(object)
          var objType = pattern.exec(objString)
          if (!objType) {
            objType = "unknown:[" + objString + "]"
          } else {
            objType = objType[1]
          }
          objType = objType.toLowerCase()
          var objectNumber = null
          if ((objectNumber = context.indexOf(object)) >= 0) {
            return this.dispatch("[CIRCULAR:" + objectNumber + "]")
          } else {
            context.push(object)
          }
          if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer && Buffer2.isBuffer(object)) {
            write4("buffer:")
            return write4(object)
          }
          if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
            if (this["_" + objType]) {
              this["_" + objType](object)
            } else if (options2.ignoreUnknown) {
              return write4("[" + objType + "]")
            } else {
              throw new Error('Unknown object type "' + objType + '"')
            }
          } else {
            var keys2 = Object.keys(object)
            if (options2.unorderedObjects) {
              keys2 = keys2.sort()
            }
            if (options2.respectType !== false && !isNativeFunction(object)) {
              keys2.splice(0, 0, "prototype", "__proto__", "constructor")
            }
            if (options2.excludeKeys) {
              keys2 = keys2.filter(function (key) {
                return !options2.excludeKeys(key)
              })
            }
            write4("object:" + keys2.length + ":")
            var self = this
            return keys2.forEach(function (key) {
              self.dispatch(key)
              write4(":")
              if (!options2.excludeValues) {
                self.dispatch(object[key])
              }
              write4(",")
            })
          }
        },
        _array: function (arr, unordered) {
          unordered = typeof unordered !== "undefined" ? unordered : options2.unorderedArrays !== false
          var self = this
          write4("array:" + arr.length + ":")
          if (!unordered || arr.length <= 1) {
            return arr.forEach(function (entry) {
              return self.dispatch(entry)
            })
          }
          var contextAdditions = []
          var entries = arr.map(function (entry) {
            var strm = new PassThrough2()
            var localContext = context.slice()
            var hasher = typeHasher(options2, strm, localContext)
            hasher.dispatch(entry)
            contextAdditions = contextAdditions.concat(localContext.slice(context.length))
            return strm.read().toString()
          })
          context = context.concat(contextAdditions)
          entries.sort()
          return this._array(entries, false)
        },
        _date: function (date) {
          return write4("date:" + date.toJSON())
        },
        _symbol: function (sym) {
          return write4("symbol:" + sym.toString())
        },
        _error: function (err2) {
          return write4("error:" + err2.toString())
        },
        _boolean: function (bool) {
          return write4("bool:" + bool.toString())
        },
        _string: function (string) {
          write4("string:" + string.length + ":")
          write4(string.toString())
        },
        _function: function (fn) {
          write4("fn:")
          if (isNativeFunction(fn)) {
            this.dispatch("[native]")
          } else {
            this.dispatch(fn.toString())
          }
          if (options2.respectFunctionNames !== false) {
            this.dispatch("function-name:" + String(fn.name))
          }
          if (options2.respectFunctionProperties) {
            this._object(fn)
          }
        },
        _number: function (number) {
          return write4("number:" + number.toString())
        },
        _xml: function (xml) {
          return write4("xml:" + xml.toString())
        },
        _null: function () {
          return write4("Null")
        },
        _undefined: function () {
          return write4("Undefined")
        },
        _regexp: function (regex2) {
          return write4("regex:" + regex2.toString())
        },
        _uint8array: function (arr) {
          write4("uint8array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _uint8clampedarray: function (arr) {
          write4("uint8clampedarray:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _int8array: function (arr) {
          write4("int8array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _uint16array: function (arr) {
          write4("uint16array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _int16array: function (arr) {
          write4("int16array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _uint32array: function (arr) {
          write4("uint32array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _int32array: function (arr) {
          write4("int32array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _float32array: function (arr) {
          write4("float32array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _float64array: function (arr) {
          write4("float64array:")
          return this.dispatch(Array.prototype.slice.call(arr))
        },
        _arraybuffer: function (arr) {
          write4("arraybuffer:")
          return this.dispatch(new Uint8Array(arr))
        },
        _url: function (url) {
          return write4("url:" + url.toString(), "utf8")
        },
        _map: function (map3) {
          write4("map:")
          var arr = Array.from(map3)
          return this._array(arr, options2.unorderedSets !== false)
        },
        _set: function (set) {
          write4("set:")
          var arr = Array.from(set)
          return this._array(arr, options2.unorderedSets !== false)
        },
        _file: function (file) {
          write4("file:")
          return this.dispatch([file.name, file.size, file.type, file.lastModfied])
        },
        _blob: function () {
          if (options2.ignoreUnknown) {
            return write4("[blob]")
          }
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')
        },
        _domwindow: function () {
          return write4("domwindow")
        },
        _bigint: function (number) {
          return write4("bigint:" + number.toString())
        },
        /* Node.js standard native objects */
        _process: function () {
          return write4("process")
        },
        _timer: function () {
          return write4("timer")
        },
        _pipe: function () {
          return write4("pipe")
        },
        _tcp: function () {
          return write4("tcp")
        },
        _udp: function () {
          return write4("udp")
        },
        _tty: function () {
          return write4("tty")
        },
        _statwatcher: function () {
          return write4("statwatcher")
        },
        _securecontext: function () {
          return write4("securecontext")
        },
        _connection: function () {
          return write4("connection")
        },
        _zlib: function () {
          return write4("zlib")
        },
        _context: function () {
          return write4("context")
        },
        _nodescript: function () {
          return write4("nodescript")
        },
        _httpparser: function () {
          return write4("httpparser")
        },
        _dataview: function () {
          return write4("dataview")
        },
        _signal: function () {
          return write4("signal")
        },
        _fsevent: function () {
          return write4("fsevent")
        },
        _tlswrap: function () {
          return write4("tlswrap")
        }
      }
    }
    function PassThrough2() {
      return {
        buf: "",
        write: function (b) {
          this.buf += b
        },
        end: function (b) {
          this.buf += b
        },
        read: function () {
          return this.buf
        }
      }
    }
  }
})

// node_modules/langchain/dist/cache/base.js
var import_object_hash
var init_base6 = __esm({
  "node_modules/langchain/dist/cache/base.js"() {
    init_process()
    init_buffer()
    import_object_hash = __toESM(require_object_hash(), 1)
  }
})

// node_modules/langchain/dist/cache/index.js
var init_cache = __esm({
  "node_modules/langchain/dist/cache/index.js"() {
    init_process()
    init_buffer()
    init_base6()
    init_schema()
  }
})

// node_modules/langchain/dist/llms/base.js
var init_base7 = __esm({
  "node_modules/langchain/dist/llms/base.js"() {
    init_process()
    init_buffer()
    init_cache()
    init_schema()
    init_base_language()
    init_manager()
  }
})

// node_modules/langchain/dist/llms/openai-chat.js
var import_openai3
var init_openai_chat = __esm({
  "node_modules/langchain/dist/llms/openai-chat.js"() {
    init_process()
    init_buffer()
    import_openai3 = __toESM(require_dist2(), 1)
    init_axios_fetch_adapter()
    init_base7()
  }
})

// node_modules/langchain/dist/llms/openai.js
var import_openai4
var init_openai2 = __esm({
  "node_modules/langchain/dist/llms/openai.js"() {
    init_process()
    init_buffer()
    import_openai4 = __toESM(require_dist2(), 1)
    init_axios_fetch_adapter()
    init_chunk()
    init_base7()
    init_count_tokens()
    init_openai_chat()
    init_openai_chat()
  }
})

// node_modules/search-query-parser/lib/search-query-parser.js
var require_search_query_parser = __commonJS({
  "node_modules/search-query-parser/lib/search-query-parser.js"(exports) {
    init_process()
    init_buffer()
    exports.parse = function (string, options2) {
      if (!options2) {
        options2 = { offsets: true }
      } else {
        options2.offsets = typeof options2.offsets === "undefined" ? true : options2.offsets
      }
      if (!string) {
        string = ""
      }
      if (-1 === string.indexOf(":") && !options2.tokenize) {
        return string
      } else if (!options2.keywords && !options2.ranges && !options2.tokenize) {
        return string
      } else {
        var query = { text: [] }
        if (options2.offsets) {
          query.offsets = []
        }
        var exclusion = {}
        var terms = []
        var regex2 = /(\S+:'(?:[^'\\]|\\.)*')|(\S+:"(?:[^"\\]|\\.)*")|(-?"(?:[^"\\]|\\.)*")|(-?'(?:[^'\\]|\\.)*')|\S+|\S+:\S+/g
        var match
        while ((match = regex2.exec(string)) !== null) {
          var term = match[0]
          var sepIndex = term.indexOf(":")
          if (sepIndex !== -1) {
            var split = term.split(":"), key = term.slice(0, sepIndex), val = term.slice(sepIndex + 1)
            val = val.replace(/^\"|\"$|^\'|\'$/g, "")
            val = (val + "").replace(/\\(.?)/g, function (s, n1) {
              switch (n1) {
                case "\\":
                  return "\\"
                case "0":
                  return "\0"
                case "":
                  return ""
                default:
                  return n1
              }
            })
            terms.push({
              keyword: key,
              value: val,
              offsetStart: match.index,
              offsetEnd: match.index + term.length
            })
          } else {
            var isExcludedTerm = false
            if (term[0] === "-") {
              isExcludedTerm = true
              term = term.slice(1)
            }
            term = term.replace(/^\"|\"$|^\'|\'$/g, "")
            term = (term + "").replace(/\\(.?)/g, function (s, n1) {
              switch (n1) {
                case "\\":
                  return "\\"
                case "0":
                  return "\0"
                case "":
                  return ""
                default:
                  return n1
              }
            })
            if (isExcludedTerm) {
              if (exclusion["text"]) {
                if (exclusion["text"] instanceof Array) {
                  exclusion["text"].push(term)
                } else {
                  exclusion["text"] = [exclusion["text"]]
                  exclusion["text"].push(term)
                }
              } else {
                exclusion["text"] = term
              }
            } else {
              terms.push({
                text: term,
                offsetStart: match.index,
                offsetEnd: match.index + term.length
              })
            }
          }
        }
        terms.reverse()
        var term
        while (term = terms.pop()) {
          if (term.text) {
            query.text.push(term.text)
            if (options2.offsets) {
              query.offsets.push(term)
            }
          } else {
            var key = term.keyword
            options2.keywords = options2.keywords || []
            var isKeyword = false
            var isExclusion = false
            if (!/^-/.test(key)) {
              isKeyword = !(-1 === options2.keywords.indexOf(key))
            } else if (key[0] === "-") {
              var _key = key.slice(1)
              isKeyword = !(-1 === options2.keywords.indexOf(_key))
              if (isKeyword) {
                key = _key
                isExclusion = true
              }
            }
            options2.ranges = options2.ranges || []
            var isRange = !(-1 === options2.ranges.indexOf(key))
            if (isKeyword) {
              if (options2.offsets) {
                query.offsets.push({
                  keyword: key,
                  value: term.value,
                  offsetStart: isExclusion ? term.offsetStart + 1 : term.offsetStart,
                  offsetEnd: term.offsetEnd
                })
              }
              var value = term.value
              if (value.length) {
                var values = value.split(",")
                if (isExclusion) {
                  if (exclusion[key]) {
                    if (exclusion[key] instanceof Array) {
                      if (values.length > 1) {
                        exclusion[key] = exclusion[key].concat(values)
                      } else {
                        exclusion[key].push(value)
                      }
                    } else {
                      exclusion[key] = [exclusion[key]]
                      exclusion[key].push(value)
                    }
                  } else {
                    if (values.length > 1) {
                      exclusion[key] = values
                    } else {
                      if (options2.alwaysArray) {
                        exclusion[key] = [value]
                      } else {
                        exclusion[key] = value
                      }
                    }
                  }
                } else {
                  if (query[key]) {
                    if (query[key] instanceof Array) {
                      if (values.length > 1) {
                        query[key] = query[key].concat(values)
                      } else {
                        query[key].push(value)
                      }
                    } else {
                      query[key] = [query[key]]
                      query[key].push(value)
                    }
                  } else {
                    if (values.length > 1) {
                      query[key] = values
                    } else {
                      if (options2.alwaysArray) {
                        query[key] = [value]
                      } else {
                        query[key] = value
                      }
                    }
                  }
                }
              }
            } else if (isRange) {
              if (options2.offsets) {
                query.offsets.push(term)
              }
              var value = term.value
              var rangeValues = value.split("-")
              query[key] = {}
              if (2 === rangeValues.length) {
                query[key].from = rangeValues[0]
                query[key].to = rangeValues[1]
              } else if (!rangeValues.length % 2) {
              } else {
                query[key].from = value
              }
            } else {
              var text = term.keyword + ":" + term.value
              query.text.push(text)
              if (options2.offsets) {
                query.offsets.push({
                  text,
                  offsetStart: term.offsetStart,
                  offsetEnd: term.offsetEnd
                })
              }
            }
          }
        }
        if (query.text.length) {
          if (!options2.tokenize) {
            query.text = query.text.join(" ").trim()
          }
        } else {
          delete query.text
        }
        query.exclude = exclusion
        return query
      }
    }
    exports.stringify = function (queryObject, options2, prefix) {
      if (!options2) {
        options2 = { offsets: true }
      }
      if (!queryObject) {
        return ""
      }
      if (typeof queryObject === "string") {
        return queryObject
      }
      if (Array.isArray(queryObject)) {
        return queryObject.join(" ")
      }
      if (!Object.keys(queryObject).length) {
        return ""
      }
      if (Object.keys(queryObject).length === 3 && !!queryObject.text && !!queryObject.offsets && !!queryObject.exclude && typeof queryObject.text === "string") {
        return queryObject.text
      }
      if (!prefix) {
        prefix = ""
      }
      var addQuotes = function (string) {
        return string.indexOf(" ") > -1 ? JSON.stringify(string) : string
      }
      var addPrefix = function (string) {
        return prefix + string
      }
      var parts = []
      if (queryObject.text) {
        var value = []
        if (typeof queryObject.text === "string") {
          value.push(queryObject.text)
        } else {
          value.push.apply(value, queryObject.text)
        }
        if (value.length > 0) {
          parts.push(value.map(addQuotes).map(addPrefix).join(" "))
        }
      }
      if (options2.keywords) {
        options2.keywords.forEach(function (keyword) {
          if (!queryObject[keyword]) {
            return
          }
          var value2 = []
          if (typeof queryObject[keyword] === "string") {
            value2.push(queryObject[keyword])
          } else {
            value2.push.apply(value2, queryObject[keyword])
          }
          if (value2.length > 0) {
            parts.push(addPrefix(keyword + ":" + value2.map(addQuotes).join(",")))
          }
        })
      }
      if (options2.ranges) {
        options2.ranges.forEach(function (range) {
          if (!queryObject[range]) {
            return
          }
          var value2 = queryObject[range].from
          var to = queryObject[range].to
          if (to) {
            value2 = value2 + "-" + to
          }
          if (value2) {
            parts.push(addPrefix(range + ":" + value2))
          }
        })
      }
      if (queryObject.exclude) {
        if (Object.keys(queryObject.exclude).length > 0) {
          parts.push(exports.stringify(queryObject.exclude, options2, "-"))
        }
      }
      return parts.join(" ")
    }
  }
})

// node_modules/search-query-parser/index.js
var require_search_query_parser2 = __commonJS({
  "node_modules/search-query-parser/index.js"(exports, module2) {
    init_process()
    init_buffer()
    module2.exports = require_search_query_parser()
  }
})

// node_modules/zotero-plugin-toolkit/dist/managers/preferencePane.js
var require_preferencePane = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/managers/preferencePane.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.PreferencePaneManager = void 0
    var ui_1 = require_ui()
    var basic_1 = require_basic()
    var PreferencePaneManager2 = class extends basic_1.ManagerTool {
      constructor(base2) {
        super(base2)
        this.alive = true
        this.ui = new ui_1.UITool(this)
        this.prefPaneCache = { win: void 0, listeners: {} }
      }
      /**
       * Register a preference pane from an xhtml, for Zotero 6 & 7.
       * @remarks
       * Don't forget to call `unregisterPrefPane` on exit.
       * @remarks
       * options:
       * ```ts
       * export interface PrefPaneOptions {
       *   pluginID: string;
       *   src: string;
       *   id?: string;
       *   parent?: string;
       *   label?: string;
       *   image?: string;
       *   extraDTD?: string[];
       *   scripts?: string[];
       *   defaultXUL?: boolean;
       *   // Only for Zotero 6
       *   onload?: (win: Window) => any;
       * }
       * ```
       *
       * @param options See {@link https://github.com/windingwind/zotero-plugin-toolkit/blob/main/src/options.ts | source code:options.ts}
       * @example
       * ```ts
       * const prefsManager = new PreferencePaneManager();
       * function initPrefs() {
       *   const prefOptions = {
       *     pluginID: addonID,
       *     src: rootURI + "chrome/content/preferences.xhtml",
       *     label: "Template",
       *     image: `chrome://${addonRef}/content/icons/favicon.png`,
       *     extraDTD: [`chrome://${addonRef}/locale/overlay.dtd`],
       *     defaultXUL: true
       *   };
       *   prefsManager.register(prefOptions);
       * };
       *
       * function unInitPrefs() {
       *   prefsManager.unregisterAll();
       * };
       * ```
       * // bootstrap.js:startup
       * initPrefs();
       *
       * // bootstrap.js:shutdown
       * unInitPrefs();
       */
      register(options2) {
        if (this.isZotero7()) {
          this.getGlobal("Zotero").PreferencePanes.register(options2)
          return
        }
        const _initImportedNodesPostInsert = (container) => {
          var _a
          const _observerSymbols = /* @__PURE__ */ new Map()
          const Zotero2 = this.getGlobal("Zotero")
          const window2 = container.ownerGlobal
          let useChecked = (elem) => elem instanceof window2.HTMLInputElement && elem.type == "checkbox" || elem.tagName == "checkbox"
          let syncFromPref = (elem, preference) => {
            let value = Zotero2.Prefs.get(preference, true)
            if (useChecked(elem)) {
              elem.checked = value
            } else {
              elem.value = value
            }
            elem.dispatchEvent(new window2.Event("syncfrompreference"))
          }
          let syncToPrefOnModify = (event) => {
            const targetNode = event.currentTarget
            if (targetNode === null || targetNode === void 0 ? void 0 : targetNode.getAttribute("preference")) {
              let value = useChecked(targetNode) ? targetNode.checked : targetNode.value
              Zotero2.Prefs.set(targetNode.getAttribute("preference") || "", value, true)
              targetNode.dispatchEvent(new window2.Event("synctopreference"))
            }
          }
          let attachToPreference = (elem, preference) => {
            Zotero2.debug(`Attaching <${elem.tagName}> element to ${preference}`)
            let symbol = Zotero2.Prefs.registerObserver(preference, () => syncFromPref(elem, preference), true)
            _observerSymbols.set(elem, symbol)
          }
          let detachFromPreference = (elem) => {
            if (_observerSymbols.has(elem)) {
              Zotero2.debug(`Detaching <${elem.tagName}> element from preference`)
              Zotero2.Prefs.unregisterObserver(this._observerSymbols.get(elem))
              _observerSymbols.delete(elem)
            }
          }
          for (let elem of container.querySelectorAll("[preference]")) {
            let preference = elem.getAttribute("preference")
            if (container.querySelector("preferences > preference#" + preference)) {
              this.log("<preference> is deprecated -- `preference` attribute values should be full preference keys, not <preference> IDs")
              preference = (_a = container.querySelector("preferences > preference#" + preference)) === null || _a === void 0 ? void 0 : _a.getAttribute("name")
            }
            attachToPreference(elem, preference)
            elem.addEventListener(this.isXULElement(elem) ? "command" : "input", syncToPrefOnModify)
            window2.setTimeout(() => {
              syncFromPref(elem, preference)
            })
          }
          new window2.MutationObserver((mutations) => {
            for (let mutation of mutations) {
              if (mutation.type == "attributes") {
                let target = mutation.target
                detachFromPreference(target)
                if (target.hasAttribute("preference")) {
                  attachToPreference(target, target.getAttribute("preference") || "")
                  target.addEventListener(this.isXULElement(target) ? "command" : "input", syncToPrefOnModify)
                }
              } else if (mutation.type == "childList") {
                for (let node of mutation.removedNodes) {
                  detachFromPreference(node)
                }
                for (let node of mutation.addedNodes) {
                  if (node.nodeType == window2.Node.ELEMENT_NODE && node.hasAttribute("preference")) {
                    attachToPreference(node, node.getAttribute("preference") || "")
                    node.addEventListener(this.isXULElement(node) ? "command" : "input", syncToPrefOnModify)
                  }
                }
              }
            }
          }).observe(container, {
            childList: true,
            subtree: true,
            attributeFilter: ["preference"]
          })
          for (let elem of container.querySelectorAll("[oncommand]")) {
            elem.oncommand = elem.getAttribute("oncommand")
          }
          for (let child of container.children) {
            child.dispatchEvent(new window2.Event("load"))
          }
        }
        const windowListener = {
          onOpenWindow: (xulWindow) => {
            if (!this.alive) {
              return
            }
            const win = xulWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow)
            win.addEventListener("load", async () => {
              var _a
              if (win.location.href === "chrome://zotero/content/preferences/preferences.xul") {
                this.log("registerPrefPane:detected", options2)
                const Zotero2 = this.getGlobal("Zotero")
                options2.id || (options2.id = `plugin-${Zotero2.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`)
                const contentOrXHR = await Zotero2.File.getContentsAsync(options2.src)
                const content = typeof contentOrXHR === "string" ? contentOrXHR : contentOrXHR.response
                const src = `<prefpane xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" id="${options2.id}" insertafter="zotero-prefpane-advanced" label="${options2.label || options2.pluginID}" image="${options2.image || ""}">
                ${content}
                </prefpane>`
                const frag = this.ui.parseXHTMLToFragment(src, options2.extraDTD, options2.defaultXUL)
                this.log(frag)
                const prefWindow = win.document.querySelector("prefwindow")
                prefWindow.appendChild(frag)
                const prefPane = win.document.querySelector(`#${options2.id}`)
                prefWindow.addPane(prefPane)
                const contentBox = win.document.getAnonymousNodes(win.document.querySelector(`#${options2.id}`))[0]
                contentBox.style.overflowY = "scroll"
                contentBox.style.height = "440px"
                win.sizeToContent()
                if (contentBox.scrollHeight === contentBox.clientHeight) {
                  contentBox.style.overflowY = "hidden"
                }
                this.prefPaneCache.win = win
                this.prefPaneCache.listeners[options2.id] = windowListener
                _initImportedNodesPostInsert(prefPane)
                if ((_a = options2.scripts) === null || _a === void 0 ? void 0 : _a.length) {
                  options2.scripts.forEach((script) => Services.scriptloader.loadSubScript(script, win))
                }
                if (options2.onload) {
                  options2.onload(win)
                }
              }
            }, false)
          }
        }
        Services.wm.addListener(windowListener)
      }
      unregister(id) {
        var _a
        const idx = Object.keys(this.prefPaneCache.listeners).indexOf(id)
        if (idx < 0) {
          return false
        }
        const listener = this.prefPaneCache.listeners[id]
        Services.wm.removeListener(listener)
        listener.onOpenWindow = void 0
        const win = this.prefPaneCache.win
        if (win && !win.closed) {
          (_a = win.document.querySelector(`#${id}`)) === null || _a === void 0 ? void 0 : _a.remove()
        }
        delete this.prefPaneCache.listeners[id]
        return true
      }
      /**
       * Unregister all preference panes added with this instance
       *
       * Called on exiting
       */
      unregisterAll() {
        this.alive = false
        for (const id in this.prefPaneCache.listeners) {
          this.unregister(id)
        }
      }
    }
    exports.PreferencePaneManager = PreferencePaneManager2
  }
})

// node_modules/zotero-plugin-toolkit/dist/managers/prompt.js
var require_prompt = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/managers/prompt.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    var __importDefault = exports && exports.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : { "default": mod }
    }
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.PromptManager = exports.Prompt = void 0
    var basic_1 = require_basic()
    var basic_2 = require_basic()
    var ui_1 = require_ui()
    var toolkitGlobal_1 = __importDefault(require_toolkitGlobal())
    var Prompt = class {
      /**
       * Initialize `Prompt` but do not create UI.
       */
      constructor() {
        this.lastInputText = ""
        this.defaultText = {
          placeholder: "Select a command...",
          empty: "No commands found."
        }
        this.maxLineNum = 12
        this.maxSuggestionNum = 100
        this.commands = []
        this.base = new basic_1.BasicTool()
        this.ui = new ui_1.UITool()
        this.document = this.base.getGlobal("document")
        this.initializeUI()
      }
      /**
       * Initialize `Prompt` UI and then bind events on it.
       */
      initializeUI() {
        this.addStyle()
        this.createHTML()
        this.initInputEvents()
        this.registerShortcut()
      }
      createHTML() {
        this.promptNode = this.ui.createElement(this.document, "div", {
          styles: {
            display: "none"
          },
          children: [
            {
              tag: "div",
              styles: {
                position: "fixed",
                left: "0",
                top: "0",
                backgroundColor: "rgba(220, 220, 220, 0.4)",
                width: "100%",
                height: "100%",
                opacity: "0.5"
              },
              listeners: [
                {
                  type: "click",
                  listener: () => {
                    this.promptNode.style.display = "none"
                  }
                }
              ]
            }
          ]
        })
        this.promptNode.appendChild(this.ui.createElement(this.document, "div", {
          id: `zotero-plugin-toolkit-prompt`,
          classList: ["prompt-container"],
          children: [
            {
              tag: "div",
              classList: ["input-container"],
              children: [
                {
                  tag: "input",
                  classList: ["prompt-input"],
                  attributes: {
                    type: "text",
                    placeholder: this.defaultText.placeholder
                  }
                },
                {
                  tag: "div",
                  classList: ["cta"]
                }
              ]
            },
            {
              tag: "div",
              classList: ["commands-containers"]
            },
            {
              tag: "div",
              classList: ["instructions"],
              children: [
                {
                  tag: "div",
                  classList: ["instruction"],
                  children: [
                    {
                      tag: "span",
                      classList: ["key"],
                      properties: {
                        innerText: "\u2191\u2193"
                      }
                    },
                    {
                      tag: "span",
                      properties: {
                        innerText: "to navigate"
                      }
                    }
                  ]
                },
                {
                  tag: "div",
                  classList: ["instruction"],
                  children: [
                    {
                      tag: "span",
                      classList: ["key"],
                      properties: {
                        innerText: "enter"
                      }
                    },
                    {
                      tag: "span",
                      properties: {
                        innerText: "to trigger"
                      }
                    }
                  ]
                },
                {
                  tag: "div",
                  classList: ["instruction"],
                  children: [
                    {
                      tag: "span",
                      classList: ["key"],
                      properties: {
                        innerText: "esc"
                      }
                    },
                    {
                      tag: "span",
                      properties: {
                        innerText: "to exit"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }))
        this.inputNode = this.promptNode.querySelector("input")
        this.document.documentElement.appendChild(this.promptNode)
      }
      /**
       * Show commands in a new `commandsContainer`
       * All other `commandsContainer` is hidden
       * @param commands Command[]
       * @param clear remove all `commandsContainer` if true
       */
      showCommands(commands, clear = false) {
        if (clear) {
          this.promptNode.querySelectorAll(".commands-container").forEach((e) => e.remove())
        }
        this.inputNode.placeholder = this.defaultText.placeholder
        const commandsContainer = this.createCommandsContainer()
        for (let command of commands) {
          if (!command.name || command.when && !command.when()) {
            continue
          }
          commandsContainer.appendChild(this.createCommandNode(command))
        }
      }
      /**
       * Create a `commandsContainer` div element, append to `commandsContainer` and hide others.
       * @returns commandsNode
       */
      createCommandsContainer() {
        const commandsContainer = this.ui.createElement(this.document, "div", {
          classList: ["commands-container"]
        })
        this.promptNode.querySelectorAll(".commands-container").forEach((e) => {
          e.style.display = "none"
        })
        this.promptNode.querySelector(".commands-containers").appendChild(commandsContainer)
        return commandsContainer
      }
      /**
       * Return current displayed `commandsContainer`
       * @returns
       */
      getCommandsContainer() {
        return [...this.promptNode.querySelectorAll(".commands-container")].find((e) => {
          return e.style.display != "none"
        })
      }
      /**
       * Create a command item for `Prompt` UI.
       * @param command
       * @returns
       */
      createCommandNode(command) {
        const commandNode = this.ui.createElement(this.document, "div", {
          classList: ["command"],
          children: [
            {
              tag: "div",
              classList: ["content"],
              children: [
                {
                  tag: "div",
                  classList: ["name"],
                  children: [
                    {
                      tag: "span",
                      properties: {
                        innerText: command.name
                      }
                    }
                  ]
                },
                {
                  tag: "div",
                  classList: ["aux"],
                  children: command.label ? [
                    {
                      tag: "span",
                      classList: ["label"],
                      properties: {
                        innerText: command.label
                      }
                    }
                  ] : []
                }
              ]
            }
          ],
          listeners: [
            {
              type: "mousemove",
              listener: () => {
                this.selectItem(commandNode)
              }
            },
            {
              type: "click",
              listener: async () => {
                await this.execCallback(command.callback)
              }
            }
          ]
        })
        commandNode.command = command
        return commandNode
      }
      /**
       * Called when `enter` key is pressed.
       */
      trigger() {
        [...this.promptNode.querySelectorAll(".commands-container")].find((e) => e.style.display != "none").querySelector(".selected").click()
      }
      /**
       * Called when `escape` key is pressed.
       */
      exit() {
        this.inputNode.placeholder = this.defaultText.placeholder
        if (this.promptNode.querySelectorAll(".commands-containers .commands-container").length >= 2) {
          this.promptNode.querySelector(".commands-container:last-child").remove()
          const commandsContainer = this.promptNode.querySelector(".commands-container:last-child")
          commandsContainer.style.display = ""
          commandsContainer.querySelectorAll(".commands").forEach((e) => e.style.display = "flex")
          this.inputNode.focus()
        } else {
          this.promptNode.style.display = "none"
        }
      }
      async execCallback(callback) {
        if (Array.isArray(callback)) {
          this.showCommands(callback)
        } else {
          await callback(this)
        }
      }
      /**
       * Match suggestions for user's entered text.
       */
      async showSuggestions(inputText) {
        var _w = /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]/, jw = /\s/, Ww = /[\u0F00-\u0FFF\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/
        function Yw(e2, t, n, i) {
          if (0 === e2.length)
            return 0
          var r = 0
          r -= Math.max(0, e2.length - 1), r -= i / 10
          var o = e2[0][0]
          return r -= (e2[e2.length - 1][1] - o + 1 - t) / 100, r -= o / 1e3, r -= n / 1e4
        }
        function $w(e2, t, n, i) {
          if (0 === e2.length)
            return null
          for (var r = n.toLowerCase(), o = 0, a = 0, s = [], l = 0; l < e2.length; l++) {
            var c = e2[l], u = r.indexOf(c, a)
            if (-1 === u)
              return null
            var h = n.charAt(u)
            if (u > 0 && !_w.test(h) && !Ww.test(h)) {
              var p = n.charAt(u - 1)
              if (h.toLowerCase() !== h && p.toLowerCase() !== p || h.toUpperCase() !== h && !_w.test(p) && !jw.test(p) && !Ww.test(p))
                if (i) {
                  if (u !== a) {
                    a += c.length, l--
                    continue
                  }
                } else
                  o += 1
            }
            if (0 === s.length)
              s.push([u, u + c.length])
            else {
              var d = s[s.length - 1]
              d[1] < u ? s.push([u, u + c.length]) : d[1] = u + c.length
            }
            a = u + c.length
          }
          return {
            matches: s,
            score: Yw(s, t.length, r.length, o)
          }
        }
        function Gw(e2) {
          for (var t = e2.toLowerCase(), n = [], i = 0, r = 0; r < t.length; r++) {
            var o = t.charAt(r)
            jw.test(o) ? (i !== r && n.push(t.substring(i, r)), i = r + 1) : (_w.test(o) || Ww.test(o)) && (i !== r && n.push(t.substring(i, r)), n.push(o), i = r + 1)
          }
          return i !== t.length && n.push(t.substring(i, t.length)), {
            query: e2,
            tokens: n,
            fuzzy: t.split("")
          }
        }
        function Xw(e2, t) {
          if ("" === e2.query)
            return {
              score: 0,
              matches: []
            }
          var n = $w(e2.tokens, e2.query, t, false)
          return n || $w(e2.fuzzy, e2.query, t, true)
        }
        var e = Gw(inputText)
        let container = this.getCommandsContainer()
        if (container.classList.contains("suggestions")) {
          this.exit()
        }
        if (inputText.trim() == "") {
          return true
        }
        let suggestions = []
        this.getCommandsContainer().querySelectorAll(".command").forEach((commandNode) => {
          let spanNode = commandNode.querySelector(".name span")
          let spanText = spanNode.innerText
          let res = Xw(e, spanText)
          if (res) {
            commandNode = this.createCommandNode(commandNode.command)
            let spanHTML = ""
            let i = 0
            for (let j = 0; j < res.matches.length; j++) {
              let [start, end] = res.matches[j]
              if (start > i) {
                spanHTML += spanText.slice(i, start)
              }
              spanHTML += `<span class="highlight">${spanText.slice(start, end)}</span>`
              i = end
            }
            if (i < spanText.length) {
              spanHTML += spanText.slice(i, spanText.length)
            }
            commandNode.querySelector(".name span").innerHTML = spanHTML
            suggestions.push({ score: res.score, commandNode })
          }
        })
        if (suggestions.length > 0) {
          suggestions.sort((a, b) => b.score - a.score).slice(this.maxSuggestionNum)
          container = this.createCommandsContainer()
          container.classList.add("suggestions")
          suggestions.forEach((suggestion) => {
            container.appendChild(suggestion.commandNode)
          })
          return true
        } else {
          const anonymousCommand = this.commands.find((c) => !c.name && (!c.when || c.when()))
          if (anonymousCommand) {
            await this.execCallback(anonymousCommand.callback)
          } else {
            this.showTip(this.defaultText.empty)
          }
          return false
        }
      }
      /**
       * Bind events of pressing `keydown` and `keyup` key.
       */
      initInputEvents() {
        this.promptNode.addEventListener("keydown", (event) => {
          if (["ArrowUp", "ArrowDown"].indexOf(event.key) != -1) {
            event.preventDefault()
            let selectedIndex
            let allItems = [
              ...this.getCommandsContainer().querySelectorAll(".command")
            ].filter((e) => e.style.display != "none")
            selectedIndex = allItems.findIndex((e) => e.classList.contains("selected"))
            if (selectedIndex != -1) {
              allItems[selectedIndex].classList.remove("selected")
              selectedIndex += event.key == "ArrowUp" ? -1 : 1
            } else {
              if (event.key == "ArrowUp") {
                selectedIndex = allItems.length - 1
              } else {
                selectedIndex = 0
              }
            }
            if (selectedIndex == -1) {
              selectedIndex = allItems.length - 1
            } else if (selectedIndex == allItems.length) {
              selectedIndex = 0
            }
            allItems[selectedIndex].classList.add("selected")
            let commandsContainer = this.getCommandsContainer()
            commandsContainer.scrollTo(0, commandsContainer.querySelector(".selected").offsetTop - commandsContainer.offsetHeight + 7.5)
            allItems[selectedIndex].classList.add("selected")
          }
        })
        this.promptNode.addEventListener("keyup", async (event) => {
          if (event.key == "Enter") {
            this.trigger()
          } else if (event.key == "Escape") {
            if (this.inputNode.value.length > 0) {
              this.inputNode.value = ""
            } else {
              this.exit()
            }
          } else if (["ArrowUp", "ArrowDown"].indexOf(event.key) != -1) {
            return
          }
          const currentInputText = this.inputNode.value
          if (currentInputText == this.lastInputText) {
            return
          }
          this.lastInputText = currentInputText
          window.setTimeout(async () => {
            await this.showSuggestions(currentInputText)
          })
        })
      }
      /**
       * Create a commandsContainer and display a text
       */
      showTip(text) {
        const tipNode = this.ui.createElement(this.document, "div", {
          classList: ["tip"],
          properties: {
            innerText: text
          }
        })
        let container = this.createCommandsContainer()
        container.classList.add("suggestions")
        container.appendChild(tipNode)
        return tipNode
      }
      /**
       * Mark the selected item with class `selected`.
       * @param item HTMLDivElement
       */
      selectItem(item) {
        this.getCommandsContainer().querySelectorAll(".command").forEach((e) => e.classList.remove("selected"))
        item.classList.add("selected")
      }
      addStyle() {
        const style = this.ui.createElement(this.document, "style", {
          namespace: "html",
          id: "prompt-style"
        })
        style.innerText = `
      .prompt-container * {
        box-sizing: border-box;
      }
      .prompt-container {
        ---radius---: 10px;
        position: fixed;
        left: 25%;
        top: 10%;
        width: 50%;
        border-radius: var(---radius---);
        border: 1px solid #bdbdbd;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: white;
        font-size: 18px;
        box-shadow: 0px 1.8px 7.3px rgba(0, 0, 0, 0.071),
                    0px 6.3px 24.7px rgba(0, 0, 0, 0.112),
                    0px 30px 90px rgba(0, 0, 0, 0.2);
        font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
      }
      
      /* input */
      .prompt-container .input-container  {
        width: 100%;
      }
      
      .input-container input {
        width: 100%;
        height: 40px;
        padding: 24px;
        border-radius: 50%;
        border: none;
        outline: none;
        font-size: 18px;
      }
      
      .input-container .cta {
        border-bottom: 1px solid #f6f6f6;  
        margin: 5px auto;
      }
      
      /* results */
      .commands-containers {
        width: 100%;
        height: 100%;
      }
      .commands-container {
        max-height: calc(${this.maxLineNum} * 35.5px);
        width: calc(100% - 12px);
        margin-left: 12px;
        margin-right: 0%;
        overflow-y: auto;
        overflow-x: hidden;
      }
      
      .commands-container .command {
        display: flex;
        align-content: baseline;
        justify-content: space-between;
        border-radius: 5px;
        padding: 6px 12px;
        margin-right: 12px;
        margin-top: 2px;
        margin-bottom: 2px;
      }
      .commands-container .command .content {
        display: flex;
        width: 100%;
        justify-content: space-between;
        flex-direction: row;
        overflow: hidden;
      }
      .commands-container .command .content .name {
        white-space: nowrap; 
        text-overflow: ellipsis;
        overflow: hidden;
      }
      .commands-container .command .content .aux {
        display: flex;
        align-items: center;
        align-self: center;
        flex-shrink: 0;
      }
      
      .commands-container .command .content .aux .label {
        font-size: 15px;
        color: #5a5a5a;
        padding: 2px 6px;
        background-color: #fafafa;
        border-radius: 5px;
      }
      
      .commands-container .selected {
          background-color: rgba(0, 0, 0, 0.075);
      }

      .commands-container .highlight {
        font-weight: bold;
      }

      .tip {
        color: #5a5a5a;
        text-align: center;
        padding: 12px 12px;
        font-size: 18px;
      }
      
      .current-value {
        background-color: #a7b8c1;
        color: white;
        border-radius: 5px;
        padding: 0 5px;
        margin-left: 10px;
        font-size: 14px;
        vertical-align: middle;
        letter-spacing: 0.05em;
      }

      /* instructions */
      .instructions {
        display: flex;
        align-content: center;
        justify-content: center;
        font-size: 15px;
        color: rgba(0, 0, 0, 0.4);
        height: 2.5em;
        width: 100%;
        border-top: 1px solid #f6f6f6;
        margin-top: 5px;
      }
      
      .instructions .instruction {
        margin: auto .5em;  
      }
      
      .instructions .key {
        margin-right: .2em;
        font-weight: 600;
      }
    `
        this.document.documentElement.appendChild(style)
      }
      registerShortcut() {
        this.document.addEventListener("keydown", (event) => {
          if (event.shiftKey && event.key.toLowerCase() == "p") {
            if (event.originalTarget.isContentEditable || "value" in event.originalTarget || this.commands.length == 0) {
              return
            }
            event.preventDefault()
            event.stopPropagation()
            if (this.promptNode.style.display == "none") {
              this.promptNode.style.display = "flex"
              if (this.promptNode.querySelectorAll(".commands-container").length == 1) {
                this.showCommands(this.commands, true)
              }
              this.promptNode.focus()
              this.inputNode.focus()
            } else {
              this.promptNode.style.display = "none"
            }
          }
        }, true)
      }
    }
    exports.Prompt = Prompt
    var PromptManager2 = class extends basic_2.ManagerTool {
      constructor(base2) {
        super(base2)
        this.commands = []
        const globalCache = toolkitGlobal_1.default.getInstance().prompt
        if (!globalCache._ready) {
          globalCache._ready = true
          globalCache.instance = new Prompt()
        }
        this.prompt = globalCache.instance
      }
      /**
       * Register commands. Don't forget to call `unregister` on plugin exit.
       * @param commands Command[]
       * @example
       * ```ts
       * let getReader = () => {
       *   return BasicTool.getZotero().Reader.getByTabID(
       *     (Zotero.getMainWindow().Zotero_Tabs).selectedID
       *   )
       * }
       *
       * register([
       *   {
       *     name: "Split Horizontally",
       *     label: "Zotero",
       *     when: () => getReader() as boolean,
       *     callback: (prompt: Prompt) => getReader().menuCmd("splitHorizontally")
       *   },
       *   {
       *     name: "Split Vertically",
       *     label: "Zotero",
       *     when: () => getReader() as boolean,
       *     callback: (prompt: Prompt) => getReader().menuCmd("splitVertically")
       *   }
       * ])
       * ```
       */
      register(commands) {
        commands.forEach((c) => {
          var _a
          return (_a = c.id) !== null && _a !== void 0 ? _a : c.id = c.name
        })
        this.prompt.commands = [...this.prompt.commands, ...commands]
        this.commands = [...this.commands, ...commands]
        this.prompt.showCommands(this.commands, true)
      }
      /**
       * You can delete a command registed before by its name.
       * @remarks
       * There is a premise here that the names of all commands registered by a single plugin are not duplicated.
       * @param id Command.name
       */
      unregister(id) {
        const command = this.commands.find((c) => c.id == id)
        this.prompt.commands = this.prompt.commands.filter((c) => {
          return JSON.stringify(command) != JSON.stringify(c)
        })
        this.commands = this.commands.filter((c) => c.id != id)
      }
      /**
       * Call `unregisterAll` on plugin exit.
       */
      unregisterAll() {
        this.prompt.commands = this.prompt.commands.filter((c) => {
          return this.commands.find((_c) => {
            JSON.stringify(_c) != JSON.stringify(c)
          })
        })
        this.commands = []
      }
    }
    exports.PromptManager = PromptManager2
  }
})

// node_modules/zotero-plugin-toolkit/dist/helpers/clipboard.js
var require_clipboard = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/helpers/clipboard.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.ClipboardHelper = void 0
    var basic_1 = require_basic()
    var ClipboardHelper2 = class {
      constructor() {
        this.transferable = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable)
        this.clipboardService = Components.classes["@mozilla.org/widget/clipboard;1"].getService(Components.interfaces.nsIClipboard)
        this.transferable.init(null)
      }
      addText(source, type2) {
        const str = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString)
        str.data = source
        this.transferable.addDataFlavor(type2)
        this.transferable.setTransferData(type2, str, source.length * 2)
        return this
      }
      addImage(source) {
        let parts = source.split(",")
        if (!parts[0].includes("base64")) {
          return this
        }
        const basicTool2 = new basic_1.BasicTool()
        let mime = parts[0].match(/:(.*?);/)[1]
        let bstr = basicTool2.getGlobal("window").atob(parts[1])
        let n = bstr.length
        let u8arr = new Uint8Array(n)
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n)
        }
        let imgTools = Components.classes["@mozilla.org/image/tools;1"].getService(Components.interfaces.imgITools)
        let mimeType
        let img
        if (basicTool2.getGlobal("Zotero").platformMajorVersion >= 102) {
          img = imgTools.decodeImageFromArrayBuffer(u8arr.buffer, mime)
          mimeType = "application/x-moz-nativeimage"
        } else {
          mimeType = `image/png`
          img = Components.classes["@mozilla.org/supports-interface-pointer;1"].createInstance(Components.interfaces.nsISupportsInterfacePointer)
          img.data = imgTools.decodeImageFromArrayBuffer(u8arr.buffer, mimeType)
        }
        this.transferable.addDataFlavor(mimeType)
        this.transferable.setTransferData(mimeType, img, 0)
        return this
      }
      copy() {
        this.clipboardService.setData(this.transferable, null, Components.interfaces.nsIClipboard.kGlobalClipboard)
        return this
      }
    }
    exports.ClipboardHelper = ClipboardHelper2
  }
})

// node_modules/zotero-plugin-toolkit/dist/helpers/progressWindow.js
var require_progressWindow = __commonJS({
  "node_modules/zotero-plugin-toolkit/dist/helpers/progressWindow.js"(exports) {
    "use strict"
    init_process()
    init_buffer()
    Object.defineProperty(exports, "__esModule", { value: true })
    exports.ProgressWindowHelper = void 0
    var basic_1 = require_basic()
    var ProgressWindowHelper2 = class extends Zotero.ProgressWindow {
      /**
       *
       * @param header window header
       * @param options
       */
      constructor(header, options2 = {
        closeOnClick: true,
        closeTime: 5e3
      }) {
        super(options2)
        this.lines = []
        this.closeTime = options2.closeTime || 5e3
        this.changeHeadline(header)
        this.originalShow = this.show
        this.show = this.showWithTimer
        if (options2.closeOtherProgressWindows) {
          basic_1.BasicTool.getZotero().ProgressWindowSet.closeAll()
        }
      }
      /**
       * Create a new line
       * @param options
       */
      createLine(options2) {
        const icon = this.getIcon(options2.type, options2.icon)
        const line = new this.ItemProgress(icon || "", options2.text || "")
        if (typeof options2.progress === "number") {
          line.setProgress(options2.progress)
        }
        this.lines.push(line)
        return this
      }
      /**
       * Change the line content
       * @param options
       */
      changeLine(options2) {
        var _a
        if (((_a = this.lines) === null || _a === void 0 ? void 0 : _a.length) === 0) {
          return this
        }
        const idx = typeof options2.idx !== "undefined" && options2.idx >= 0 && options2.idx < this.lines.length ? options2.idx : 0
        const icon = this.getIcon(options2.type, options2.icon)
        options2.text && this.lines[idx].setText(options2.text)
        icon && this.lines[idx].setIcon(icon)
        typeof options2.progress === "number" && this.lines[idx].setProgress(options2.progress)
        return this
      }
      showWithTimer(closeTime = void 0) {
        this.originalShow()
        typeof closeTime !== "undefined" && (this.closeTime = closeTime)
        if (this.closeTime && this.closeTime > 0) {
          this.startCloseTimer(this.closeTime)
        }
        return this
      }
      /**
       * Set custom icon uri for progress window
       * @param key
       * @param uri
       */
      static setIconURI(key, uri) {
        icons[key] = uri
      }
      getIcon(type2, defaultIcon) {
        return type2 && type2 in icons ? icons[type2] : defaultIcon
      }
    }
    exports.ProgressWindowHelper = ProgressWindowHelper2
    var icons = {
      success: "chrome://zotero/skin/tick.png",
      fail: "chrome://zotero/skin/cross.png"
    }
  }
})

// src/tests.ts
init_process()
init_buffer()
var import_basic4 = __toESM(require_basic())

// src/addon.ts
init_process()
init_buffer()

// src/hooks.ts
init_process()
init_buffer()

// package.json
var version2 = "0.0.16"
var config2 = {
  addonName: "Aria",
  addonID: "aria@apex974.com",
  addonRef: "aria",
  addonInstance: "Aria",
  releasepage: "https://github.com/lifan0127/ai-research-assistant/releases/latest/download/aria.xpi",
  updaterdf: "https://raw.githubusercontent.com/lifan0127/ai-research-assistant/bootstrap/update.json"
}

// src/modules/locale.ts
init_process()
init_buffer()
function initLocale() {
  addon.data.locale = {
    stringBundle: Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService).createBundle(`chrome://${config2.addonRef}/locale/addon.properties`)
  }
}
function getString(localString, noReload = false) {
  var _a
  try {
    return (_a = addon.data.locale) == null ? void 0 : _a.stringBundle.GetStringFromName(localString)
  } catch (e) {
    if (!noReload) {
      initLocale()
      return getString(localString, true)
    }
    return localString
  }
}

// src/modules/views/chat.ts
init_process()
init_buffer()
var import_basic = __toESM(require_basic())
var import_basic2 = __toESM(require_basic())
var import_ui = __toESM(require_ui())
var import_shortcut = __toESM(require_shortcut())

// node_modules/marked/lib/marked.esm.js
init_process()
init_buffer()
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  }
}
var defaults = getDefaults()
function changeDefaults(newDefaults) {
  defaults = newDefaults
}
var escapeTest = /[&<>"']/
var escapeReplace = new RegExp(escapeTest.source, "g")
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g")
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}
var getEscapeReplacement = (ch) => escapeReplacements[ch]
function escape2(html, encode3) {
  if (encode3) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement)
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement)
    }
  }
  return html
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig
function unescape2(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase()
    if (n === "colon")
      return ":"
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1))
    }
    return ""
  })
}
var caret = /(^|[^\[])\^/g
function edit(regex2, opt) {
  regex2 = typeof regex2 === "string" ? regex2 : regex2.source
  opt = opt || ""
  const obj = {
    replace: (name, val) => {
      val = val.source || val
      val = val.replace(caret, "$1")
      regex2 = regex2.replace(name, val)
      return obj
    },
    getRegex: () => {
      return new RegExp(regex2, opt)
    }
  }
  return obj
}
var nonWordAndColonTest = /[^\w:]/g
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i
function cleanUrl(sanitize, base2, href) {
  if (sanitize) {
    let prot
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase()
    } catch (e) {
      return null
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null
    }
  }
  if (base2 && !originIndependentUrl.test(href)) {
    href = resolveUrl(base2, href)
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%")
  } catch (e) {
    return null
  }
  return href
}
var baseUrls = {}
var justDomain = /^[^:]+:\/*[^/]*$/
var protocol = /^([^:]+:)[\s\S]*$/
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/
function resolveUrl(base2, href) {
  if (!baseUrls[" " + base2]) {
    if (justDomain.test(base2)) {
      baseUrls[" " + base2] = base2 + "/"
    } else {
      baseUrls[" " + base2] = rtrim(base2, "/", true)
    }
  }
  base2 = baseUrls[" " + base2]
  const relativeBase = base2.indexOf(":") === -1
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href
    }
    return base2.replace(protocol, "$1") + href
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href
    }
    return base2.replace(domain, "$1") + href
  } else {
    return base2 + href
  }
}
var noopTest = {
  exec: function noopTest2() {
  }
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped
    if (escaped) {
      return "|"
    } else {
      return " |"
    }
  }), cells = row.split(/ \|/)
  let i = 0
  if (!cells[0].trim()) {
    cells.shift()
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop()
  }
  if (cells.length > count) {
    cells.splice(count)
  } else {
    while (cells.length < count)
      cells.push("")
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|")
  }
  return cells
}
function rtrim(str, c, invert) {
  const l = str.length
  if (l === 0) {
    return ""
  }
  let suffLen = 0
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1)
    if (currChar === c && !invert) {
      suffLen++
    } else if (currChar !== c && invert) {
      suffLen++
    } else {
      break
    }
  }
  return str.slice(0, l - suffLen)
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1
  }
  const l = str.length
  let level = 0, i = 0
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++
    } else if (str[i] === b[0]) {
      level++
    } else if (str[i] === b[1]) {
      level--
      if (level < 0) {
        return i
      }
    }
  }
  return -1
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return ""
  }
  let result = ""
  while (count > 1) {
    if (count & 1) {
      result += pattern
    }
    count >>= 1
    pattern += pattern
  }
  return result + pattern
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href
  const title3 = link.title ? escape2(link.title) : null
  const text = cap[1].replace(/\\([\[\]])/g, "$1")
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true
    const token = {
      type: "link",
      raw,
      href,
      title: title3,
      text,
      tokens: lexer2.inlineTokens(text)
    }
    lexer2.state.inLink = false
    return token
  }
  return {
    type: "image",
    raw,
    href,
    title: title3,
    text: escape2(text)
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/)
  if (matchIndentToCode === null) {
    return text
  }
  const indentToCode = matchIndentToCode[1]
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/)
    if (matchIndentInNode === null) {
      return node
    }
    const [indentInNode] = matchIndentInNode
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length)
    }
    return node
  }).join("\n")
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src)
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      }
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src)
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "")
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      }
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src)
    if (cap) {
      const raw = cap[0]
      const text = indentCodeCompensation(raw, cap[3] || "")
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      }
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src)
    if (cap) {
      let text = cap[2].trim()
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#")
        if (this.options.pedantic) {
          text = trimmed.trim()
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim()
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      }
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src)
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      }
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src)
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "")
      const top = this.lexer.state.top
      this.lexer.state.top = true
      const tokens = this.lexer.blockTokens(text)
      this.lexer.state.top = top
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      }
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src)
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly
      let bull = cap[1].trim()
      const isordered = bull.length > 1
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      }
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]"
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`)
      while (src) {
        endEarly = false
        if (!(cap = itemRegex.exec(src))) {
          break
        }
        if (this.rules.block.hr.test(src)) {
          break
        }
        raw = cap[0]
        src = src.substring(raw.length)
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length))
        nextLine = src.split("\n", 1)[0]
        if (this.options.pedantic) {
          indent = 2
          itemContents = line.trimLeft()
        } else {
          indent = cap[2].search(/[^ ]/)
          indent = indent > 4 ? 1 : indent
          itemContents = line.slice(indent)
          indent += cap[1].length
        }
        blankLine = false
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n"
          src = src.substring(nextLine.length + 1)
          endEarly = true
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`)
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`)
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`)
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`)
          while (src) {
            rawLine = src.split("\n", 1)[0]
            nextLine = rawLine
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")
            }
            if (fencesBeginRegex.test(nextLine)) {
              break
            }
            if (headingBeginRegex.test(nextLine)) {
              break
            }
            if (nextBulletRegex.test(nextLine)) {
              break
            }
            if (hrRegex.test(src)) {
              break
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent)
            } else {
              if (blankLine) {
                break
              }
              if (line.search(/[^ ]/) >= 4) {
                break
              }
              if (fencesBeginRegex.test(line)) {
                break
              }
              if (headingBeginRegex.test(line)) {
                break
              }
              if (hrRegex.test(line)) {
                break
              }
              itemContents += "\n" + nextLine
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true
            }
            raw += rawLine + "\n"
            src = src.substring(rawLine.length + 1)
            line = nextLine.slice(indent)
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents)
          if (istask) {
            ischecked = istask[0] !== "[ ] "
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "")
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        })
        list2.raw += raw
      }
      list2.items[list2.items.length - 1].raw = raw.trimRight()
      list2.items[list2.items.length - 1].text = itemContents.trimRight()
      list2.raw = list2.raw.trimRight()
      const l = list2.items.length
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, [])
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space")
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw))
          list2.loose = hasMultipleLineBreaks
        }
      }
      if (list2.loose) {
        for (i = 0; i < l; i++) {
          list2.items[i].loose = true
        }
      }
      return list2
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src)
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      }
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0])
        token.type = "paragraph"
        token.text = text
        token.tokens = this.lexer.inline(text)
      }
      return token
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src)
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ")
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : ""
      const title3 = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3]
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title: title3
      }
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src)
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c }
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      }
      if (item.header.length === item.align.length) {
        item.raw = cap[0]
        let l = item.align.length
        let i, j, k, row
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right"
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center"
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left"
          } else {
            item.align[i] = null
          }
        }
        l = item.rows.length
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c }
          })
        }
        l = item.header.length
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text)
        }
        l = item.rows.length
        for (j = 0; j < l; j++) {
          row = item.rows[j]
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text)
          }
        }
        return item
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src)
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      }
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src)
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      }
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src)
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      }
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src)
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape2(cap[1])
      }
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src)
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
      }
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src)
    if (cap) {
      const trimmedUrl = cap[2].trim()
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\")
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()")
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4
          const linkLen = start + cap[1].length + lastParenIndex
          cap[2] = cap[2].substring(0, lastParenIndex)
          cap[0] = cap[0].substring(0, linkLen).trim()
          cap[3] = ""
        }
      }
      let href = cap[2]
      let title3 = ""
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href)
        if (link) {
          href = link[1]
          title3 = link[3]
        }
      } else {
        title3 = cap[3] ? cap[3].slice(1, -1) : ""
      }
      href = href.trim()
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1)
        } else {
          href = href.slice(1, -1)
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title3 ? title3.replace(this.rules.inline._escapes, "$1") : title3
      }, cap[0], this.lexer)
    }
  }
  reflink(src, links) {
    let cap
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ")
      link = links[link.toLowerCase()]
      if (!link) {
        const text = cap[0].charAt(0)
        return {
          type: "text",
          raw: text,
          text
        }
      }
      return outputLink(cap, link, cap[0], this.lexer)
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src)
    if (!match)
      return
    if (match[3] && prevChar.match(/[\w\d]/))
      return
    const nextChar = match[1] || match[2] || ""
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd
      endReg.lastIndex = 0
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength)
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6]
        if (!rDelim)
          continue
        rLength = rDelim.length
        if (match[3] || match[4]) {
          delimTotal += rLength
          continue
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength
            continue
          }
        }
        delimTotal -= rLength
        if (delimTotal > 0)
          continue
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal)
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength)
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1)
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          }
        }
        const text = raw.slice(2, -2)
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        }
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src)
    if (cap) {
      let text = cap[2].replace(/\n/g, " ")
      const hasNonSpaceChars = /[^ ]/.test(text)
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text)
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1)
      }
      text = escape2(text, true)
      return {
        type: "codespan",
        raw: cap[0],
        text
      }
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src)
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      }
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src)
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      }
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src)
    if (cap) {
      let text, href
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[1]) : cap[1])
        href = "mailto:" + text
      } else {
        text = escape2(cap[1])
        href = text
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      }
    }
  }
  url(src, mangle2) {
    let cap
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[0]) : cap[0])
        href = "mailto:" + text
      } else {
        let prevCapZero
        do {
          prevCapZero = cap[0]
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0]
        } while (prevCapZero !== cap[0])
        text = escape2(cap[0])
        if (cap[1] === "www.") {
          href = "http://" + cap[0]
        } else {
          href = cap[0]
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      }
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src)
    if (cap) {
      let text
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
      } else {
        text = escape2(this.options.smartypants ? smartypants2(cap[0]) : cap[0])
      }
      return {
        type: "text",
        raw: cap[0],
        text
      }
    }
  }
}
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
}
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex()
block.bullet = /(?:[*+-]|\d{1,9}[.)])/
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex()
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex()
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex()
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex()
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex()
block.normal = { ...block }
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
}
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex()
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex()
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
}
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
}
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex()
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex()
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex()
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex()
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex()
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex()
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex()
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex()
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex()
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex()
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex()
inline.normal = { ...inline }
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
}
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex()
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026")
}
function mangle(text) {
  let out = "", i, ch
  const l = text.length
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i)
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16)
    }
    out += "&#" + ch + ";"
  }
  return out
}
var Lexer = class {
  constructor(options2) {
    this.tokens = []
    this.tokens.links = /* @__PURE__ */ Object.create(null)
    this.options = options2 || defaults
    this.options.tokenizer = this.options.tokenizer || new Tokenizer()
    this.tokenizer = this.options.tokenizer
    this.tokenizer.options = this.options
    this.tokenizer.lexer = this
    this.inlineQueue = []
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    }
    const rules = {
      block: block.normal,
      inline: inline.normal
    }
    if (this.options.pedantic) {
      rules.block = block.pedantic
      rules.inline = inline.pedantic
    } else if (this.options.gfm) {
      rules.block = block.gfm
      if (this.options.breaks) {
        rules.inline = inline.breaks
      } else {
        rules.inline = inline.gfm
      }
    }
    this.tokenizer.rules = rules
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    }
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new Lexer(options2)
    return lexer2.lex(src)
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2)
    return lexer2.inlineTokens(src)
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n")
    this.blockTokens(src, this.tokens)
    let next
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens)
    }
    return this.tokens
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "")
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length)
      })
    }
    let token, lastToken, cutSrc, lastParagraphClipped
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length)
          tokens.push(token)
          return true
        }
        return false
      })) {
        continue
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length)
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n"
        } else {
          tokens.push(token)
        }
        continue
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length)
        lastToken = tokens[tokens.length - 1]
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw
          lastToken.text += "\n" + token.text
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text
        } else {
          tokens.push(token)
        }
        continue
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length)
        lastToken = tokens[tokens.length - 1]
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw
          lastToken.text += "\n" + token.raw
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          }
        }
        continue
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      cutSrc = src
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity
        const tempSrc = src.slice(1)
        let tempStart
        this.options.extensions.startBlock.forEach(function (getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc)
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart)
          }
        })
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1)
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1]
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw
          lastToken.text += "\n" + token.text
          this.inlineQueue.pop()
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text
        } else {
          tokens.push(token)
        }
        lastParagraphClipped = cutSrc.length !== src.length
        src = src.substring(token.raw.length)
        continue
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length)
        lastToken = tokens[tokens.length - 1]
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw
          lastToken.text += "\n" + token.text
          this.inlineQueue.pop()
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text
        } else {
          tokens.push(token)
        }
        continue
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0)
        if (this.options.silent) {
          console.error(errMsg)
          break
        } else {
          throw new Error(errMsg)
        }
      }
    }
    this.state.top = true
    return tokens
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens })
    return tokens
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc
    let maskedSrc = src
    let match
    let keepPrevChar, prevChar
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links)
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex)
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = ""
      }
      keepPrevChar = false
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length)
          tokens.push(token)
          return true
        }
        return false
      })) {
        continue
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length)
        lastToken = tokens[tokens.length - 1]
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw
          lastToken.text += token.text
        } else {
          tokens.push(token)
        }
        continue
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length)
        lastToken = tokens[tokens.length - 1]
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw
          lastToken.text += token.text
        } else {
          tokens.push(token)
        }
        continue
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length)
        tokens.push(token)
        continue
      }
      cutSrc = src
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity
        const tempSrc = src.slice(1)
        let tempStart
        this.options.extensions.startInline.forEach(function (getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc)
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart)
          }
        })
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1)
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length)
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1)
        }
        keepPrevChar = true
        lastToken = tokens[tokens.length - 1]
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw
          lastToken.text += token.text
        } else {
          tokens.push(token)
        }
        continue
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0)
        if (this.options.silent) {
          console.error(errMsg)
          break
        } else {
          throw new Error(errMsg)
        }
      }
    }
    return tokens
  }
}
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0]
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang)
      if (out != null && out !== code) {
        escaped = true
        code = out
      }
    }
    code = code.replace(/\n$/, "") + "\n"
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape2(code, true)) + "</code></pre>\n"
    }
    return '<pre><code class="' + this.options.langPrefix + escape2(lang) + '">' + (escaped ? code : escape2(code, true)) + "</code></pre>\n"
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`
  }
  html(html) {
    return html
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw)
      return `<h${level} id="${id}">${text}</h${level}>
`
    }
    return `<h${level}>${text}</h${level}>
`
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
  }
  list(body, ordered, start) {
    const type2 = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : ""
    return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n"
  }
  /**
   * @param {string} text
   */
  listitem(text) {
    return `<li>${text}</li>
`
  }
  checkbox(checked3) {
    return "<input " + (checked3 ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> "
  }
  /**
   * @param {string} text
   */
  paragraph(text) {
    return `<p>${text}</p>
`
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n"
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`
  }
  tablecell(content, flags) {
    const type2 = flags.header ? "th" : "td"
    const tag = flags.align ? `<${type2} align="${flags.align}">` : `<${type2}>`
    return tag + content + `</${type2}>
`
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text) {
    return `<strong>${text}</strong>`
  }
  /**
   * @param {string} text
   */
  em(text) {
    return `<em>${text}</em>`
  }
  /**
   * @param {string} text
   */
  codespan(text) {
    return `<code>${text}</code>`
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>"
  }
  /**
   * @param {string} text
   */
  del(text) {
    return `<del>${text}</del>`
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title3, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href)
    if (href === null) {
      return text
    }
    let out = '<a href="' + href + '"'
    if (title3) {
      out += ' title="' + title3 + '"'
    }
    out += ">" + text + "</a>"
    return out
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title3, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href)
    if (href === null) {
      return text
    }
    let out = `<img src="${href}" alt="${text}"`
    if (title3) {
      out += ` title="${title3}"`
    }
    out += this.options.xhtml ? "/>" : ">"
    return out
  }
  text(text) {
    return text
  }
}
var TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text
  }
  em(text) {
    return text
  }
  codespan(text) {
    return text
  }
  del(text) {
    return text
  }
  html(text) {
    return text
  }
  text(text) {
    return text
  }
  link(href, title3, text) {
    return "" + text
  }
  image(href, title3, text) {
    return "" + text
  }
  br() {
    return ""
  }
}
var Slugger = class {
  constructor() {
    this.seen = {}
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-")
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug
    let occurenceAccumulator = 0
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug]
      do {
        occurenceAccumulator++
        slug = originalSlug + "-" + occurenceAccumulator
      } while (this.seen.hasOwnProperty(slug))
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator
      this.seen[slug] = 0
    }
    return slug
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value)
    return this.getNextSafeSlug(slug, options2.dryrun)
  }
}
var Parser = class {
  constructor(options2) {
    this.options = options2 || defaults
    this.options.renderer = this.options.renderer || new Renderer()
    this.renderer = this.options.renderer
    this.renderer.options = this.options
    this.textRenderer = new TextRenderer()
    this.slugger = new Slugger()
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new Parser(options2)
    return parser2.parse(tokens)
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new Parser(options2)
    return parser2.parseInline(tokens)
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked3, task, checkbox, ret
    const l = tokens.length
    for (i = 0; i < l; i++) {
      token = tokens[i]
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token)
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || ""
          continue
        }
      }
      switch (token.type) {
        case "space": {
          continue
        }
        case "hr": {
          out += this.renderer.hr()
          continue
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape2(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          )
          continue
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          )
          continue
        }
        case "table": {
          header = ""
          cell = ""
          l2 = token.header.length
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            )
          }
          header += this.renderer.tablerow(cell)
          body = ""
          l2 = token.rows.length
          for (j = 0; j < l2; j++) {
            row = token.rows[j]
            cell = ""
            l3 = row.length
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              )
            }
            body += this.renderer.tablerow(cell)
          }
          out += this.renderer.table(header, body)
          continue
        }
        case "blockquote": {
          body = this.parse(token.tokens)
          out += this.renderer.blockquote(body)
          continue
        }
        case "list": {
          ordered = token.ordered
          start = token.start
          loose = token.loose
          l2 = token.items.length
          body = ""
          for (j = 0; j < l2; j++) {
            item = token.items[j]
            checked3 = item.checked
            task = item.task
            itemBody = ""
            if (item.task) {
              checkbox = this.renderer.checkbox(checked3)
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  })
                }
              } else {
                itemBody += checkbox
              }
            }
            itemBody += this.parse(item.tokens, loose)
            body += this.renderer.listitem(itemBody, task, checked3)
          }
          out += this.renderer.list(body, ordered, start)
          continue
        }
        case "html": {
          out += this.renderer.html(token.text)
          continue
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens))
          continue
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i]
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text)
          }
          out += top ? this.renderer.paragraph(body) : body
          continue
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.'
          if (this.options.silent) {
            console.error(errMsg)
            return
          } else {
            throw new Error(errMsg)
          }
        }
      }
    }
    return out
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer
    let out = "", i, token, ret
    const l = tokens.length
    for (i = 0; i < l; i++) {
      token = tokens[i]
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token)
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || ""
          continue
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text)
          break
        }
        case "html": {
          out += renderer.html(token.text)
          break
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer))
          break
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text)
          break
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer))
          break
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer))
          break
        }
        case "codespan": {
          out += renderer.codespan(token.text)
          break
        }
        case "br": {
          out += renderer.br()
          break
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer))
          break
        }
        case "text": {
          out += renderer.text(token.text)
          break
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.'
          if (this.options.silent) {
            console.error(errMsg)
            return
          } else {
            throw new Error(errMsg)
          }
        }
      }
    }
    return out
  }
}
var Hooks = class {
  constructor(options2) {
    this.options = options2 || defaults
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]))
function onError(silent, async, callback) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked."
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>"
      if (async) {
        return Promise.resolve(msg)
      }
      if (callback) {
        callback(null, msg)
        return
      }
      return msg
    }
    if (async) {
      return Promise.reject(e)
    }
    if (callback) {
      callback(e)
      return
    }
    throw e
  }
}
function parseMarkdown(lexer2, parser2) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt
      opt = null
    }
    const origOpt = { ...opt }
    opt = { ...marked.defaults, ...origOpt }
    const throwError = onError(opt.silent, opt.async, callback)
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"))
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"))
    }
    checkSanitizeDeprecation(opt)
    if (opt.hooks) {
      opt.hooks.options = opt
    }
    if (callback) {
      const highlight = opt.highlight
      let tokens
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src)
        }
        tokens = lexer2(src, opt)
      } catch (e) {
        return throwError(e)
      }
      const done2 = function (err2) {
        let out
        if (!err2) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens)
            }
            out = parser2(tokens, opt)
            if (opt.hooks) {
              out = opt.hooks.postprocess(out)
            }
          } catch (e) {
            err2 = e
          }
        }
        opt.highlight = highlight
        return err2 ? throwError(err2) : callback(null, out)
      }
      if (!highlight || highlight.length < 3) {
        return done2()
      }
      delete opt.highlight
      if (!tokens.length)
        return done2()
      let pending = 0
      marked.walkTokens(tokens, function (token) {
        if (token.type === "code") {
          pending++
          setTimeout(() => {
            highlight(token.text, token.lang, function (err2, code) {
              if (err2) {
                return done2(err2)
              }
              if (code != null && code !== token.text) {
                token.text = code
                token.escaped = true
              }
              pending--
              if (pending === 0) {
                done2()
              }
            })
          }, 0)
        }
      })
      if (pending === 0) {
        done2()
      }
      return
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError)
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src)
      }
      const tokens = lexer2(src, opt)
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens)
      }
      let html = parser2(tokens, opt)
      if (opt.hooks) {
        html = opt.hooks.postprocess(html)
      }
      return html
    } catch (e) {
      return throwError(e)
    }
  }
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback)
}
marked.options = marked.setOptions = function (opt) {
  marked.defaults = { ...marked.defaults, ...opt }
  changeDefaults(marked.defaults)
  return marked
}
marked.getDefaults = getDefaults
marked.defaults = defaults
marked.use = function (...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} }
  args.forEach((pack) => {
    const opts = { ...pack }
    opts.async = marked.defaults.async || opts.async || false
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required")
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name]
          if (prevRenderer) {
            extensions.renderers[ext.name] = function (...args2) {
              let ret = ext.renderer.apply(this, args2)
              if (ret === false) {
                ret = prevRenderer.apply(this, args2)
              }
              return ret
            }
          } else {
            extensions.renderers[ext.name] = ext.renderer
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'")
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer)
          } else {
            extensions[ext.level] = [ext.tokenizer]
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start)
              } else {
                extensions.startBlock = [ext.start]
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start)
              } else {
                extensions.startInline = [ext.start]
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens
        }
      })
      opts.extensions = extensions
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer()
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop]
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2)
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2)
          }
          return ret
        }
      }
      opts.renderer = renderer
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer()
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop]
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2)
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2)
          }
          return ret
        }
      }
      opts.tokenizer = tokenizer
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks()
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop]
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2)
              })
            }
            const ret = pack.hooks[prop].call(hooks, arg)
            return prevHook.call(hooks, ret)
          }
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2)
            if (ret === false) {
              ret = prevHook.apply(hooks, args2)
            }
            return ret
          }
        }
      }
      opts.hooks = hooks
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens
      opts.walkTokens = function (token) {
        let values = []
        values.push(pack.walkTokens.call(this, token))
        if (walkTokens2) {
          values = values.concat(walkTokens2.call(this, token))
        }
        return values
      }
    }
    marked.setOptions(opts)
  })
}
marked.walkTokens = function (tokens, callback) {
  let values = []
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token))
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback))
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback))
          }
        }
        break
      }
      case "list": {
        values = values.concat(marked.walkTokens(token.items, callback))
        break
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
            values = values.concat(marked.walkTokens(token[childTokens], callback))
          })
        } else if (token.tokens) {
          values = values.concat(marked.walkTokens(token.tokens, callback))
        }
      }
    }
  }
  return values
}
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline)
marked.Parser = Parser
marked.parser = Parser.parse
marked.Renderer = Renderer
marked.TextRenderer = TextRenderer
marked.Lexer = Lexer
marked.lexer = Lexer.lex
marked.Tokenizer = Tokenizer
marked.Slugger = Slugger
marked.Hooks = Hooks
marked.parse = marked
var options = marked.options
var setOptions = marked.setOptions
var use = marked.use
var walkTokens = marked.walkTokens
var parseInline = marked.parseInline
var parser = Parser.parse
var lexer = Lexer.lex

// node_modules/serialize-error/index.js
init_process()
init_buffer()

// node_modules/serialize-error/error-constructors.js
init_process()
init_buffer()
var list = [
  // Native ES errors https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  // Built-in errors
  _globalThis.DOMException,
  // Node-specific errors
  // https://nodejs.org/api/errors.html
  _globalThis.AssertionError,
  _globalThis.SystemError
].filter(Boolean).map(
  (constructor) => [constructor.name, constructor]
)
var errorConstructors = new Map(list)
var error_constructors_default = errorConstructors

// node_modules/serialize-error/index.js
var commonProperties = [
  {
    property: "name",
    enumerable: false
  },
  {
    property: "message",
    enumerable: false
  },
  {
    property: "stack",
    enumerable: false
  },
  {
    property: "code",
    enumerable: true
  },
  {
    property: "cause",
    enumerable: false
  }
]
var toJsonWasCalled = Symbol(".toJSON was called")
var toJSON2 = (from3) => {
  from3[toJsonWasCalled] = true
  const json = from3.toJSON()
  delete from3[toJsonWasCalled]
  return json
}
var getErrorConstructor = (name) => {
  var _a
  return (_a = error_constructors_default.get(name)) != null ? _a : Error
}
var destroyCircular = ({
  from: from3,
  seen,
  to,
  forceEnumerable,
  maxDepth,
  depth,
  useToJSON,
  serialize
}) => {
  if (!to) {
    if (Array.isArray(from3)) {
      to = []
    } else if (!serialize && isErrorLike(from3)) {
      const Error2 = getErrorConstructor(from3.name)
      to = new Error2()
    } else {
      to = {}
    }
  }
  seen.push(from3)
  if (depth >= maxDepth) {
    return to
  }
  if (useToJSON && typeof from3.toJSON === "function" && from3[toJsonWasCalled] !== true) {
    return toJSON2(from3)
  }
  const continueDestroyCircular = (value) => destroyCircular({
    from: value,
    seen: [...seen],
    forceEnumerable,
    maxDepth,
    depth,
    useToJSON,
    serialize
  })
  for (const [key, value] of Object.entries(from3)) {
    if (typeof Buffer2 === "function" && Buffer2.isBuffer(value)) {
      to[key] = "[object Buffer]"
      continue
    }
    if (value !== null && typeof value === "object" && typeof value.pipe === "function") {
      to[key] = "[object Stream]"
      continue
    }
    if (typeof value === "function") {
      continue
    }
    if (!value || typeof value !== "object") {
      to[key] = value
      continue
    }
    if (!seen.includes(from3[key])) {
      depth++
      to[key] = continueDestroyCircular(from3[key])
      continue
    }
    to[key] = "[Circular]"
  }
  for (const { property, enumerable } of commonProperties) {
    if (typeof from3[property] !== "undefined" && from3[property] !== null) {
      Object.defineProperty(to, property, {
        value: isErrorLike(from3[property]) ? continueDestroyCircular(from3[property]) : from3[property],
        enumerable: forceEnumerable ? true : enumerable,
        configurable: true,
        writable: true
      })
    }
  }
  return to
}
function serializeError(value, options2 = {}) {
  var _a
  const {
    maxDepth = Number.POSITIVE_INFINITY,
    useToJSON = true
  } = options2
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: [],
      forceEnumerable: true,
      maxDepth,
      depth: 0,
      useToJSON,
      serialize: true
    })
  }
  if (typeof value === "function") {
    return `[Function: ${(_a = value.name) != null ? _a : "anonymous"}]`
  }
  return value
}
function isErrorLike(value) {
  return Boolean(value) && typeof value === "object" && "name" in value && "message" in value && "stack" in value
}

// src/libs/agents/index.ts
init_process()
init_buffer()

// src/libs/agents/base.ts
init_process()
init_buffer()

// src/libs/agents/qa.ts
init_process()
init_buffer()

// node_modules/langchain/chat_models.js
init_process()
init_buffer()

// node_modules/langchain/dist/chat_models/index.js
init_process()
init_buffer()
init_base3()
init_openai()

// node_modules/langchain/dist/chat_models/anthropic.js
init_process()
init_buffer()
var import_sdk = __toESM(require_src2(), 1)
init_base3()
init_schema()

// node_modules/langchain/agents.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/index.js
init_process()
init_buffer()
init_agent()

// node_modules/langchain/dist/agents/agent_toolkits/index.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/json/json.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/json.js
init_process()
init_buffer()
var import_jsonpointer = __toESM(require_jsonpointer(), 1)

// node_modules/langchain/dist/tools/base.js
init_process()
init_buffer()

// node_modules/zod/lib/index.mjs
init_process()
init_buffer()
var util;
(function (util2) {
  util2.assertEqual = (val) => val
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs
  function assertNever(_x) {
    throw new Error()
  }
  util2.assertNever = assertNever
  util2.arrayToEnum = (items) => {
    const obj = {}
    for (const item of items) {
      obj[item] = item
    }
    return obj
  }
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number")
    const filtered = {}
    for (const k of validKeys) {
      filtered[k] = obj[k]
    }
    return util2.objectValues(filtered)
  }
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function (e) {
      return obj[e]
    })
  }
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = []
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key)
      }
    }
    return keys2
  }
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item
    }
    return void 0
  }
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator)
  }
  util2.joinValues = joinValues
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString()
    }
    return value
  }
})(util || (util = {}))
var objectUtil;
(function (objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    }
  }
})(objectUtil || (objectUtil = {}))
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
])
var getParsedType = (data) => {
  const t = typeof data
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined
    case "string":
      return ZodParsedType.string
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number
    case "boolean":
      return ZodParsedType.boolean
    case "function":
      return ZodParsedType.function
    case "bigint":
      return ZodParsedType.bigint
    case "symbol":
      return ZodParsedType.symbol
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array
      }
      if (data === null) {
        return ZodParsedType.null
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date
      }
      return ZodParsedType.object
    default:
      return ZodParsedType.unknown
  }
}
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
])
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2)
  return json.replace(/"([^"]+)":/g, "$1:")
}
var ZodError = class extends Error {
  constructor(issues) {
    super()
    this.issues = []
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub]
    }
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs]
    }
    const actualProto = new.target.prototype
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto)
    } else {
      this.__proto__ = actualProto
    }
    this.name = "ZodError"
    this.issues = issues
  }
  get errors() {
    return this.issues
  }
  format(_mapper) {
    const mapper = _mapper || function (issue) {
      return issue.message
    }
    const fieldErrors = { _errors: [] }
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError)
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError)
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError)
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue))
        } else {
          let curr = fieldErrors
          let i = 0
          while (i < issue.path.length) {
            const el = issue.path[i]
            const terminal = i === issue.path.length - 1
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] }
            } else {
              curr[el] = curr[el] || { _errors: [] }
              curr[el]._errors.push(mapper(issue))
            }
            curr = curr[el]
            i++
          }
        }
      }
    }
    processError(this)
    return fieldErrors
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {}
    const formErrors = []
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || []
        fieldErrors[sub.path[0]].push(mapper(sub))
      } else {
        formErrors.push(mapper(sub))
      }
    }
    return { formErrors, fieldErrors }
  }
  get formErrors() {
    return this.flatten()
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues)
  return error2
}
var errorMap = (issue, _ctx) => {
  let message
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required"
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`
      }
      break
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`
      break
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`
      break
    case ZodIssueCode.invalid_union:
      message = `Invalid input`
      break
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`
      break
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`
      break
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`
      break
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`
      break
    case ZodIssueCode.invalid_date:
      message = `Invalid date`
      break
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`
        } else {
          util.assertNever(issue.validation)
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`
      } else {
        message = "Invalid"
      }
      break
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`
      else
        message = "Invalid input"
      break
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`
      else
        message = "Invalid input"
      break
    case ZodIssueCode.custom:
      message = `Invalid input`
      break
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`
      break
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`
      break
    case ZodIssueCode.not_finite:
      message = "Number must be finite"
      break
    default:
      message = _ctx.defaultError
      util.assertNever(issue)
  }
  return { message }
}
var overrideErrorMap = errorMap
function setErrorMap(map3) {
  overrideErrorMap = map3
}
function getErrorMap() {
  return overrideErrorMap
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params
  const fullPath = [...path, ...issueData.path || []]
  const fullIssue = {
    ...issueData,
    path: fullPath
  }
  let errorMessage = ""
  const maps = errorMaps.filter((m) => !!m).slice().reverse()
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  }
}
var EMPTY_PATH = []
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  })
  ctx.common.issues.push(issue)
}
var ParseStatus = class {
  constructor() {
    this.value = "valid"
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty"
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted"
  }
  static mergeArray(status2, results) {
    const arrayValue = []
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID
      if (s.status === "dirty")
        status2.dirty()
      arrayValue.push(s.value)
    }
    return { status: status2.value, value: arrayValue }
  }
  static async mergeObjectAsync(status2, pairs) {
    const syncPairs = []
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      })
    }
    return ParseStatus.mergeObjectSync(status2, syncPairs)
  }
  static mergeObjectSync(status2, pairs) {
    const finalObject = {}
    for (const pair of pairs) {
      const { key, value } = pair
      if (key.status === "aborted")
        return INVALID
      if (value.status === "aborted")
        return INVALID
      if (key.status === "dirty")
        status2.dirty()
      if (value.status === "dirty")
        status2.dirty()
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value
      }
    }
    return { status: status2.value, value: finalObject }
  }
}
var INVALID = Object.freeze({
  status: "aborted"
})
var DIRTY = (value) => ({ status: "dirty", value })
var OK = (value) => ({ status: "valid", value })
var isAborted = (x) => x.status === "aborted"
var isDirty = (x) => x.status === "dirty"
var isValid = (x) => x.status === "valid"
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise
var errorUtil;
(function (errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {}
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message
})(errorUtil || (errorUtil = {}))
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = []
    this.parent = parent
    this.data = value
    this._path = path
    this._key = key
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key)
      } else {
        this._cachedPath.push(...this._path, this._key)
      }
    }
    return this._cachedPath
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value }
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.")
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error
        const error2 = new ZodError(ctx.common.issues)
        this._error = error2
        return this._error
      }
    }
  }
}
function processCreateParams(params) {
  if (!params)
    return {}
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`)
  }
  if (errorMap2)
    return { errorMap: errorMap2, description }
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError }
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError }
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError }
  }
  return { errorMap: customMap, description }
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync
    this._def = def
    this.parse = this.parse.bind(this)
    this.safeParse = this.safeParse.bind(this)
    this.parseAsync = this.parseAsync.bind(this)
    this.safeParseAsync = this.safeParseAsync.bind(this)
    this.spa = this.spa.bind(this)
    this.refine = this.refine.bind(this)
    this.refinement = this.refinement.bind(this)
    this.superRefine = this.superRefine.bind(this)
    this.optional = this.optional.bind(this)
    this.nullable = this.nullable.bind(this)
    this.nullish = this.nullish.bind(this)
    this.array = this.array.bind(this)
    this.promise = this.promise.bind(this)
    this.or = this.or.bind(this)
    this.and = this.and.bind(this)
    this.transform = this.transform.bind(this)
    this.brand = this.brand.bind(this)
    this.default = this.default.bind(this)
    this.catch = this.catch.bind(this)
    this.describe = this.describe.bind(this)
    this.pipe = this.pipe.bind(this)
    this.isNullable = this.isNullable.bind(this)
    this.isOptional = this.isOptional.bind(this)
  }
  get description() {
    return this._def.description
  }
  _getType(input) {
    return getParsedType(input.data)
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    }
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    }
  }
  _parseSync(input) {
    const result = this._parse(input)
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.")
    }
    return result
  }
  _parseAsync(input) {
    const result = this._parse(input)
    return Promise.resolve(result)
  }
  parse(data, params) {
    const result = this.safeParse(data, params)
    if (result.success)
      return result.data
    throw result.error
  }
  safeParse(data, params) {
    var _a
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }
    const result = this._parseSync({ data, path: ctx.path, parent: ctx })
    return handleResult(ctx, result)
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params)
    if (result.success)
      return result.data
    throw result.error
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx })
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult))
    return handleResult(ctx, result)
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message }
      } else if (typeof message === "function") {
        return message(val)
      } else {
        return message
      }
    }
    return this._refinement((val, ctx) => {
      const result = check(val)
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      })
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError()
            return false
          } else {
            return true
          }
        })
      }
      if (!result) {
        setError()
        return false
      } else {
        return true
      }
    })
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData)
        return false
      } else {
        return true
      }
    })
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    })
  }
  superRefine(refinement) {
    return this._refinement(refinement)
  }
  optional() {
    return ZodOptional.create(this, this._def)
  }
  nullable() {
    return ZodNullable.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return ZodArray.create(this, this._def)
  }
  promise() {
    return ZodPromise.create(this, this._def)
  }
  or(option) {
    return ZodUnion.create([this, option], this._def)
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def)
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    })
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    })
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    })
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    })
  }
  describe(description) {
    const This = this.constructor
    return new This({
      ...this._def,
      description
    })
  }
  pipe(target) {
    return ZodPipeline.create(this, target)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i
var cuid2Regex = /^[a-z][a-z0-9]*$/
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/
var emojiRegex = /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`)
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`)
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`)
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`)
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`)
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`)
    }
  }
}
function isValidIP(ip, version5) {
  if ((version5 === "v4" || !version5) && ipv4Regex.test(ip)) {
    return true
  }
  if ((version5 === "v6" || !version5) && ipv6Regex.test(ip)) {
    return true
  }
  return false
}
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments)
    this._regex = (regex2, validation, message) => this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    })
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message))
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    })
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    })
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    })
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data)
    }
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      )
      return INVALID
    }
    const status2 = new ParseStatus()
    let ctx = void 0
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value
        const tooSmall = input.data.length < check.value
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx)
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            })
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            })
          }
          status2.dirty()
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data)
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0
        const testResult = check.regex.test(input.data)
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim()
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase()
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase()
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check)
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          })
          status2.dirty()
        }
      } else {
        util.assertNever(check)
      }
    }
    return { status: status2.value, value: input.data }
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    })
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) })
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) })
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) })
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) })
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) })
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) })
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) })
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) })
  }
  datetime(options2) {
    var _a
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options2
      })
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    })
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    })
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 === null || options2 === void 0 ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    })
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    })
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    })
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    })
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    })
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    })
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime")
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email")
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url")
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji")
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid")
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid")
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2")
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid")
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip")
  }
  get minLength() {
    let min = null
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value
      }
    }
    return min
  }
  get maxLength() {
    let max = null
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value
      }
    }
    return max
  }
}
ZodString.create = (params) => {
  var _a
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  })
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length
  const stepDecCount = (step.toString().split(".")[1] || "").length
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""))
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""))
  return valInt % stepInt / Math.pow(10, decCount)
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments)
    this.min = this.gte
    this.max = this.lte
    this.step = this.multipleOf
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data)
    }
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      })
      return INVALID
    }
    let ctx = void 0
    const status2 = new ParseStatus()
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          })
          status2.dirty()
        }
      } else {
        util.assertNever(check)
      }
    }
    return { status: status2.value, value: input.data }
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message))
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message))
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message))
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message))
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    })
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    })
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    })
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    })
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    })
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    })
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    })
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    })
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    })
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })
  }
  get minValue() {
    let min = null
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value
      }
    }
    return min
  }
  get maxValue() {
    let max = null
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value
      }
    }
    return max
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value))
  }
  get isFinite() {
    let max = null, min = null
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value
      }
    }
    return Number.isFinite(min) && Number.isFinite(max)
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  })
}
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments)
    this.min = this.gte
    this.max = this.lte
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data)
    }
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      })
      return INVALID
    }
    let ctx = void 0
    const status2 = new ParseStatus()
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          })
          status2.dirty()
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          })
          status2.dirty()
        }
      } else {
        util.assertNever(check)
      }
    }
    return { status: status2.value, value: input.data }
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message))
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message))
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message))
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message))
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    })
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    })
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    })
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    })
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    })
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    })
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    })
  }
  get minValue() {
    let min = null
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value
      }
    }
    return min
  }
  get maxValue() {
    let max = null
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value
      }
    }
    return max
  }
}
ZodBigInt.create = (params) => {
  var _a
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  })
}
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data)
    }
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      })
      return INVALID
    }
    return OK(input.data)
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  })
}
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data)
    }
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      })
      return INVALID
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      })
      return INVALID
    }
    const status2 = new ParseStatus()
    let ctx = void 0
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          })
          status2.dirty()
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx)
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          })
          status2.dirty()
        }
      } else {
        util.assertNever(check)
      }
    }
    return {
      status: status2.value,
      value: new Date(input.data.getTime())
    }
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    })
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    })
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    })
  }
  get minDate() {
    let min = null
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value
      }
    }
    return min != null ? new Date(min) : null
  }
  get maxDate() {
    let max = null
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value
      }
    }
    return max != null ? new Date(max) : null
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  })
}
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      })
      return INVALID
    }
    return OK(input.data)
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  })
}
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      })
      return INVALID
    }
    return OK(input.data)
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  })
}
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      })
      return INVALID
    }
    return OK(input.data)
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  })
}
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments)
    this._any = true
  }
  _parse(input) {
    return OK(input.data)
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  })
}
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments)
    this._unknown = true
  }
  _parse(input) {
    return OK(input.data)
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  })
}
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input)
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    })
    return INVALID
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  })
}
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      })
      return INVALID
    }
    return OK(input.data)
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  })
}
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status: status2 } = this._processInputParams(input)
    const def = this._def
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      })
      return INVALID
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value
      const tooSmall = ctx.data.length < def.exactLength.value
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        })
        status2.dirty()
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        })
        status2.dirty()
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        })
        status2.dirty()
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i))
      })).then((result2) => {
        return ParseStatus.mergeArray(status2, result2)
      })
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i))
    })
    return ParseStatus.mergeArray(status2, result)
  }
  get element() {
    return this._def.type
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    })
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    })
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    })
  }
  nonempty(message) {
    return this.min(1, message)
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  })
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {}
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key]
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema))
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    })
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    })
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()))
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()))
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)))
  } else {
    return schema
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments)
    this._cached = null
    this.nonstrict = this.passthrough
    this.augment = this.extend
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached
    const shape = this._def.shape()
    const keys2 = util.objectKeys(shape)
    return this._cached = { shape, keys: keys2 }
  }
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input)
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      })
      return INVALID
    }
    const { status: status2, ctx } = this._processInputParams(input)
    const { shape, keys: shapeKeys } = this._getCached()
    const extraKeys = []
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key)
        }
      }
    }
    const pairs = []
    for (const key of shapeKeys) {
      const keyValidator = shape[key]
      const value = ctx.data[key]
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      })
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          })
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          })
          status2.dirty()
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`)
      }
    } else {
      const catchall = this._def.catchall
      for (const key of extraKeys) {
        const value = ctx.data[key]
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        })
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = []
        for (const pair of pairs) {
          const key = await pair.key
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          })
        }
        return syncPairs
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status2, syncPairs)
      })
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs)
    }
  }
  get shape() {
    return this._def.shape()
  }
  strict(message) {
    errorUtil.errToObj
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            }
          return {
            message: defaultError
          }
        }
      } : {}
    })
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    })
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    })
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    })
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    })
    return merged
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema })
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    })
  }
  pick(mask) {
    const shape = {}
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key]
      }
    })
    return new ZodObject({
      ...this._def,
      shape: () => shape
    })
  }
  omit(mask) {
    const shape = {}
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key]
      }
    })
    return new ZodObject({
      ...this._def,
      shape: () => shape
    })
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this)
  }
  partial(mask) {
    const newShape = {}
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key]
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema
      } else {
        newShape[key] = fieldSchema.optional()
      }
    })
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    })
  }
  required(mask) {
    const newShape = {}
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key]
      } else {
        const fieldSchema = this.shape[key]
        let newField = fieldSchema
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType
        }
        newShape[key] = newField
      }
    })
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    })
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape))
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  })
}
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  })
}
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  })
}
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    const options2 = this._def.options
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues)
          return result.result
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues))
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      })
      return INVALID
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        }
      })).then(handleResults)
    } else {
      let dirty = void 0
      const issues = []
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        })
        if (result.status === "valid") {
          return result
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx }
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues)
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues)
        return dirty.result
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2))
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      })
      return INVALID
    }
  }
  get options() {
    return this._def.options
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  })
}
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema)
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType())
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value]
  } else if (type2 instanceof ZodEnum) {
    return type2.options
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum)
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType)
  } else if (type2 instanceof ZodUndefined) {
    return [void 0]
  } else if (type2 instanceof ZodNull) {
    return [null]
  } else {
    return null
  }
}
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      })
      return INVALID
    }
    const discriminator = this.discriminator
    const discriminatorValue = ctx.data[discriminator]
    const option = this.optionsMap.get(discriminatorValue)
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      })
      return INVALID
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    }
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map()
    for (const type2 of options2) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator])
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`)
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`)
        }
        optionsMap.set(value, type2)
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    })
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a)
  const bType = getParsedType(b)
  if (a === b) {
    return { valid: true, data: a }
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b)
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1)
    const newObj = { ...a, ...b }
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key])
      if (!sharedValue.valid) {
        return { valid: false }
      }
      newObj[key] = sharedValue.data
    }
    return { valid: true, data: newObj }
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false }
    }
    const newArray = []
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index]
      const itemB = b[index]
      const sharedValue = mergeValues(itemA, itemB)
      if (!sharedValue.valid) {
        return { valid: false }
      }
      newArray.push(sharedValue.data)
    }
    return { valid: true, data: newArray }
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a }
  } else {
    return { valid: false }
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value)
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        })
        return INVALID
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status2.dirty()
      }
      return { status: status2.value, value: merged.data }
    }
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right))
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }))
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  })
}
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      })
      return INVALID
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      })
      return INVALID
    }
    const rest = this._def.rest
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      })
      status2.dirty()
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest
      if (!schema)
        return null
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex))
    }).filter((x) => !!x)
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status2, results)
      })
    } else {
      return ParseStatus.mergeArray(status2, items)
    }
  }
  get items() {
    return this._def.items
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    })
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])")
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  })
}
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      })
      return INVALID
    }
    const pairs = []
    const keyType = this._def.keyType
    const valueType = this._def.valueType
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      })
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status2, pairs)
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs)
    }
  }
  get element() {
    return this._def.valueType
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      })
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    })
  }
}
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      })
      return INVALID
    }
    const keyType = this._def.keyType
    const valueType = this._def.valueType
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      }
    })
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map()
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key
          const value = await pair.value
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status2.dirty()
          }
          finalMap.set(key.value, value.value)
        }
        return { status: status2.value, value: finalMap }
      })
    } else {
      const finalMap = /* @__PURE__ */ new Map()
      for (const pair of pairs) {
        const key = pair.key
        const value = pair.value
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status2.dirty()
        }
        finalMap.set(key.value, value.value)
      }
      return { status: status2.value, value: finalMap }
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  })
}
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      })
      return INVALID
    }
    const def = this._def
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        })
        status2.dirty()
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        })
        status2.dirty()
      }
    }
    const valueType = this._def.valueType
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set()
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID
        if (element.status === "dirty")
          status2.dirty()
        parsedSet.add(element.value)
      }
      return { status: status2.value, value: parsedSet }
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)))
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2))
    } else {
      return finalizeSet(elements)
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    })
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    })
  }
  size(size, message) {
    return this.min(size, message).max(size, message)
  }
  nonempty(message) {
    return this.min(1, message)
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  })
}
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments)
    this.validate = this.implement
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      })
      return INVALID
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      })
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      })
    }
    const params = { errorMap: ctx.common.contextualErrorMap }
    const fn = ctx.data
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error2 = new ZodError([])
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e))
          throw error2
        })
        const result = await fn(...parsedArgs)
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result, e))
          throw error2
        })
        return parsedReturns
      })
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params)
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)])
        }
        const result = fn(...parsedArgs.data)
        const parsedReturns = this._def.returns.safeParse(result, params)
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)])
        }
        return parsedReturns.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    })
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    })
  }
  implement(func) {
    const validatedFunc = this.parse(func)
    return validatedFunc
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func)
    return validatedFunc
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    })
  }
}
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter()
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    const lazySchema = this._def.getter()
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx })
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  })
}
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      })
      return INVALID
    }
    return { status: "valid", value: input.data }
  }
  get value() {
    return this._def.value
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  })
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  })
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input)
      const expectedValues = this._def.values
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      })
      return INVALID
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input)
      const expectedValues = this._def.values
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      })
      return INVALID
    }
    return OK(input.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const enumValues = {}
    for (const val of this._def.values) {
      enumValues[val] = val
    }
    return enumValues
  }
  get Values() {
    const enumValues = {}
    for (const val of this._def.values) {
      enumValues[val] = val
    }
    return enumValues
  }
  get Enum() {
    const enumValues = {}
    for (const val of this._def.values) {
      enumValues[val] = val
    }
    return enumValues
  }
  extract(values) {
    return ZodEnum.create(values)
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)))
  }
}
ZodEnum.create = createZodEnum
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values)
    const ctx = this._getOrReturnCtx(input)
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues)
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      })
      return INVALID
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues)
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      })
      return INVALID
    }
    return OK(input.data)
  }
  get enum() {
    return this._def.values
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  })
}
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      })
      return INVALID
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data)
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      })
    }))
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  })
}
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    const effect = this._def.effect || null
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data)
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          })
        })
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        })
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg)
        if (arg.fatal) {
          status2.abort()
        } else {
          status2.dirty()
        }
      },
      get path() {
        return ctx.path
      }
    }
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx)
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx)
        if (ctx.common.async) {
          return Promise.resolve(result)
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.")
        }
        return acc
      }
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
        if (inner.status === "aborted")
          return INVALID
        if (inner.status === "dirty")
          status2.dirty()
        executeRefinement(inner.value)
        return { status: status2.value, value: inner.value }
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID
          if (inner.status === "dirty")
            status2.dirty()
          return executeRefinement(inner.value).then(() => {
            return { status: status2.value, value: inner.value }
          })
        })
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
        if (!isValid(base2))
          return base2
        const result = effect.transform(base2.value, checkCtx)
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`)
        }
        return { status: status2.value, value: result }
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status2.value, value: result }))
        })
      }
    }
    util.assertNever(effect)
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  })
}
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  })
}
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0)
    }
    return this._def.innerType._parse(input)
  }
  unwrap() {
    return this._def.innerType
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  })
}
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType === ZodParsedType.null) {
      return OK(null)
    }
    return this._def.innerType._parse(input)
  }
  unwrap() {
    return this._def.innerType
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  })
}
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    let data = ctx.data
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue()
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    })
  }
  removeDefault() {
    return this._def.innerType
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  })
}
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    })
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues)
            },
            input: newCtx.data
          })
        }
      })
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues)
          },
          input: newCtx.data
        })
      }
    }
  }
  removeCatch() {
    return this._def.innerType
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  })
}
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      })
      return INVALID
    }
    return { status: "valid", value: input.data }
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  })
}
var BRAND = Symbol("zod_brand")
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input)
    const data = ctx.data
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    })
  }
  unwrap() {
    return this._def.type
  }
}
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input)
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
        if (inResult.status === "aborted")
          return INVALID
        if (inResult.status === "dirty") {
          status2.dirty()
          return DIRTY(inResult.value)
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          })
        }
      }
      return handleAsync()
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
      if (inResult.status === "aborted")
        return INVALID
      if (inResult.status === "dirty") {
        status2.dirty()
        return {
          status: "dirty",
          value: inResult.value
        }
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        })
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    })
  }
}
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true
        const p2 = typeof p === "string" ? { message: p } : p
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal })
      }
    })
  return ZodAny.create()
}
var late = {
  object: ZodObject.lazycreate
}
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString"
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber"
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN"
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt"
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean"
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate"
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol"
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined"
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull"
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny"
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown"
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever"
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid"
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray"
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject"
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion"
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion"
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection"
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple"
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord"
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap"
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet"
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction"
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy"
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral"
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum"
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects"
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum"
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional"
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable"
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault"
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch"
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise"
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded"
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline"
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}))
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params)
var stringType = ZodString.create
var numberType = ZodNumber.create
var nanType = ZodNaN.create
var bigIntType = ZodBigInt.create
var booleanType = ZodBoolean.create
var dateType = ZodDate.create
var symbolType = ZodSymbol.create
var undefinedType = ZodUndefined.create
var nullType = ZodNull.create
var anyType = ZodAny.create
var unknownType = ZodUnknown.create
var neverType = ZodNever.create
var voidType = ZodVoid.create
var arrayType = ZodArray.create
var objectType = ZodObject.create
var strictObjectType = ZodObject.strictCreate
var unionType = ZodUnion.create
var discriminatedUnionType = ZodDiscriminatedUnion.create
var intersectionType = ZodIntersection.create
var tupleType = ZodTuple.create
var recordType = ZodRecord.create
var mapType = ZodMap.create
var setType = ZodSet.create
var functionType = ZodFunction.create
var lazyType = ZodLazy.create
var literalType = ZodLiteral.create
var enumType = ZodEnum.create
var nativeEnumType = ZodNativeEnum.create
var promiseType = ZodPromise.create
var effectsType = ZodEffects.create
var optionalType = ZodOptional.create
var nullableType = ZodNullable.create
var preprocessType = ZodEffects.createWithPreprocess
var pipelineType = ZodPipeline.create
var ostring = () => stringType().optional()
var onumber = () => numberType().optional()
var oboolean = () => booleanType().optional()
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
}
var NEVER = INVALID
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util
  },
  get objectUtil() {
    return objectUtil
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
})

// node_modules/langchain/dist/tools/base.js
init_manager()
init_base_language()
var StructuredTool = class extends BaseLangChain {
  constructor(fields) {
    super(fields != null ? fields : {})
    Object.defineProperty(this, "returnDirect", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    })
  }
  async call(arg, callbacks) {
    const parsed = await this.schema.parseAsync(arg)
    const callbackManager_ = await CallbackManager.configure(callbacks, this.callbacks, { verbose: this.verbose })
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleToolStart({ name: this.name }, typeof parsed === "string" ? parsed : JSON.stringify(parsed)))
    let result
    try {
      result = await this._call(parsed, runManager)
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleToolError(e))
      throw e
    }
    await (runManager == null ? void 0 : runManager.handleToolEnd(result))
    return result
  }
}
var Tool = class extends StructuredTool {
  constructor(verbose, callbacks) {
    super({ verbose, callbacks })
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: z.object({ input: z.string().optional() }).transform((obj) => obj.input)
    })
  }
  call(arg, callbacks) {
    return super.call(typeof arg === "string" || !arg ? { input: arg } : arg, callbacks)
  }
}

// node_modules/langchain/dist/agents/agent_toolkits/json/prompt.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/json/json.js
init_llm_chain()
init_mrkl()

// node_modules/langchain/dist/agents/agent_toolkits/base.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/executor.js
init_process()
init_buffer()
init_base5()
var AgentExecutor = class extends BaseChain {
  get inputKeys() {
    return this.agent.inputKeys
  }
  get outputKeys() {
    return this.agent.returnValues
  }
  constructor(input) {
    var _a, _b, _c, _d
    super(input.memory, input.verbose, (_a = input.callbacks) != null ? _a : input.callbackManager)
    Object.defineProperty(this, "agent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "tools", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "returnIntermediateSteps", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    })
    Object.defineProperty(this, "maxIterations", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 15
    })
    Object.defineProperty(this, "earlyStoppingMethod", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "force"
    })
    this.agent = input.agent
    this.tools = input.tools
    if (this.agent._agentActionType() === "multi") {
      for (const tool of this.tools) {
        if (tool.returnDirect) {
          throw new Error(`Tool with return direct ${tool.name} not supported for multi-action agent.`)
        }
      }
    }
    this.returnIntermediateSteps = (_b = input.returnIntermediateSteps) != null ? _b : this.returnIntermediateSteps
    this.maxIterations = (_c = input.maxIterations) != null ? _c : this.maxIterations
    this.earlyStoppingMethod = (_d = input.earlyStoppingMethod) != null ? _d : this.earlyStoppingMethod
  }
  /** Create from agent and a list of tools. */
  static fromAgentAndTools(fields) {
    return new AgentExecutor(fields)
  }
  shouldContinue(iterations) {
    return this.maxIterations === void 0 || iterations < this.maxIterations
  }
  /** @ignore */
  async _call(inputs, runManager) {
    var _a
    const toolsByName = Object.fromEntries(this.tools.map((t) => [t.name.toLowerCase(), t]))
    const steps = []
    let iterations = 0
    const getOutput = async (finishStep) => {
      const { returnValues } = finishStep
      const additional = await this.agent.prepareForOutput(returnValues, steps)
      if (this.returnIntermediateSteps) {
        return { ...returnValues, intermediateSteps: steps, ...additional }
      }
      await (runManager == null ? void 0 : runManager.handleAgentEnd(finishStep))
      return { ...returnValues, ...additional }
    }
    while (this.shouldContinue(iterations)) {
      const output = await this.agent.plan(steps, inputs, runManager == null ? void 0 : runManager.getChild())
      if ("returnValues" in output) {
        return getOutput(output)
      }
      let actions
      if (Array.isArray(output)) {
        actions = output
      } else {
        actions = [output]
      }
      const newSteps = await Promise.all(actions.map(async (action) => {
        var _a2
        await (runManager == null ? void 0 : runManager.handleAgentAction(action))
        const tool = toolsByName[(_a2 = action.tool) == null ? void 0 : _a2.toLowerCase()]
        const observation = tool ? await tool.call(action.toolInput, runManager == null ? void 0 : runManager.getChild()) : `${action.tool} is not a valid tool, try another one.`
        return { action, observation }
      }))
      steps.push(...newSteps)
      const lastStep = steps[steps.length - 1]
      const lastTool = toolsByName[(_a = lastStep.action.tool) == null ? void 0 : _a.toLowerCase()]
      if (lastTool == null ? void 0 : lastTool.returnDirect) {
        return getOutput({
          returnValues: { [this.agent.returnValues[0]]: lastStep.observation },
          log: ""
        })
      }
      iterations += 1
    }
    const finish = await this.agent.returnStoppedResponse(this.earlyStoppingMethod, steps, inputs)
    return getOutput(finish)
  }
  _chainType() {
    return "agent_executor"
  }
  serialize() {
    throw new Error("Cannot serialize an AgentExecutor")
  }
}

// node_modules/langchain/dist/agents/agent_toolkits/sql/sql.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/sql.js
init_process()
init_buffer()
init_openai2()
init_llm_chain()
init_prompt()

// node_modules/langchain/dist/agents/agent_toolkits/sql/prompt.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/sql/sql.js
init_template()
init_llm_chain()
init_mrkl()

// node_modules/langchain/dist/agents/agent_toolkits/openapi/openapi.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/dynamic.js
init_process()
init_buffer()
var DynamicTool = class extends Tool {
  constructor(fields) {
    var _a
    super(fields.verbose, fields.callbacks)
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    this.name = fields.name
    this.description = fields.description
    this.func = fields.func
    this.returnDirect = (_a = fields.returnDirect) != null ? _a : this.returnDirect
  }
  /** @ignore */
  async _call(input, runManager) {
    return this.func(input, runManager)
  }
}

// node_modules/langchain/dist/agents/agent_toolkits/openapi/prompt.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/openapi/openapi.js
init_llm_chain()
init_mrkl()

// node_modules/langchain/dist/tools/requests.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/vectorstore/vectorstore.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/vectorstore.js
init_process()
init_buffer()
init_vector_db_qa()

// node_modules/langchain/dist/agents/agent_toolkits/vectorstore/vectorstore.js
init_mrkl()

// node_modules/langchain/dist/agents/agent_toolkits/vectorstore/prompt.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/agent_toolkits/vectorstore/vectorstore.js
init_prompt2()
init_llm_chain()

// node_modules/langchain/dist/agents/agent_toolkits/zapier/zapier.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/zapier.js
init_process()
init_buffer()
init_template()
init_async_caller()

// node_modules/langchain/dist/agents/chat/index.js
init_process()
init_buffer()
init_llm_chain()
init_chat()
init_agent()

// node_modules/langchain/dist/agents/chat/outputParser.js
init_process()
init_buffer()
init_types()

// node_modules/langchain/dist/agents/chat/prompt.js
init_process()
init_buffer()

// node_modules/langchain/dist/agents/chat_convo/index.js
init_process()
init_buffer()
init_llm_chain()
init_chat()
init_template()
init_schema()
init_agent()

// node_modules/langchain/dist/agents/chat_convo/outputParser.js
init_process()
init_buffer()
init_types()

// node_modules/langchain/dist/agents/chat_convo/prompt.js
init_process()
init_buffer()
var DEFAULT_PREFIX = `Assistant is a large language model trained by OpenAI.

Assistant is designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.

Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of topics.

Overall, Assistant is a powerful system that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether you need help with a specific question or just want to have a conversation about a particular topic, Assistant is here to assist.`
var PREFIX_END = ` However, above all else, all responses must adhere to the format of RESPONSE FORMAT INSTRUCTIONS.`
var FORMAT_INSTRUCTIONS3 = `RESPONSE FORMAT INSTRUCTIONS
----------------------------

When responding to me please, please output a response in one of two formats:

**Option 1:**
Use this if you want the human to use a tool.
Markdown code snippet formatted in the following schema:

\`\`\`json
{{{{
    "action": string \\ The action to take. Must be one of {tool_names}
    "action_input": string \\ The input to the action
}}}}
\`\`\`

**Option #2:**
Use this if you want to respond directly to the human. Markdown code snippet formatted in the following schema:

\`\`\`json
{{{{
    "action": "Final Answer",
    "action_input": string \\ You should put what you want to return to use here and make sure to use valid json newline characters.
}}}}
\`\`\``
var DEFAULT_SUFFIX = `TOOLS
------
Assistant can ask the user to use tools to look up information that may be helpful in answering the users original question. The tools the human can use are:

{{tools}}

{format_instructions}

USER'S INPUT
--------------------
Here is the user's input (remember to respond with a markdown code snippet of a json blob with a single action, and NOTHING else):

{{{{input}}}}`
var TEMPLATE_TOOL_RESPONSE = `TOOL RESPONSE:
---------------------
{observation}

USER'S INPUT
--------------------

Okay, so what is the response to my original question? If using information from tools, you must say it explicitly - I have forgotten all TOOL RESPONSES! Remember to respond with a markdown code snippet of a json blob with a single action, and NOTHING else.`

// node_modules/langchain/dist/agents/chat_convo/outputParser.js
var ChatConversationalAgentOutputParser = class extends AgentActionOutputParser {
  async parse(text) {
    let jsonOutput = text.trim()
    if (jsonOutput.includes("```json")) {
      jsonOutput = jsonOutput.split("```json")[1].trimStart()
    } else if (jsonOutput.includes("```")) {
      const firstIndex = jsonOutput.indexOf("```")
      jsonOutput = jsonOutput.slice(firstIndex + 3).trimStart()
    }
    const lastIndex = jsonOutput.lastIndexOf("```")
    if (lastIndex !== -1) {
      jsonOutput = jsonOutput.slice(0, lastIndex).trimEnd()
    }
    const response = JSON.parse(jsonOutput)
    const { action, action_input } = response
    if (action === "Final Answer") {
      return { returnValues: { output: action_input }, log: text }
    }
    return { tool: action, toolInput: action_input, log: text }
  }
  getFormatInstructions() {
    return FORMAT_INSTRUCTIONS3
  }
}

// node_modules/langchain/dist/agents/chat_convo/index.js
var ChatConversationalAgent = class extends Agent3 {
  constructor(input) {
    var _a
    const outputParser = (_a = input.outputParser) != null ? _a : ChatConversationalAgent.getDefaultOutputParser()
    super({ ...input, outputParser })
  }
  _agentType() {
    return "chat-conversational-react-description"
  }
  observationPrefix() {
    return "Observation: "
  }
  llmPrefix() {
    return "Thought:"
  }
  _stop() {
    return ["Observation:"]
  }
  static validateTools(tools) {
    const invalidTool = tools.find((tool) => !tool.description)
    if (invalidTool) {
      const msg = `Got a tool ${invalidTool.name} without a description. This agent requires descriptions for all tools.`
      throw new Error(msg)
    }
  }
  async constructScratchPad(steps) {
    const thoughts = []
    for (const step of steps) {
      thoughts.push(new AIChatMessage(step.action.log))
      thoughts.push(new HumanChatMessage(renderTemplate(TEMPLATE_TOOL_RESPONSE, "f-string", {
        observation: step.observation
      })))
    }
    return thoughts
  }
  static getDefaultOutputParser(_fields) {
    return new ChatConversationalAgentOutputParser()
  }
  /**
   * Create prompt in the style of the ChatConversationAgent.
   *
   * @param tools - List of tools the agent will have access to, used to format the prompt.
   * @param args - Arguments to create the prompt with.
   * @param args.systemMessage - String to put before the list of tools.
   * @param args.humanMessage - String to put after the list of tools.
   */
  static createPrompt(tools, args) {
    var _a, _b, _c
    const systemMessage = ((_a = args == null ? void 0 : args.systemMessage) != null ? _a : DEFAULT_PREFIX) + PREFIX_END
    const humanMessage = (_b = args == null ? void 0 : args.humanMessage) != null ? _b : DEFAULT_SUFFIX
    const outputParser = (_c = args == null ? void 0 : args.outputParser) != null ? _c : new ChatConversationalAgentOutputParser()
    const toolStrings = tools.map((tool) => `${tool.name}: ${tool.description}`).join("\n")
    const formatInstructions = renderTemplate(humanMessage, "f-string", {
      format_instructions: outputParser.getFormatInstructions()
    })
    const toolNames = tools.map((tool) => tool.name).join("\n")
    const finalPrompt = renderTemplate(formatInstructions, "f-string", {
      tools: toolStrings,
      tool_names: toolNames
    })
    const messages2 = [
      SystemMessagePromptTemplate.fromTemplate(systemMessage),
      new MessagesPlaceholder("chat_history"),
      HumanMessagePromptTemplate.fromTemplate(finalPrompt),
      new MessagesPlaceholder("agent_scratchpad")
    ]
    return ChatPromptTemplate.fromPromptMessages(messages2)
  }
  static fromLLMAndTools(llm, tools, args) {
    var _a, _b
    ChatConversationalAgent.validateTools(tools)
    const prompt = ChatConversationalAgent.createPrompt(tools, args)
    const chain = new LLMChain({
      prompt,
      llm,
      callbacks: (_a = args == null ? void 0 : args.callbacks) != null ? _a : args == null ? void 0 : args.callbackManager
    })
    const outputParser = (_b = args == null ? void 0 : args.outputParser) != null ? _b : ChatConversationalAgent.getDefaultOutputParser()
    return new ChatConversationalAgent({
      llmChain: chain,
      outputParser,
      allowedTools: tools.map((t) => t.name)
    })
  }
}

// node_modules/langchain/dist/agents/initialize.js
init_process()
init_buffer()

// node_modules/langchain/dist/memory/buffer_memory.js
init_process()
init_buffer()
init_base()

// node_modules/langchain/dist/memory/chat_memory.js
init_process()
init_buffer()
init_base()

// node_modules/langchain/dist/stores/message/in_memory.js
init_process()
init_buffer()
init_schema()
var ChatMessageHistory = class extends BaseChatMessageHistory {
  constructor(messages2) {
    super()
    Object.defineProperty(this, "messages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    })
    this.messages = messages2 != null ? messages2 : []
  }
  async getMessages() {
    return this.messages
  }
  async addUserMessage(message) {
    this.messages.push(new HumanChatMessage(message))
  }
  async addAIChatMessage(message) {
    this.messages.push(new AIChatMessage(message))
  }
  async clear() {
    this.messages = []
  }
}

// node_modules/langchain/dist/memory/chat_memory.js
var BaseChatMemory = class extends BaseMemory {
  constructor(fields) {
    var _a, _b, _c, _d
    super()
    Object.defineProperty(this, "chatHistory", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "returnMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    })
    Object.defineProperty(this, "inputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "outputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    this.chatHistory = (_a = fields == null ? void 0 : fields.chatHistory) != null ? _a : new ChatMessageHistory()
    this.returnMessages = (_b = fields == null ? void 0 : fields.returnMessages) != null ? _b : this.returnMessages
    this.inputKey = (_c = fields == null ? void 0 : fields.inputKey) != null ? _c : this.inputKey
    this.outputKey = (_d = fields == null ? void 0 : fields.outputKey) != null ? _d : this.outputKey
  }
  async saveContext(inputValues, outputValues) {
    await this.chatHistory.addUserMessage(getInputValue(inputValues, this.inputKey))
    await this.chatHistory.addAIChatMessage(getInputValue(outputValues, this.outputKey))
  }
  async clear() {
    await this.chatHistory.clear()
  }
}

// node_modules/langchain/dist/memory/buffer_memory.js
var BufferMemory = class extends BaseChatMemory {
  constructor(fields) {
    var _a, _b, _c, _d
    super({
      chatHistory: fields == null ? void 0 : fields.chatHistory,
      returnMessages: (_a = fields == null ? void 0 : fields.returnMessages) != null ? _a : false,
      inputKey: fields == null ? void 0 : fields.inputKey,
      outputKey: fields == null ? void 0 : fields.outputKey
    })
    Object.defineProperty(this, "humanPrefix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Human"
    })
    Object.defineProperty(this, "aiPrefix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AI"
    })
    Object.defineProperty(this, "memoryKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "history"
    })
    this.humanPrefix = (_b = fields == null ? void 0 : fields.humanPrefix) != null ? _b : this.humanPrefix
    this.aiPrefix = (_c = fields == null ? void 0 : fields.aiPrefix) != null ? _c : this.aiPrefix
    this.memoryKey = (_d = fields == null ? void 0 : fields.memoryKey) != null ? _d : this.memoryKey
  }
  get memoryKeys() {
    return [this.memoryKey]
  }
  async loadMemoryVariables(_values) {
    const messages2 = await this.chatHistory.getMessages()
    if (this.returnMessages) {
      const result2 = {
        [this.memoryKey]: messages2
      }
      return result2
    }
    const result = {
      [this.memoryKey]: getBufferString(messages2)
    }
    return result
  }
}

// node_modules/langchain/dist/agents/initialize.js
init_mrkl()

// node_modules/langchain/dist/agents/index.js
init_mrkl()
init_outputParser()
init_types()

// src/libs/tools/zoteroSearch.ts
init_process()
init_buffer()

// node_modules/langchain/tools.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/index.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/serpapi.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/dadjokeapi.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/bingserpapi.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/IFTTTWebhook.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/chain.js
init_process()
init_buffer()
var ChainTool = class extends DynamicTool {
  constructor({ chain, ...rest }) {
    super({
      ...rest,
      func: async (input, runManager) => chain.run(input, runManager == null ? void 0 : runManager.getChild())
    })
    Object.defineProperty(this, "chain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    this.chain = chain
  }
}

// node_modules/langchain/dist/tools/serper.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/aiplugin.js
init_process()
init_buffer()

// node_modules/langchain/dist/tools/fs.js
init_process()
init_buffer()

// src/libs/tools/zoteroSearch.ts
var import_search_query_parser = __toESM(require_search_query_parser2())
var ZoteroSearch = class extends Tool {
  constructor() {
    super()
    this.name = "zotero-search"
    this.description = `Useful for finding relevant articles from user's personal Zotero database. The gathered articles can then be used to answer user question. This tool is not useful if the question is not based on article contents. The input to this tool should be a search query, which is either a set of keywords (example: machine learning materials discovery), or a search query syntax created by the zotero-query tool (example: chemistry creator:white tag:"machine learning").`
  }
  async _call(input) {
    try {
      const s = new Zotero.Search()
      s.addCondition("itemType", "isNot", "attachment")
      const query = (0, import_search_query_parser.parse)(input, {
        keywords: ["creator", "tag"],
        ranges: ["year"],
        alwaysArray: true,
        offsets: false
      })
      console.log({ query })
      if (typeof query === "string") {
        s.addCondition("quicksearch-everything", "contains", query)
      } else {
        const {
          text,
          creator = [],
          tag = [],
          year
        } = query
        text == null ? void 0 : text.split(" ").forEach((t) => s.addCondition("quicksearch-everything", "contains", t))
        creator.forEach((c) => c.split(" ").forEach((w) => s.addCondition("creator", "contains", w)))
        tag.forEach((t) => s.addCondition("tag", "is", t))
        year && year.from && s.addCondition("date", "isAfter", `${parseInt(year.from) - 1}`)
        year && year.to && s.addCondition("date", "isBefore", `${parseInt(year.to) + 1}`)
      }
      const ids = await s.search()
      const results = await Promise.all(
        ids.map(async (id) => {
          return await Zotero.Items.getAsync(id)
        })
      )
      const output = results.filter((item) => item.itemType !== "attachment").slice(0, 5).map((item) => {
        const id = item.id
        const itemType = item.itemType
        const title3 = item.getField("title", false, true)
        const author = item.getField("firstCreator", false, true)
        const date = item.getField("date", true, true)
        return `
          id: ${id}
          itemType: ${itemType}
          title: ${title3}
          author: ${author}
          date: ${date}
          `
      })
      if (output.length) {
        return output.join("------------------------")
      }
      return `No results was found in user's Zotero library for query: ${input}.`
    } catch (error2) {
      const errorObj = serializeError(error2)
      console.log({ zoteroSearchError: errorObj })
      return `Error: ${errorObj.message}`
    }
  }
}

// src/libs/tools/zoteroItem.ts
init_process()
init_buffer()
var ZoteroItem = class extends Tool {
  constructor() {
    super()
    this.name = "zotero-item"
    this.description = `Useful for retrieving an item from Zotero and extract some key fields for summarization. The input to this tool should be a string representing an item ID such as "576".`
  }
  async _call(input) {
    try {
      const item = await Zotero.Items.getAsync(parseInt(input))
      const id = item.id
      const itemType = item.itemType
      const title3 = item.getField("title", false, true)
      const abstract = item.getField("abstractNote", false, true) || ""
      const author = item.getField("firstCreator", false, true)
      const date = item.getField("date", true, true)
      const publication = item.getField("publicationTitle", false, true)
      return `
      ## ID
      ${id}

      ## Item Type
      ${itemType}
      
      ## Title
      ${title3}

      ## Abstract
      ${abstract}

      ## Author
      ${author} et al.

      ## Publication Date
      ${date}

      ## Publication Name
      ${publication}
      `
    } catch (error2) {
      const errorObj = serializeError(error2)
      console.log({ zoteroItemError: errorObj })
      return `Error: ${errorObj.message}`
    }
  }
}

// src/libs/tools/zoteroCollection.ts
init_process()
init_buffer()
var ZoteroCollection = class extends Tool {
  constructor() {
    super()
    this.name = "zotero-collection"
    this.description = `Useful for retrieving the current collection information, including id, name, parent, library and number of items. The input is a collection ID.`
  }
  async _call(input) {
    try {
      const sql = `
        SELECT c.collectionID, c.collectionName, c.parentCollectionID, c.libraryID, COUNT(ci.itemID) as itemCount
        FROM collections c
        LEFT JOIN collectionItems ci ON c.collectionID=ci.collectionID
        WHERE c.collectionID=?
        GROUP BY c.collectionID
      `.trim()
      const results = await Zotero.DB.queryAsync(sql, [`${input}`])
      let output = []
      for (let row of results) {
        output.push({
          id: row.collectionID,
          name: row.collectionName,
          parent: row.parentCollectionID,
          library: row.libraryID,
          itemCount: row.itemCount
        })
      }
      if (output.length > 0) {
        return `ID: ${output[0].id}
        Name: ${output[0].name}
        Parent ID: ${output[0].parent}
        Library ID: ${output[0].library}
        Number of items in collection: ${output[0].itemCount}
        `
      }
      return `No collection matching ID ${input} found.`
    } catch (error2) {
      return `Error retrieving collection information for ${input}`
    }
  }
}

// src/libs/tools/zoteroCreators.ts
init_process()
init_buffer()
var ZoteroCreators = class extends Tool {
  constructor() {
    super()
    this.name = "zotero-creators"
    this.description = `Useful for searching for creators (authors, editors) in Zotero. The input to this tool should be a string representing a partial creator name.`
  }
  async _call(input) {
    try {
      const sql = `
        SELECT DISTINCT CASE fieldMode 
          WHEN 1 THEN lastName 
				  WHEN 0 THEN firstName || ' ' || lastName END AS val, NULL AS id 
				FROM creators
        WHERE CASE fieldMode 
          WHEN 1 THEN lastName LIKE ?1
          WHEN 0 THEN (firstName || ' ' || lastName LIKE ?1) OR (lastName LIKE ?1) END
        ORDER BY val
        LIMIT 10
      `.trim()
      const results = await Zotero.DB.queryAsync(sql, [`${input}`])
      let output = []
      for (let row of results) {
        output.push(row.val)
      }
      return output.join("\n")
    } catch (error2) {
      const errorObj = serializeError(error2)
      console.log({ zoteroCreatorsError: errorObj })
      return `Error: ${errorObj.message}`
    }
  }
}

// node_modules/langchain/memory.js
init_process()
init_buffer()

// node_modules/langchain/dist/memory/index.js
init_process()
init_buffer()
init_base()

// node_modules/langchain/dist/memory/summary.js
init_process()
init_buffer()
init_llm_chain()
init_schema()
init_base()

// node_modules/langchain/dist/memory/prompt.js
init_process()
init_buffer()
init_prompt()

// node_modules/langchain/dist/memory/buffer_window_memory.js
init_process()
init_buffer()
init_base()

// node_modules/langchain/dist/memory/motorhead_memory.js
init_process()
init_buffer()
init_base()
init_async_caller()

// src/libs/chains/queryBuilder.ts
init_process()
init_buffer()

// node_modules/langchain/prompts.js
init_process()
init_buffer()
init_prompts()

// node_modules/langchain/chains.js
init_process()
init_buffer()

// node_modules/langchain/dist/chains/index.js
init_process()
init_buffer()
init_base5()
init_llm_chain()

// node_modules/langchain/dist/chains/conversation.js
init_process()
init_buffer()
init_llm_chain()
init_prompt()

// node_modules/langchain/dist/chains/index.js
init_sequential_chain()
init_combine_docs_chain()

// node_modules/langchain/dist/chains/chat_vector_db_chain.js
init_process()
init_buffer()
init_prompt()
init_base5()
init_llm_chain()
init_load()

// node_modules/langchain/dist/chains/analyze_documents_chain.js
init_process()
init_buffer()
init_base5()

// node_modules/langchain/dist/text_splitter.js
init_process()
init_buffer()
init_document()
var TextSplitter = class {
  constructor(fields) {
    var _a, _b
    Object.defineProperty(this, "chunkSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 1e3
    })
    Object.defineProperty(this, "chunkOverlap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 200
    })
    this.chunkSize = (_a = fields == null ? void 0 : fields.chunkSize) != null ? _a : this.chunkSize
    this.chunkOverlap = (_b = fields == null ? void 0 : fields.chunkOverlap) != null ? _b : this.chunkOverlap
    if (this.chunkOverlap >= this.chunkSize) {
      throw new Error("Cannot have chunkOverlap >= chunkSize")
    }
  }
  async createDocuments(texts, metadatas = []) {
    const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({})
    const documents = new Array()
    for (let i = 0; i < texts.length; i += 1) {
      const text = texts[i]
      let lineCounterIndex = 1
      let prevChunk = null
      for (const chunk of await this.splitText(text)) {
        let numberOfIntermediateNewLines = 0
        if (prevChunk) {
          const indexChunk = text.indexOf(chunk)
          const indexEndPrevChunk = text.indexOf(prevChunk) + prevChunk.length
          const removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk)
          numberOfIntermediateNewLines = (removedNewlinesFromSplittingText.match(/\n/g) || []).length
        }
        lineCounterIndex += numberOfIntermediateNewLines
        const newLinesCount = (chunk.match(/\n/g) || []).length
        const loc = _metadatas[i].loc && typeof _metadatas[i].loc === "object" ? { ..._metadatas[i].loc } : {}
        loc.lines = {
          from: lineCounterIndex,
          to: lineCounterIndex + newLinesCount
        }
        const metadataWithLinesNumber = {
          ..._metadatas[i],
          loc
        }
        documents.push(new Document({
          pageContent: chunk,
          metadata: metadataWithLinesNumber
        }))
        lineCounterIndex += newLinesCount
        prevChunk = chunk
      }
    }
    return documents
  }
  async splitDocuments(documents) {
    const selectedDocuments = documents.filter((doc) => doc.pageContent !== void 0)
    const texts = selectedDocuments.map((doc) => doc.pageContent)
    const metadatas = selectedDocuments.map((doc) => doc.metadata)
    return this.createDocuments(texts, metadatas)
  }
  joinDocs(docs, separator) {
    const text = docs.join(separator).trim()
    return text === "" ? null : text
  }
  mergeSplits(splits, separator) {
    const docs = []
    const currentDoc = []
    let total = 0
    for (const d of splits) {
      const _len = d.length
      if (total + _len >= this.chunkSize) {
        if (total > this.chunkSize) {
          console.warn(`Created a chunk of size ${total}, +
which is longer than the specified ${this.chunkSize}`)
        }
        if (currentDoc.length > 0) {
          const doc2 = this.joinDocs(currentDoc, separator)
          if (doc2 !== null) {
            docs.push(doc2)
          }
          while (total > this.chunkOverlap || total + _len > this.chunkSize && total > 0) {
            total -= currentDoc[0].length
            currentDoc.shift()
          }
        }
      }
      currentDoc.push(d)
      total += _len
    }
    const doc = this.joinDocs(currentDoc, separator)
    if (doc !== null) {
      docs.push(doc)
    }
    return docs
  }
}
var RecursiveCharacterTextSplitter = class extends TextSplitter {
  constructor(fields) {
    var _a
    super(fields)
    Object.defineProperty(this, "separators", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["\n\n", "\n", " ", ""]
    })
    this.separators = (_a = fields == null ? void 0 : fields.separators) != null ? _a : this.separators
  }
  async splitText(text) {
    const finalChunks = []
    let separator = this.separators[this.separators.length - 1]
    for (const s of this.separators) {
      if (s === "") {
        separator = s
        break
      }
      if (text.includes(s)) {
        separator = s
        break
      }
    }
    let splits
    if (separator) {
      splits = text.split(separator)
    } else {
      splits = text.split("")
    }
    let goodSplits = []
    for (const s of splits) {
      if (s.length < this.chunkSize) {
        goodSplits.push(s)
      } else {
        if (goodSplits.length) {
          const mergedText = this.mergeSplits(goodSplits, separator)
          finalChunks.push(...mergedText)
          goodSplits = []
        }
        const otherInfo = await this.splitText(s)
        finalChunks.push(...otherInfo)
      }
    }
    if (goodSplits.length) {
      const mergedText = this.mergeSplits(goodSplits, separator)
      finalChunks.push(...mergedText)
    }
    return finalChunks
  }
}

// node_modules/langchain/dist/chains/analyze_documents_chain.js
var AnalyzeDocumentChain = class extends BaseChain {
  constructor(fields) {
    var _a, _b
    super(fields)
    Object.defineProperty(this, "inputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "input_document"
    })
    Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    Object.defineProperty(this, "textSplitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    })
    this.combineDocumentsChain = fields.combineDocumentsChain
    this.inputKey = (_a = fields.inputKey) != null ? _a : this.inputKey
    this.textSplitter = (_b = fields.textSplitter) != null ? _b : new RecursiveCharacterTextSplitter()
  }
  get inputKeys() {
    return [this.inputKey]
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys
  }
  /** @ignore */
  async _call(values, runManager) {
    if (!(this.inputKey in values)) {
      throw new Error(`Document key ${this.inputKey} not found.`)
    }
    const { [this.inputKey]: doc, ...rest } = values
    const currentDoc = doc
    const currentDocs = await this.textSplitter.createDocuments([currentDoc])
    const newInputs = { input_documents: currentDocs, ...rest }
    const result = await this.combineDocumentsChain.call(newInputs, runManager == null ? void 0 : runManager.getChild())
    return result
  }
  _chainType() {
    return "analyze_document_chain"
  }
  static async deserialize(data, values) {
    if (!("text_splitter" in values)) {
      throw new Error(`Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.`)
    }
    const { text_splitter } = values
    if (!data.combine_document_chain) {
      throw new Error(`Need to pass in a combine_document_chain to deserialize AnalyzeDocumentChain.`)
    }
    return new AnalyzeDocumentChain({
      combineDocumentsChain: await BaseChain.deserialize(data.combine_document_chain),
      textSplitter: text_splitter
    })
  }
  serialize() {
    return {
      _type: this._chainType(),
      combine_document_chain: this.combineDocumentsChain.serialize()
    }
  }
}

// node_modules/langchain/dist/chains/index.js
init_vector_db_qa()
init_load()

// node_modules/langchain/dist/chains/summarization/load.js
init_process()
init_buffer()
init_llm_chain()
init_combine_docs_chain()

// node_modules/langchain/dist/chains/summarization/stuff_prompts.js
init_process()
init_buffer()
init_prompt()
var template = `Write a concise summary of the following:


"{text}"


CONCISE SUMMARY:`
var DEFAULT_PROMPT = /* @__PURE__ */ new PromptTemplate({
  template,
  inputVariables: ["text"]
})

// node_modules/langchain/dist/chains/summarization/refine_prompts.js
init_process()
init_buffer()
init_prompt()
var refinePromptTemplate = `Your job is to produce a final summary
We have provided an existing summary up to a certain point: "{existing_answer}"
We have the opportunity to refine the existing summary
(only if needed) with some more context below.
------------
"{text}"
------------

Given the new context, refine the original summary
If the context isn't useful, return the original summary.

REFINED SUMMARY:`
var REFINE_PROMPT = /* @__PURE__ */ new PromptTemplate({
  template: refinePromptTemplate,
  inputVariables: ["existing_answer", "text"]
})

// node_modules/langchain/dist/chains/summarization/load.js
var loadSummarizationChain = (llm, params = { type: "map_reduce" }) => {
  if (params.type === "stuff") {
    const { prompt = DEFAULT_PROMPT } = params
    const llmChain = new LLMChain({ prompt, llm })
    const chain = new StuffDocumentsChain({
      llmChain,
      documentVariableName: "text"
    })
    return chain
  }
  if (params.type === "map_reduce") {
    const { combineMapPrompt = DEFAULT_PROMPT, combinePrompt = DEFAULT_PROMPT } = params
    const llmChain = new LLMChain({ prompt: combineMapPrompt, llm })
    const combineLLMChain = new LLMChain({ prompt: combinePrompt, llm })
    const combineDocumentChain = new StuffDocumentsChain({
      llmChain: combineLLMChain,
      documentVariableName: "text"
    })
    const chain = new MapReduceDocumentsChain({
      llmChain,
      combineDocumentChain,
      documentVariableName: "text"
    })
    return chain
  }
  if (params.type === "refine") {
    const { refinePrompt = REFINE_PROMPT, questionPrompt = DEFAULT_PROMPT } = params
    const llmChain = new LLMChain({ prompt: questionPrompt, llm })
    const refineLLMChain = new LLMChain({ prompt: refinePrompt, llm })
    const chain = new RefineDocumentsChain({
      llmChain,
      refineLLMChain,
      documentVariableName: "text"
    })
    return chain
  }
  throw new Error(`Invalid _type: ${params.type}`)
}

// node_modules/langchain/dist/chains/sql_db/sql_db_chain.js
init_process()
init_buffer()

// node_modules/langchain/dist/chains/sql_db/sql_db_prompt.js
init_process()
init_buffer()
init_prompt()

// node_modules/langchain/dist/chains/sql_db/sql_db_chain.js
init_base5()
init_llm_chain()
init_base_language()
init_count_tokens()

// node_modules/langchain/dist/chains/conversational_retrieval_chain.js
init_process()
init_buffer()
init_prompt()
init_base5()
init_llm_chain()
init_load()

// node_modules/langchain/dist/chains/retrieval_qa.js
init_process()
init_buffer()
init_base5()
init_load()

// src/libs/chains/queryBuilder.ts
var QUERY_BUILDER_DEFAULT_PROMPT = ChatPromptTemplate.fromPromptMessages([
  SystemMessagePromptTemplate.fromTemplate(
    "You are a scholarly researcher that answers in an unbiased, scholarly tone. You sometimes refuse to answer if there is insufficient information."
  ),
  HumanMessagePromptTemplate.fromTemplate(
    `
We want to answer the following question: {question}
Provide a search query that will find papers to help answer the question. Please pay attention to the following requirements:

- The query should be general enough to capture all relevant results. 
- Do not use boolean operators such as "AND", "OR", or "NOT" in the query.
- If explicitly asked by the user, you can use the following metadata fields: "creator", "tag" and "year" as predicates. Do not invent new predicates.
    - creator: should be followed by the name of the author, such as creator:White
    - tag: should be followed by the name of the tag, such as tag:"drug discovery"
    - year: should be followed by the year or a range of years, such as year:2022-2021

Examples:
- machine learning
- chemistry creator:white tag:"machine learning"
- GPT year:2020-2021

Search query:
  `.trim()
  )
])
var loadQueryBuilderChain = (llm, params = {}) => {
  const { prompt = QUERY_BUILDER_DEFAULT_PROMPT, callbackManager } = params
  const chain = new LLMChain({ prompt, llm, callbackManager })
  return chain
}
var loadQueryBuilderChainAsTool = (llm, params = {}) => {
  return new ChainTool({
    name: "zotero-query-builder",
    description: 'Useful for converting a question or a topic into a query for searching the Zotero database via the "zotero-search" tool. The input to this tool should be a string representing a question such as "how to use machine learning for drug discovery?".',
    chain: loadQueryBuilderChain(llm, params)
  })
}

// src/libs/chains/qa.ts
init_process()
init_buffer()
var QA_DEFAULT_PROMPT = ChatPromptTemplate.fromPromptMessages([
  SystemMessagePromptTemplate.fromTemplate(
    "You are a scholarly researcher that answers in an unbiased, scholarly tone. You sometimes refuse to answer if there is insufficient information."
  ),
  HumanMessagePromptTemplate.fromTemplate(
    `
Write an answer for the question below solely based on the provided context. 
If the context provides insufficient information, reply "I cannot answer".

Answer in an unbiased and scholarly tone. Make clear what is your opinion. 
Use Markdown for formatting code or text, and try to use direct quotes to support arguments.

Question: {question}
Answer:
  `.trim()
  )
])
var loadQAChain2 = (llm, params = {}) => {
  const { prompt = QA_DEFAULT_PROMPT } = params
  const chain = new LLMChain({ prompt, llm })
  return chain
}
var loadQAChainAsTool = (llm, params = {}) => {
  return new ChainTool({
    name: "zotero-qa",
    description: 'Useful for answering a question based on the content of references found in the Zotero database via the "zotero-search" tool.',
    chain: loadQAChain2(llm, params)
  })
}

// src/libs/chains/summary.ts
init_process()
init_buffer()
var loadAnalyzeDocumentChainAsTool = (llm) => {
  const combineDocsChain = loadSummarizationChain(llm, { type: "stuff" })
  const chain = new AnalyzeDocumentChain({
    combineDocumentsChain: combineDocsChain
  })
  return new ChainTool({
    name: "zotero-summary",
    description: 'Useful for generating a short summary from a long article the Zotero database. The input should be a LONG string representing the entire content of a single article. The input should not be an item ID such as "568" or multiple articles.',
    chain
  })
}

// src/libs/agents/qa.ts
var PREFIX3 = `Assistant is a large language model trained by OpenAI.
Assistant is designed to be able to assist with a wide range of tasks related to the users of Zotero, a desktop reference management tool, such as finding articles from the Zotero database, summarizing results and answering questions. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topics related to Zotero.
Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of Zotera-related topics.
Assistant is able to access user's Zotero database and can search for items in the database.
Assistant can search Zotero to find the information to answer the user's question. If unable to find relevant information in Zotero, Assistant should politely decline the request and ask the user to try again with a different question. 
Whenever a Zotero item is mentioned in answer, please, please include the item's Zotero ID in the answer, like [ID:1234].
Where appropriate, incorporate bullet points or table as part of your response.
Assistant can use Zotero state information, such as the current items, current collection and current library to scope the answer as directed by the user.
Assistant should politely decline any requests that are unrelated to Zotero reference management, such as: 
- How to cook certain food such as french toast, pizza etc.. 
- Request to prodcue a story, ajoke, a poem, a song or like.
`
var FORMAT_INSTRUCTIONS4 = `RESPONSE FORMAT INSTRUCTIONS
----------------------------
When responding to me please, please output a response in one of two formats:
**Option 1:**
Use this if you want the human to use a tool.
Markdown code snippet formatted in the following schema:
\`\`\`json
{{{{
    "action": string \\ The action to take. Must be one of {tool_names}
    "action_input": string \\ The input to the action
}}}}
\`\`\`
**Option #2:**
Use this if you want to respond directly to the human. Markdown code snippet formatted in the following schema:
\`\`\`json
{{{{
    "action": "Final Answer",
    "action_input": string \\ You should put what you want to return to use here
}}}}
\`\`\``
var SUFFIX3 = `TOOLS
------
Assistant can ask the user to use tools to look up information that may be helpful in answering the users original question. The tools the human can use are:
{{tools}}
{format_instructions}
Please, please ALWAYS adhere to the response format instructions above. If you do not, I will not be able to understand your response and will not be able to learn from it.
APPLICATION STATES
--------------------
The following Zotero application states are relevant to user questions. Do NOT rely on chat history as application state changes constantly.
- Current Items: {{{{current_items}}}}
- Current Collection: {{{{current_collection}}}}
USER'S INPUT
--------------------
Here is the user's input (remember to respond with a markdown code snippet of a json blob with a single action, and NOTHING else):
{{{{input}}}}`
var QAAgentOutputParser = class extends AgentActionOutputParser {
  async parse(text) {
    let jsonOutput = text.trim()
    console.log("jsonOutput", jsonOutput)
    if (jsonOutput.includes("```json")) {
      jsonOutput = jsonOutput.split("```json")[1].trimStart()
    }
    if (jsonOutput.includes("```")) {
      jsonOutput = jsonOutput.split("```")[0].trimEnd()
    }
    if (jsonOutput.startsWith("```")) {
      jsonOutput = jsonOutput.slice(3).trimStart()
    }
    if (jsonOutput.endsWith("```")) {
      jsonOutput = jsonOutput.slice(0, -3).trimEnd()
    }
    try {
      const response = JSON.parse(jsonOutput)
      let { action, action_input } = response
      if (typeof action_input === "object") {
        action_input = JSON.stringify(action_input)
      }
      if (action === "Final Answer") {
        return { returnValues: { output: action_input }, log: text }
      }
      return { tool: action, toolInput: action_input, log: text }
    } catch (error2) {
      return { returnValues: { output: text }, log: text }
    }
  }
  getFormatInstructions() {
    return FORMAT_INSTRUCTIONS4
  }
}
var createPromptArgs = {
  systemMessage: PREFIX3,
  humanMessage: SUFFIX3,
  outputParser: new QAAgentOutputParser()
}
async function createQAExecutor({ callbackManager }) {
  const OPENAI_API_KEY = Zotero.Prefs.get(`${config2.addonRef}.OPENAI_API_KEY`)
  const title3 = "QA Assistant"
  const description = `
  QA Assistant analyzes and understands the content of your Zotero library. It can help streamline your research process by performing automatic literature search, summarization, and question & answer.
  `
  const chatModel = new ChatOpenAI({
    temperature: 0,
    openAIApiKey: OPENAI_API_KEY,
    modelName: "gpt-3.5-turbo"
  })
  const zoteroQueryBuilderTool = loadQueryBuilderChainAsTool(chatModel)
  const zoteroQATool = loadQAChainAsTool(chatModel)
  const zoteroItemTool = new ZoteroItem()
  const zoteroCollectionTool = new ZoteroCollection()
  const zoteroSummaryTool = loadAnalyzeDocumentChainAsTool(chatModel)
  const zoteroSearchTool = new ZoteroSearch()
  const zoteroCreatorsTool = new ZoteroCreators()
  const tools = [
    zoteroQueryBuilderTool,
    zoteroSearchTool,
    zoteroQATool,
    zoteroItemTool,
    zoteroCollectionTool,
    zoteroSummaryTool,
    zoteroCreatorsTool
  ]
  const executor = AgentExecutor.fromAgentAndTools({
    agent: ChatConversationalAgent.fromLLMAndTools(chatModel, tools, createPromptArgs),
    tools,
    verbose: true,
    callbackManager,
    maxIterations: 6
  })
  executor.agent.llmChain.prompt.partialVariables = {
    current_items: () => {
      const items = ZoteroPane.getSelectedItems()
      if (items.length > 0) {
        return items.map((x) => `${x.name} (ID: "${x.id}")`).join(", ")
      }
      return "No selected items"
    },
    current_collection: () => {
      const collection = ZoteroPane.getSelectedCollection()
      if (collection) {
        return `${collection.name} (ID: "${collection.id}")`
      }
      return "None"
    }
  }
  executor.memory = new BufferWindowMemory({
    returnMessages: true,
    memoryKey: "chat_history",
    inputKey: "input",
    k: 5
  })
  return { executor, metadata: { title: title3, description } }
}

// node_modules/langchain/callbacks.js
init_process()
init_buffer()

// node_modules/langchain/dist/callbacks/index.js
init_process()
init_buffer()
init_base2()
init_tracers()
init_initialize()
init_manager()
init_console()

// src/modules/components/icons.ts
init_process()
init_buffer()
var CopyIcon = `
<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"
  xmlns="http://www.w3.org/2000/svg">
  <path
    d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path>
  <path
    d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
</svg>
`

// src/modules/views/chat.ts
var Chat = class {
  /**
   * Initialize `Prompt` but do not create UI.
   */
  constructor() {
    /**
     * Record the last text entered
     */
    this.lastInputText = ""
    /**
     * Default text
     */
    this.defaultText = {
      placeholder: "How can I help you today?"
    }
    /**
     * It controls the max line number of commands displayed in `commandsNode`.
     */
    this.maxLineNum = 12
    /**
     * Save all commands registered by all addons.
     */
    this.commands = []
    this.base = new import_basic.BasicTool()
    this.ui = new import_ui.UITool()
    this.document = this.base.getGlobal("document")
    this.OPENAI_API_KEY = Zotero.Prefs.get(`${config2.addonRef}.OPENAI_API_KEY`)
    this.initializeUI()
    if (this.OPENAI_API_KEY !== "") {
      Zotero.HTTP.request("POST", "https://api.openai.com/v1/chat/completions", {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: "gpt-3.5-turbo",
          messages: [{ role: "user", content: "Say this is a test!" }],
          temperature: 0.7
        })
      }).then(() => {
        const callbackManager = CallbackManager.fromHandlers({
          handleAgentAction: async (action) => {
            this.addActionOutput(action)
          }
        })
        createQAExecutor({ callbackManager }).then(this.initConversation.bind(this)).catch(console.error)
      }).catch((error2) => {
        try {
          const message = JSON.parse(error2.xmlhttp.response).error.message
          this.initError(message)
        } catch (error3) {
          console.log({ unknownOpenAIApiError: error3 })
          this.initError("Unknown error. Please contact support.")
        }
      })
    } else {
      this.initConfiguration()
    }
  }
  addActionOutput(action) {
    if (action.tool) {
      const actionNode = this.ui.createElement(this.document, "div", {
        styles: {
          fontWeight: "bold",
          padding: "0 12px 24px"
        },
        properties: {
          innerText: `\u{1F6E0}\uFE0F ${action.tool}`
        },
        children: [
          {
            tag: "span",
            styles: {
              fontWeight: "normal",
              fontSize: "12px"
            },
            properties: {
              innerText: action.toolInput && typeof action.toolInput === "string" ? ` (input: ${action.toolInput.length > 64 ? action.toolInput.slice(0, 64) + "..." : action.toolInput || "missing"})` : ""
            }
          }
        ]
      })
      this.conversationNode.appendChild(actionNode)
      this.conversationNode.scrollTo(0, this.conversationNode.scrollHeight)
    }
    console.log({ displayAction: action })
  }
  initConfiguration() {
    const missingApiKeyNode = this.ui.createElement(this.document, "div", {
      styles: {
        color: "black",
        background: "RGBA(255, 234, 0, 0.5)",
        padding: "24px",
        width: "75%",
        minWidth: "560px",
        textAlign: "left",
        position: "fixed",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)",
        border: "1px solid RGBA(215,200,50,1)",
        borderRadius: "18px"
      },
      children: [
        {
          tag: "div",
          styles: {
            fontSize: "18px",
            fontWeight: "bold",
            marginBottom: "18px"
          },
          properties: {
            innerText: "OpenAI API key is required to use Aria."
          }
        },
        {
          tag: "div",
          styles: {
            fontSize: "14px"
          },
          properties: {
            innerHTML: `
              <ul>
                <li>Select <em>Edit</em> from the top menu bar, then select <em>Preferences</em> from the drop-down menu.</li>
                <li>On the top panel or the left-hand side panel, select <em>Aria</em>.</li>
                <li>Locate the <em>OpenAI API key</em> field and enter your API key in the text box.</li>
                <li>Click the "Close" button to save your change and <b>restart Zotero</b>.</li>
              </ul>
            `
          }
        }
      ]
    })
    this.conversationNode.childNodes.forEach((child) => child.remove())
    this.conversationNode.appendChild(missingApiKeyNode)
  }
  initError(message) {
    const missingApiKeyNode = this.ui.createElement(this.document, "div", {
      styles: {
        color: "black",
        background: "RGBA(255, 187, 129, 0.5)",
        padding: "24px",
        width: "75%",
        minWidth: "560px",
        textAlign: "left",
        position: "fixed",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)",
        border: "1px solid RGBA(255, 172, 120, 1)",
        borderRadius: "18px"
      },
      children: [
        {
          tag: "div",
          styles: {
            fontSize: "18px",
            fontWeight: "bold",
            marginBottom: "18px"
          },
          properties: {
            innerText: "Error in connecting to OpenAI API."
          }
        },
        {
          tag: "div",
          styles: {
            fontSize: "14px"
          },
          properties: {
            innerText: message
          }
        }
      ]
    })
    this.conversationNode.childNodes.forEach((child) => child.remove())
    this.conversationNode.appendChild(missingApiKeyNode)
  }
  initConversation({ executor, metadata: { title: title3, description } }) {
    this.executor = executor
    const introductionNode = this.ui.createElement(this.document, "div", {
      id: "aria-chat-introduction",
      styles: {
        display: "flex",
        flexDirection: "row",
        color: "#666"
      },
      children: [
        {
          tag: "div",
          styles: {
            width: "15%",
            marginRight: "24px"
          },
          children: [
            {
              tag: "img",
              styles: {
                maxWidth: "100%"
              },
              properties: {
                src: `chrome://${config2.addonRef}/content/icons/favicon@4x.png`,
                alt: "Aria"
              }
            }
          ]
        },
        {
          tag: "div",
          children: [
            {
              tag: "h2",
              styles: {
                margin: "12px 0 0",
                padding: "0",
                fontSize: "28px"
              },
              properties: {
                innerText: "A.R.I.A. (Aria)"
              }
            },
            {
              tag: "div",
              styles: {
                margin: "0",
                padding: "0",
                fontSize: "14px"
              },
              properties: {
                innerText: "Your AI Research Assistant"
              }
            },
            {
              tag: "div",
              properties: {
                innerHTML: marked(description)
              }
            }
          ]
        }
      ]
    })
    this.conversationNode.childNodes.forEach((child) => child.remove())
    this.conversationNode.appendChild(introductionNode)
  }
  /**
   * Initialize `Prompt` UI and then bind events on it.
   */
  initializeUI() {
    this.addStyle()
    this.createHTML()
    this.initInputEvents()
    this.registerShortcut()
  }
  createHTML() {
    const existingChatNode = this.document.getElementById("chat-node")
    existingChatNode == null ? void 0 : existingChatNode.remove()
    this.chatNode = this.ui.createElement(this.document, "div", {
      id: "chat-node",
      styles: {
        display: "none"
      },
      children: [
        {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0",
            top: "0",
            backgroundColor: "rgba(220, 220, 220, 0.4)",
            width: "100%",
            height: "100%",
            opacity: "0.5"
          },
          listeners: [
            {
              type: "click",
              listener: () => {
                this.chatNode.style.display = "none"
              }
            }
          ]
        }
      ]
    })
    this.chatNode.appendChild(
      this.ui.createElement(this.document, "div", {
        id: `aria-chat`,
        classList: ["chat-container"],
        children: [
          {
            tag: "div",
            id: "chat-conversation"
          },
          {
            tag: "div",
            classList: ["chat-input"],
            children: [
              {
                id: "input",
                tag: "textarea",
                attributes: {
                  placeholder: this.defaultText.placeholder
                }
              },
              {
                id: "loading",
                tag: "div",
                children: [
                  {
                    tag: "div",
                    classList: ["dot-flashing"]
                  }
                ]
              }
            ]
          },
          {
            tag: "div",
            classList: ["chat-instructions"],
            children: [
              {
                tag: "div",
                classList: ["instruction"],
                children: [
                  {
                    tag: "span",
                    properties: {
                      innerText: `${config2.addonName} (${version2})`
                    }
                  }
                ]
              },
              {
                tag: "div",
                classList: ["instruction"],
                children: [
                  {
                    tag: "span",
                    properties: {
                      innerText: "Model: GPT-Turbo-3.5"
                    }
                  }
                ]
              }
            ]
          }
        ]
      })
    )
    this.inputNode = this.chatNode.querySelector("#input")
    this.conversationNode = this.chatNode.querySelector("#chat-conversation")
    this.document.documentElement.appendChild(this.chatNode)
    this.loadingNode = this.chatNode.querySelector("#loading")
    this.loadingNode.style.visibility = "hidden"
  }
  /**
   * Show commands in a new `commandsContainer`
   * All other `commandsContainer` is hidden
   * @param commands Command[]
   * @param clear remove all `commandsContainer` if true
   */
  // public showCommands(commands: any[], clear: boolean = false) {
  //   if (clear) {
  //     this.chatNode.querySelectorAll('.message').forEach((e: any) => e.remove())
  //   }
  //   this.inputNode.placeholder = this.defaultText.placeholder
  //   const commandsContainer = this.createCommandsContainer()
  //   for (let command of commands) {
  //     if (command.when && !command.when()) {
  //       continue
  //     }
  //     commandsContainer.appendChild(this.createCommandNode(command))
  //   }
  // }
  /**
   * Create a `commandsContainer` div element, append to `commandsContainer` and hide others.
   * @returns commandsNode
   */
  createCommandsContainer() {
    const commandsContainer = this.ui.createElement(this.document, "div", {
      classList: ["message"]
    })
    this.chatNode.querySelector(".conversation").appendChild(commandsContainer)
    return commandsContainer
  }
  /**
   * Return current displayed `commandsContainer`
   * @returns
   */
  getConversationContainer() {
    return [...this.chatNode.querySelectorAll(".message")].find((e) => {
      return e.style.display != "none"
    })
  }
  addUserInput(input) {
    const message = input.message.replace(/\n/g, "<br/>")
    const inputNode = this.ui.createElement(this.document, "div", {
      classList: ["chat-message", "chat-message-user"],
      // properties: {
      //   innerHTML: input.message.replace(/\n/g, '<br/>'),
      // },
      children: [
        {
          tag: "div",
          classList: ["hover-container"],
          children: [
            {
              tag: "button",
              classList: ["copy-button"],
              styles: {
                background: "none",
                border: "none",
                cursor: "pointer"
              },
              listeners: [
                {
                  type: "click",
                  listener: () => {
                    new ztoolkit.Clipboard().addText(message, "text/unicode").copy()
                  }
                }
              ],
              children: [
                {
                  tag: "div",
                  classList: ["copy-icon"],
                  properties: {
                    innerHTML: CopyIcon
                  }
                }
              ]
            }
          ]
        },
        {
          tag: "div",
          classList: ["markdown"],
          properties: {
            innerHTML: message
          }
        }
      ]
    })
    this.conversationNode.appendChild(inputNode)
    this.conversationNode.scrollTo(0, this.conversationNode.scrollHeight)
  }
  addBotOutput({ message }) {
    if (message === "Agent stopped due to max iterations.") {
      message = "Sorry. I can't answer this question because I've reached the maximum number of attempts."
    }
    const htmlMessage = marked(message)
    const outputNode = this.ui.createElement(this.document, "div", {
      classList: ["chat-message", "chat-message-bot"],
      children: [
        {
          tag: "div",
          classList: ["hover-container"],
          children: [
            {
              tag: "button",
              classList: ["copy-button"],
              styles: {
                background: "none",
                border: "none",
                cursor: "pointer"
              },
              listeners: [
                {
                  type: "click",
                  listener: () => {
                    new ztoolkit.Clipboard().addText(message, "text/unicode").addText(htmlMessage, "text/html").copy()
                  }
                }
              ],
              children: [
                {
                  tag: "div",
                  classList: ["copy-icon"],
                  properties: {
                    innerHTML: CopyIcon
                  }
                }
              ]
            }
          ]
        },
        {
          tag: "div",
          classList: ["markdown"],
          properties: {
            innerHTML: htmlMessage
          }
        }
      ]
    })
    this.conversationNode.appendChild(outputNode)
    this.conversationNode.scrollTo(0, this.conversationNode.scrollHeight)
  }
  setLoading(isLoading = false) {
    this.loadingNode.style.visibility = isLoading ? "visible" : "hidden"
  }
  /**
   * Create a command item for `Prompt` UI.
   * @param command
   * @returns
   */
  // public createCommandNode(command: any): HTMLElement {
  //   const commandNode = this.ui.createElement(this.document, 'div', {
  //     classList: ['command'],
  //     children: [
  //       {
  //         tag: 'div',
  //         classList: ['content'],
  //         children: [
  //           {
  //             tag: 'div',
  //             classList: ['name'],
  //             children: [
  //               {
  //                 tag: 'span',
  //                 properties: {
  //                   innerText: command.name,
  //                 },
  //               },
  //             ],
  //           },
  //           {
  //             tag: 'div',
  //             classList: ['aux'],
  //             children: command.label
  //               ? [
  //                   {
  //                     tag: 'span',
  //                     classList: ['label'],
  //                     properties: {
  //                       innerText: command.label,
  //                     },
  //                   },
  //                 ]
  //               : [],
  //           },
  //         ],
  //       },
  //     ],
  //     listeners: [
  //       {
  //         type: 'mousemove',
  //         listener: () => {
  //           this.selectItem(commandNode)
  //         },
  //       },
  //       {
  //         type: 'click',
  //         listener: async () => {
  //           if (Array.isArray(command.callback)) {
  //             this.showCommands(command.callback)
  //           } else {
  //             await command.callback(this)
  //           }
  //         },
  //       },
  //     ],
  //   })
  //   return commandNode
  // }
  /**
   * Called when `enter` key is pressed.
   */
  async trigger(input) {
    if (input.trim() === "") {
      return
    }
    const userInput = {
      role: "user",
      message: input.trim()
    }
    this.addUserInput(userInput)
    this.inputNode.value = ""
    this.inputNode.style.height = "20px"
    try {
      this.setLoading(true)
      const result = await this.executor.call({ input })
      const botOutput = {
        role: "bot",
        message: result.output
      }
      this.addBotOutput(botOutput)
      this.setLoading(false)
    } catch (error2) {
      const errorObj = serializeError(error2)
      console.log({ executorError: error2, errorObj })
      if (errorObj.message && errorObj.message.startsWith("Unable to parse JSON response from chat agent.")) {
        const botOutput = {
          role: "bot",
          message: errorObj.message.replace("Unable to parse JSON response from chat agent.", "").trim()
        }
        this.addBotOutput(botOutput)
      } else {
        const errorBotOutput = {
          role: "bot",
          message: `Sorry. An error occurred. Please try something else.
          <pre class='error'>${JSON.stringify(serializeError(error2))}</pre>`
        }
        this.addBotOutput(errorBotOutput)
      }
      this.setLoading(false)
    }
  }
  /**
   * Called when `escape` key is pressed.
   */
  exit() {
    this.inputNode.placeholder = this.defaultText.placeholder
    if (this.chatNode.querySelectorAll(".conversation .message").length >= 2) {
      ;
      this.chatNode.querySelector(".message:last-child").remove()
      const commandsContainer = this.chatNode.querySelector(".message:last-child")
      commandsContainer.style.display = ""
      commandsContainer.querySelectorAll(".commands").forEach((e) => e.style.display = "flex")
      this.inputNode.focus()
    } else {
      this.chatNode.style.display = "none"
    }
  }
  /**
   * Bind events of pressing `keydown` and `keyup` key.
   */
  initInputEvents() {
    this.chatNode.addEventListener("keyup", async (event) => {
      if (event.key == "Enter" && !event.shiftKey) {
        await this.trigger(this.inputNode.value)
      } else if (event.key == "Escape") {
        if (this.inputNode.value.length > 0) {
          this.inputNode.value = ""
          return
        }
        this.exit()
      } else {
        this.inputNode.style.height = this.inputNode.scrollHeight + "px"
      }
      if (this.inputNode.value == this.lastInputText) {
        return
      }
    })
  }
  /**
   * Create a commandsContainer and display a text
   */
  showTip(text) {
    const tipNode = this.ui.createElement(this.document, "div", {
      classList: ["tip"],
      properties: {
        innerText: text
      }
    })
    this.createCommandsContainer().appendChild(tipNode)
    return tipNode
  }
  /**
   * Mark the selected item with class `selected`.
   * @param item HTMLDivElement
   */
  selectItem(item) {
    this.getConversationContainer().querySelectorAll(".command").forEach((e) => e.classList.remove("selected"))
    item.classList.add("selected")
  }
  addStyle() {
    const style = this.ui.createElement(this.document, "style", {
      id: "chat-style"
    })
    style.innerText = `
      .chat-container * {
        box-sizing: border-box;
      }
      .chat-container {
        overflow: hidden;
        padding: 9px 18px;
        position: fixed;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60%;
        top: 50%;
        height: 80%;
        min-width: 720px;
        border-radius: 10px;
        border: 1px solid #bdbdbd;
        justify-content: center;
        align-items: center;
        /* https://cssgradient.io/ */
        background: rgb(255,246,246);
        background: linear-gradient(170deg, rgba(255,246,246,1) 0%, rgba(230,240,255,1) 100%);
        font-size: 16px;
        box-shadow: 0px 1.8px 7.3px rgba(0, 0, 0, 0.071),
                    0px 6.3px 24.7px rgba(0, 0, 0, 0.112),
                    0px 30px 90px rgba(0, 0, 0, 0.2);
        font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
      }
      
      /* input */
      .chat-container .chat-input  {
        position: fixed;
        bottom: 30px;
        width: calc(100% - 36px);
        padding: 9px 12px;
        border-radius: 4px;
        border-width: 1px;
        border-color: rgba(0,0,0,0.1);
        background: white;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        z-index: 100;
      }
      
      .chat-input textarea#input {
        width: 100%;
        height: 20px;
        max-height: 200px;
        padding: 0;
        background-color: transparent;
        resize: none;
        border-width: 0;
        font-size: 16px;
        overflow-y: auto;
        color: black;
      }

      .chat-input #loading {
        position: absolute;
        right: 24px;
        bottom: 15px;
      }

      .chat-input #loading .dot-flashing {
        position: relative;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite linear alternate;
        animation-delay: 0.5s;
      }
      .chat-input #loading .dot-flashing::before, 
      .chat-input #loading .dot-flashing::after {
        content: "";
        display: inline-block;
        position: absolute;
        top: 0;
      }
      .chat-input #loading .dot-flashing::before {
        left: -15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite alternate;
        animation-delay: 0s;
      }
      .chat-input #loading .dot-flashing::after {
        left: 15px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background-color: #9880ff;
        color: #9880ff;
        animation: dot-flashing 1s infinite alternate;
        animation-delay: 1s;
      }

      @keyframes dot-flashing {
        0% {
          background-color: #9880ff;
        }
        50%, 100% {
          background-color: rgba(152, 128, 255, 0.2);
        }
      }
      
      /* results */
      #chat-conversation {
        width: 100%;
        height: calc(100% - 75px);
        mask-image: linear-gradient(to left, rgba(0,0,0,1), rgba(0,0,0,0)), linear-gradient(to right, rgba(0,0,0,1), rgba(0,0,0,0));
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;

        mask-image: linear-gradient(180deg, rgba(0,0,0,1), rgba(0,0,0,1) 98%, transparent)
      }
      #chat-conversation .chat-message {
        border-radius: 12px;
        margin-bottom: 18px;
        overflow-wrap: break-word;
        position: relative;
      }

      #chat-conversation .chat-message.chat-message-user {
        padding: 6px 12px;
        background: RGB(204, 41, 54, 1);
        color: white;
        width: auto;
        align-self: flex-end;
        max-width: 70%;
        border-width: 1px;
        box-shadow: 0 0 6px rgba(0,0,0,0.1);
      }

      #chat-conversation .chat-message.chat-message-bot {
        padding: 0 4px;
        background: RGBA(255, 255, 255, 1);
        width: auto;
        align-self: flex-start;
        max-width: 70%;
        border-color: RGBA(0, 0, 0, 0.5);
        border-width: 1px;
        border-color: rgba(0,0,0,0.1);
        box-shadow: 0 0 6px rgba(0,0,0,0.1);
        background: white;
        color: black;
      }

      #chat-conversation .chat-message.chat-message-bot .markdown * {
        margin: 8px;
      }

      #chat-conversation .chat-message.chat-message-bot .hover-container,
      #chat-conversation .chat-message.chat-message-user .hover-container  {
        visibility: hidden;
        position: absolute;
      }

      #chat-conversation .chat-message.chat-message-bot .hover-container {
        top: 9px;
        right: -30px;
      }

      #chat-conversation .chat-message.chat-message-user .hover-container {
        top: 8px;
        left: -30px;
      }

      #chat-conversation .chat-message.chat-message-bot:hover .hover-container,
      #chat-conversation .chat-message.chat-message-user:hover .hover-container  {
        visibility: visible;
      }

      

      #chat-conversation .chat-message.chat-message-bot .error {
        white-space: pre-wrap;
        background-color: #f3f3f3;
        color: #666;
        font-size: 12px;
      }

      #chat-conversation .chat-message.chat-message-bot .markdown {
        overflow: hidden;
      }

      #chat-conversation .chat-message.chat-message-bot .markdown table {
        width: 100%;
        table-layout: auto;
        text-align: left;
        margin-top: 2em;
        margin-bottom: 2em;
        font-size: 0.875em;
        line-height: 1.7142857;
      }

      #chat-conversation .chat-message.chat-message-bot .markdown thead {
        color: #1a202c;
        font-weight: 600;
        border-bottom: 1px solid RGB(0, 0, 0, 0.5);
      }

      #chat-conversation .chat-message.chat-message-bot .markdown thead th{
            vertical-align: bottom;
            padding-right: 0.5714286em;
            padding-bottom: 0.5714286em;
            padding-left: 0.5714286em;
      }

      .message {
        max-height: calc(${this.maxLineNum} * 35.5px);
        width: calc(100% - 12px);
        margin-left: 12px;
        margin-right: 0%;
        overflow-y: auto;
        overflow-x: hidden;
      }
      
      .message .command {
        display: flex;
        align-content: baseline;
        justify-content: space-between;
        border-radius: 5px;
        padding: 6px 12px;
        margin-right: 12px;
        margin-top: 2px;
        margin-bottom: 2px;
      }
      .message .command .content {
        display: flex;
        width: 100%;
        justify-content: space-between;
        flex-direction: row;
        overflow: hidden;
      }
      .message .command .content .name {
        white-space: nowrap; 
        text-overflow: ellipsis;
        overflow: hidden;
      }
      .message .command .content .aux {
        display: flex;
        align-items: center;
        align-self: center;
        flex-shrink: 0;
      }
      
      .message .command .content .aux .label {
        font-size: 15px;
        color: #5a5a5a;
        padding: 2px 6px;
        background-color: #fafafa;
        border-radius: 5px;
      }
      
      .message .selected {
          background-color: rgba(0, 0, 0, 0.075);
      }
      .message .highlight {
        font-weight: bold;
      }
      .tip {
        color: #5a5a5a;
        text-align: center;
        padding: 12px 12px;
        font-size: 18px;
      }
      
      .current-value {
        background-color: #a7b8c1;
        color: white;
        border-radius: 5px;
        padding: 0 5px;
        margin-left: 10px;
        font-size: 14px;
        vertical-align: middle;
        letter-spacing: 0.05em;
      }
      /* instructions */
      .chat-instructions {
        display: flex;
        align-content: center;
        justify-content: center;
        color: rgba(0, 0, 0, 0.4);
        height: 2em;
        width: 100%;
        margin-top: 5px;
        position: fixed;
        bottom: 0;
      }
      
      .chat-instructions .instruction {
        margin: auto .5em;  
        font-size: 12px;
      }
      
      .chat-instructions .key {
        margin-right: .2em;
        font-weight: 600;
      }
    `
    this.document.documentElement.appendChild(style)
  }
  registerShortcut() {
    const shortCut = new import_shortcut.ShortcutManager()
    shortCut.register("event", {
      id: "aria-chat-key",
      modifiers: "shift",
      key: "r",
      callback: () => {
        if (this.chatNode.style.display == "none") {
          this.chatNode.style.display = "flex"
          this.inputNode.focus()
        }
      }
    })
  }
}
async function chat() {
  const dialogData = {
    inputValue: "test",
    checkboxValue: true,
    loadCallback: () => {
      ztoolkit.log(dialogData, "Dialog Opened!")
    },
    unloadCallback: () => {
      ztoolkit.log(dialogData, "Dialog closed!")
    }
  }
  const dialogHelper = new ztoolkit.Dialog(10, 2).addCell(0, 0, {
    tag: "h1",
    properties: { innerHTML: "Chat Window" }
  }).addCell(1, 0, {
    tag: "h2",
    properties: { innerHTML: "Conversational AI" }
  }).addCell(2, 0, {
    tag: "p",
    properties: {
      innerHTML: "Elements with attribute 'data-bind' are binded to the prop under 'dialogData' with the same name."
    },
    styles: {
      width: "200px"
    }
  }).addCell(3, 0, {
    tag: "label",
    namespace: "html",
    attributes: {
      for: "dialog-checkbox"
    },
    properties: { innerHTML: "bind:checkbox" }
  }).addCell(
    3,
    1,
    {
      tag: "input",
      namespace: "html",
      id: "dialog-checkbox",
      attributes: {
        "data-bind": "checkboxValue",
        "data-prop": "checked",
        type: "checkbox"
      },
      properties: { label: "Cell 1,0" }
    },
    false
  ).addCell(4, 0, {
    tag: "label",
    namespace: "html",
    attributes: {
      for: "dialog-input"
    },
    properties: { innerHTML: "bind:input" }
  }).addCell(
    4,
    1,
    {
      tag: "input",
      namespace: "html",
      id: "dialog-input",
      attributes: {
        "data-bind": "inputValue",
        "data-prop": "value",
        type: "text"
      }
    },
    false
  ).addCell(5, 0, {
    tag: "h2",
    properties: { innerHTML: "Toolkit Helper Examples" }
  }).addCell(
    6,
    0,
    {
      tag: "button",
      namespace: "html",
      attributes: {
        type: "button"
      },
      listeners: [
        {
          type: "click",
          listener: (e) => {
            addon.hooks.onDialogEvents("clipboardExample")
          }
        }
      ],
      children: [
        {
          tag: "div",
          styles: {
            padding: "2.5px 15px"
          },
          properties: {
            innerHTML: "example:clipboard"
          }
        }
      ]
    },
    false
  ).addCell(
    7,
    0,
    {
      tag: "button",
      namespace: "html",
      attributes: {
        type: "button"
      },
      listeners: [
        {
          type: "click",
          listener: (e) => {
            addon.hooks.onDialogEvents("filePickerExample")
          }
        }
      ],
      children: [
        {
          tag: "div",
          styles: {
            padding: "2.5px 15px"
          },
          properties: {
            innerHTML: "example:filepicker"
          }
        }
      ]
    },
    false
  ).addCell(
    8,
    0,
    {
      tag: "button",
      namespace: "html",
      attributes: {
        type: "button"
      },
      listeners: [
        {
          type: "click",
          listener: (e) => {
            addon.hooks.onDialogEvents("progressWindowExample")
          }
        }
      ],
      children: [
        {
          tag: "div",
          styles: {
            padding: "2.5px 15px"
          },
          properties: {
            innerHTML: "example:progressWindow"
          }
        }
      ]
    },
    false
  ).addCell(
    9,
    0,
    {
      tag: "button",
      namespace: "html",
      attributes: {
        type: "button"
      },
      listeners: [
        {
          type: "click",
          listener: (e) => {
            addon.hooks.onDialogEvents("vtableExample")
          }
        }
      ],
      children: [
        {
          tag: "div",
          styles: {
            padding: "2.5px 15px"
          },
          properties: {
            innerHTML: "example:virtualized-table"
          }
        }
      ]
    },
    false
  ).addButton("Confirm", "confirm").addButton("Cancel", "cancel").addButton("Help", "help", {
    noClose: true,
    callback: (e) => {
      var _a;
      (_a = dialogHelper.window) == null ? void 0 : _a.alert("Help Clicked! Dialog will not be closed.")
    }
  }).setDialogData(dialogData).open("Dialog Example")
  await dialogData.unloadLock.promise
  ztoolkit.getGlobal("alert")(
    `Close dialog with ${dialogData._lastButtonId}.
Checkbox: ${dialogData.checkboxValue}
Input: ${dialogData.inputValue}.`
  )
  ztoolkit.log(dialogData)
}
var ChatManager = class extends import_basic2.ManagerTool {
  /**
   * Save the commands registered from this manager
   */
  constructor(base2) {
    super(base2)
    this.chat = new Chat()
  }
  /**
   * Register commands. Don't forget to call `unregister` on plugin exit.
   * @param commands Command[]
   * @example
   * ```ts
   * let getReader = () => {
   *   return BasicTool.getZotero().Reader.getByTabID(
   *     (Zotero.getMainWindow().Zotero_Tabs).selectedID
   *   )
   * }
   *
   * register([
   *   {
   *     name: "Split Horizontally",
   *     label: "Zotero",
   *     when: () => getReader() as boolean,
   *     callback: (prompt: Prompt) => getReader().menuCmd("splitHorizontally")
   *   },
   *   {
   *     name: "Split Vertically",
   *     label: "Zotero",
   *     when: () => getReader() as boolean,
   *     callback: (prompt: Prompt) => getReader().menuCmd("splitVertically")
   *   }
   * ])
   * ```
   */
  register(commands) {
  }
  /**
   * You can delete a command registed before by its name.
   * @remarks
   * There is a premise here that the names of all commands registered by a single plugin are not duplicated.
   * @param name Command.name
   */
  unregister(name) {
  }
  /**
   * Call `unregisterAll` on plugin exit.
   */
  unregisterAll() {
  }
}

// src/modules/preferences.ts
init_process()
init_buffer()
function registerPrefsWindow() {
  const prefOptions = {
    pluginID: config2.addonID,
    src: rootURI + "chrome/content/preferences.xhtml",
    label: getString("prefs.title"),
    image: `chrome://${config2.addonRef}/content/icons/favicon.png`,
    extraDTD: [`chrome://${config2.addonRef}/locale/overlay.dtd`],
    defaultXUL: true
  }
  ztoolkit.PreferencePane.register(prefOptions)
}
function registerPrefsScripts(_window) {
  if (!addon.data.prefs) {
    addon.data.prefs = {
      window: _window,
      columns: [
        {
          dataKey: "title",
          label: "prefs.table.title",
          fixedWidth: true,
          width: 100
        },
        {
          dataKey: "detail",
          label: "prefs.table.detail"
        }
      ],
      rows: [
        {
          title: "Orange",
          detail: "It's juicy"
        },
        {
          title: "Banana",
          detail: "It's sweet"
        },
        {
          title: "Apple",
          detail: "I mean the fruit APPLE"
        }
      ]
    }
  } else {
    addon.data.prefs.window = _window
  }
  updatePrefsUI()
  bindPrefEvents()
}
async function updatePrefsUI() {
  const renderLock = ztoolkit.getGlobal("Zotero").Promise.defer()
  await renderLock.promise
  ztoolkit.log("Preference table rendered!")
}
function bindPrefEvents() {
  var _a;
  (_a = addon.data.prefs.window.document.querySelector(`#zotero-prefpane-${config2.addonRef}-OPENAI_API_KEY`)) == null ? void 0 : _a.addEventListener("change", (e) => {
    addon.data.prefs.window.alert(`Please restart Zotero for your new OPENAI API Key to take effect.`)
  })
}

// src/hooks.ts
async function onStartup() {
  await Promise.all([Zotero.initializationPromise, Zotero.unlockPromise, Zotero.uiReadyPromise])
  initLocale()
  ztoolkit.ProgressWindow.setIconURI("default", `chrome://${config2.addonRef}/content/icons/favicon.png`)
  registerPrefsWindow()
  await Zotero.Promise.delay(1e3)
  const popupWin = new ztoolkit.ProgressWindow(config2.addonName, {
    closeOnClick: true,
    closeTime: -1
  }).createLine({
    text: getString("startup.begin"),
    type: "default",
    progress: 0
  }).show()
  popupWin.changeLine({
    progress: 100,
    text: `[100%] ${getString("startup.finish")}`
  })
  popupWin.startCloseTimer(5e3)
}
function onShutdown() {
  ztoolkit.unregisterAll()
  addon.data.alive = false
  delete Zotero[config2.addonInstance]
}
async function onNotify(event, type2, ids, extraData) {
  ztoolkit.log("notify", event, type2, ids, extraData)
}
async function onPrefsEvent(type2, data) {
  switch (type2) {
    case "load":
      registerPrefsScripts(data.window)
      break
    default:
      return
  }
}
function onShortcuts(type2) {
  switch (type2) {
    default:
      break
  }
}
function onDialogEvents(type2) {
  switch (type2) {
    case "dialogExample":
      chat()
      break
    default:
      break
  }
}
var hooks_default = {
  onStartup,
  onShutdown,
  onNotify,
  onPrefsEvent,
  onShortcuts,
  onDialogEvents
}

// src/addon.ts
var import_basic3 = __toESM(require_basic())
var import_ui2 = __toESM(require_ui())
var import_preferencePane = __toESM(require_preferencePane())
var import_prompt28 = __toESM(require_prompt())
var import_clipboard = __toESM(require_clipboard())
var import_shortcut2 = __toESM(require_shortcut())
var import_progressWindow = __toESM(require_progressWindow())
var Addon = class {
  constructor() {
    this.data = {
      alive: true,
      env: "development",
      ztoolkit: new CustomToolkit()
      // ztoolkit: new ZoteroToolkit(),
    }
    this.hooks = hooks_default
    this.api = {}
  }
}
var CustomToolkit = class extends import_basic3.BasicTool {
  constructor() {
    super()
    this.UI = new import_ui2.UITool(this)
    this.PreferencePane = new import_preferencePane.PreferencePaneManager(this)
    this.Shortcut = new import_shortcut2.ShortcutManager(this)
    this.Chat = new ChatManager(this)
    this.Prompt = new import_prompt28.PromptManager(this)
    this.Clipboard = import_clipboard.ClipboardHelper
    this.ProgressWindow = import_progressWindow.ProgressWindowHelper
    this.ProgressWindow.setIconURI("default", `chrome://${config2.addonRef}/content/icons/favicon.png`)
  }
  unregisterAll() {
    (0, import_basic3.unregister)(this)
  }
}
var addon_default = Addon

// src/constants.ts
init_process()
init_buffer()
var IS_ZOTERO_7 = Zotero.platformMajorVersion >= 102

// src/polyfills/fs.ts
init_process()
init_buffer()
var { classes: Cc, interfaces: Ci, utils: Cu } = Components
Cu.import("resource://gre/modules/FileUtils.jsm")
Cu.import("resource://gre/modules/osfile.jsm")
var fsPromises = {
  readFile: async function (filePath, options2 = { encoding: "utf-8" }) {
    try {
      let fileData = await OS.File.read(filePath, options2)
      return fileData
    } catch (error2) {
      Zotero.debug("Error reading file: " + error2)
      throw error2
    }
  },
  writeFile: async function (filePath, content, options2 = { encoding: "utf-8" }) {
    try {
      await OS.File.writeAtomic(filePath, content, Object.assign(options2, { tmpPath: filePath + ".tmp" }))
    } catch (error2) {
      Zotero.debug("Error writing file: " + error2)
      throw error2
    }
  },
  mkdir: async function (path, options2 = {}) {
    try {
      const file = Zotero.File.pathToFile(path)
      if (file.exists() && !options2.force) {
        throw new Error(`Directory already exists: ${path}`)
      }
      if (options2.recursive) {
        file.createUnique(Components.interfaces.nsIFile.DIRECTORY_TYPE, 493)
      } else {
        file.create(Components.interfaces.nsIFile.DIRECTORY_TYPE, 493)
      }
    } catch (error2) {
      console.error(error2)
      throw error2
    }
  }
}

// src/polyfills/object.ts
init_process()
init_buffer()
if (!Object.fromEntries) {
  Object.defineProperty(Object, "fromEntries", {
    value(entries) {
      if (!entries || !entries[Symbol.iterator]) {
        throw new Error("Object.fromEntries() requires a single iterable argument")
      }
      const o = {}
      Object.keys(entries).forEach((key) => {
        const [k, v] = entries[key]
        o[k] = v
      })
      return o
    }
  })
}

// src/polyfills/string.ts
init_process()
init_buffer()
if (!String.prototype.replaceAll) {
  ;
  String.prototype.replaceAll = function (search, replacement) {
    const target = this
    return target.split(search).join(replacement)
  }
}
if (!String.prototype.trimStart) {
  String.prototype.trimStart = function () {
    return this.replace(/^\s+/, "")
  }
}
if (!String.prototype.trimEnd) {
  String.prototype.trimEnd = function () {
    return this.replace(/\s+$/, "")
  }
}

// src/polyfills/error.ts
init_process()
init_buffer()
if (!Error.captureStackTrace) {
  Error.captureStackTrace = function (targetObject, constructorOpt) {
    const error2 = new Error()
    if (Error.prepareStackTrace) {
      targetObject.stack = Error.prepareStackTrace(targetObject, error2.stack)
    } else {
      targetObject.stack = error2.stack
    }
  }
}

// src/polyfills/crypto.ts
init_process()
init_buffer()
var { classes: Cc2, interfaces: Ci2 } = Components
var crypto3 = {
  randomFillSync: function (buffer) {
    const randomGenerator = Cc2["@mozilla.org/security/random-generator;1"].createInstance(Ci2.nsIRandomGenerator)
    const randomBytes = randomGenerator.generateRandomBytes(buffer.length)
    for (let i = 0; i < randomBytes.length; i++) {
      buffer[i] = randomBytes[i]
    }
  }
}

// src/polyfills/timers.ts
init_process()
init_buffer()
function setTimeout2(callback, delay) {
  let timer = Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer)
  timer.initWithCallback(callback, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT)
  return timer
}
function clearTimeout2(timer) {
  if (timer) {
    timer.cancel()
  }
}

// src/polyfills/textencoder.ts
init_process()
init_buffer()
var { TextEncoder: ZoteroTextEncoder, TextDecoder: ZoteroTextDecoder } = Components.utils.import(
  "resource://gre/modules/Services.jsm",
  {}
)

// src/libs/chains/qa.ts.test.ts
init_process()
init_buffer()
function test() {
  const OPENAI_API_KEY = Zotero.Prefs.get(`${config2.addonRef}.OPENAI_API_KEY`)
  const chatModel = new ChatOpenAI({
    temperature: 0,
    openAIApiKey: OPENAI_API_KEY,
    modelName: "gpt-3.5-turbo"
  })
  const chain = loadQAChain2(chatModel)
  const result = chain.run("What is the meaning of life?")
  Zotero.getMainWindow().alert(`What is the meaning of life? ${JSON.stringify(result)}`)
}

// src/tests.ts
var _globalThis2 = {}
if (!IS_ZOTERO_7) {
  Components.utils.importGlobalProperties(["URL", "URLSearchParams", "fetch"])
}
process.env = { ...process.env, LANGCHAIN_TRACING: true ? "true" : "false" }
var basicTool = new import_basic4.BasicTool()
if (!basicTool.getGlobal("Zotero")[config2.addonInstance]) {
  _globalThis2.Zotero = basicTool.getGlobal("Zotero")
  _globalThis2.ZoteroPane = basicTool.getGlobal("ZoteroPane")
  _globalThis2.Zotero_Tabs = basicTool.getGlobal("Zotero_Tabs")
  _globalThis2.window = basicTool.getGlobal("window")
  _globalThis2.document = basicTool.getGlobal("document")
  _globalThis2.setTimeout = setTimeout2
  _globalThis2.clearTimeout = clearTimeout2
  _globalThis2.fs = fsPromises
  _globalThis2.crypto = crypto3
  _globalThis2.TextEncoder = ZoteroTextEncoder
  _globalThis2.TextDecoder = ZoteroTextDecoder
  _globalThis2.addon = new addon_default()
  _globalThis2.ztoolkit = addon.data.ztoolkit
  ztoolkit.basicOptions.log.prefix = `[${config2.addonName}]`
  ztoolkit.basicOptions.log.disableConsole = addon.data.env === "production"
  ztoolkit.UI.basicOptions.ui.enableElementJSONLog = addon.data.env === "development"
  ztoolkit.UI.basicOptions.ui.enableElementDOMLog = addon.data.env === "development"
  ztoolkit.basicOptions.debug.disableDebugBridgePassword = addon.data.env === "development"
  Zotero[config2.addonInstance] = addon
  addon.hooks.onStartup()
}
Zotero.Promise.delay(2500).then(() => {
  test()
});
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

search-query-parser/lib/search-query-parser.js:
  (*!
   * search-query-parser.js
   * Copyright(c) 2014-2019
   * MIT Licensed
   *)
*/
